{"service_name": "travis-ci", "git": {"head": {"committer_email": "martin@phonations.com", "author_email": "martin@phonations.com", "author_name": "Martin Delille", "message": "add coveralls build-root", "committer_name": "Martin Delille", "id": "c984fb917c5d7bba0f4b3893f72bf2c925d01adb"}, "remotes": [], "branch": "mdCoveralls"}, "source_files": [{"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#include \"AboutDialog.h\"\n#include \"ui_AboutDialog.h\"\n\nAboutDialog::AboutDialog(QWidget *parent) :\n\tQDialog(parent),\n\tui(new Ui::AboutDialog)\n{\n\tui->setupUi(this);\n\tQString version = APP_NAME;\n\tversion += \" v\";\n\tversion += APP_VERSION;\n\tui->labelVersion->setText(version);\n\n\tui->labelContact->setText(\"<a href=\\\"mailto:support@phonations.com\\\">support@phonations.com</a>\");\n\tui->labelContact->setTextInteractionFlags(Qt::TextSelectableByMouse);\n\n\tui->graphicsViewIcon->setStyleSheet(\"background: transparent\");\n\n\tQGraphicsScene *scn = new QGraphicsScene( ui->graphicsViewIcon );\n\tscn->setSceneRect( ui->graphicsViewIcon->rect() );\n\tui->graphicsViewIcon->setScene( scn );\n\tui->graphicsViewIcon->setFixedSize(ui->graphicsViewIcon->width(), ui->graphicsViewIcon->height() );\n\tQPixmap pix(QCoreApplication::applicationDirPath() + PATH_TO_RESSOURCES + \"/phonationsBlack.png\");\n\tscn->addPixmap( pix );\n}\n\nAboutDialog::~AboutDialog()\n{\n\tdelete ui;\n}\n\nvoid AboutDialog::on_pushButton_clicked()\n{\n\tthis->close();\n}\n", "name": "app/Joker/AboutDialog.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef ABOUTDIALOG_H\n#define ABOUTDIALOG_H\n\n#include <QDialog>\n\nnamespace Ui {\nclass AboutDialog;\n}\n/**\n * @brief This dialog display legal and version information about Joker.\n */\nclass AboutDialog : public QDialog\n{\n\tQ_OBJECT\n\npublic:\n\t/**\n\t * @brief The AboutDialog constructor\n\t * @param parent The parent object\n\t */\n\texplicit AboutDialog(QWidget *parent = 0);\n\t~AboutDialog();\n\nprivate slots:\n\tvoid on_pushButton_clicked();\n\nprivate:\n\tUi::AboutDialog *ui;\n};\n\n#endif // ABOUTDIALOG_H\n", "name": "app/Joker/AboutDialog.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef JOKERSETTINGS_H\n#define JOKERSETTINGS_H\n\n#include <QDir>\n#include <QApplication>\n\n#include \"PhTools/PhGenericSettings.h\"\n#include \"PhGraphicStrip/PhGraphicStripSettings.h\"\n#include \"PhVideo/PhVideoSettings.h\"\n#include \"PhSync/PhSyncSettings.h\"\n#include \"PhCommonUI/PhDocumentWindowSettings.h\"\n#include \"PhCommonUI/PhFeedbackSettings.h\"\n\n\n/**\n * @brief The Joker application settings\n */\nclass JokerSettings : PhGenericSettings,\n\tpublic PhGraphicStripSettings,\n\tpublic PhVideoSettings,\n\tpublic PhSyncSettings,\n\tpublic PhDocumentWindowSettings,\n\tpublic PhFeedbackSettings\n{\npublic:\n\tPH_SETTING_INT3(setScreenDelay, screenDelay, delay)\n\n\t// PhGraphicSettings\n\tPH_SETTING_BOOL(setDisplayInfo, displayInfo)\n\tPH_SETTING_STRING2(setFontFile, fontFile, QApplication::applicationDirPath() + PATH_TO_RESSOURCES + \"/SWENSON.TTF\")\n\tPH_SETTING_BOOL(setResetInfo, resetInfo)\n\n\t// PhGraphicStripSettings :\n\tPH_SETTING_FLOAT2(setStripHeight, stripHeight, 0.25f)\n\tPH_SETTING_INT2(setHorizontalTimePerPixel, horizontalTimePerPixel, 50)\n\tPH_SETTING_INT2(setVerticalTimePerPixel, verticalTimePerPixel, 1000)\n\tPH_SETTING_STRING(setTextFontFile, textFontFile)\n\tPH_SETTING_INT2(setTextBoldness, textBoldness, 2)\n\tPH_SETTING_BOOL(setStripTestMode, stripTestMode)\n\tPH_SETTING_BOOL2(setDisplayNextText, displayNextText, true)\n\tPH_SETTING_STRINGLIST(setSelectedPeopleNameList, selectedPeopleNameList)\n\tPH_SETTING_BOOL(setInvertColor, invertColor)\n\tPH_SETTING_BOOL(setDisplayRuler, displayRuler)\n\tPH_SETTING_INT(setRulerTimeIn, rulerTimeIn)\n\tPH_SETTING_INT2(setTimeBetweenRuler, timeBetweenRuler, 24000)\n\tPH_SETTING_INT(setTimePlayed, timePlayed)\n\n\t// PhVideoSettings :\n\n\t// PhSyncSettings:\n\tPH_SETTING_BOOL2(setVideoSyncUp, videoSyncUp, true)\n\tPH_SETTING_UCHAR2(setSonyDevice1, sonyDevice1, 0xF0)\n\tPH_SETTING_UCHAR2(setSonyDevice2, sonyDevice2, 0xC0)\n\tPH_SETTING_FLOAT2(setSonyFastRate, sonyFastRate, 3)\n\tPH_SETTING_STRING2(setSonySlavePortSuffix, sonySlavePortSuffix, \"A\")\n\tPH_SETTING_STRING2(setSonyMasterPortSuffix, sonyMasterPortSuffix, \"B\")\n\n\t// PhWindowSettings\n\tPH_SETTING_BOOL(setFullScreen, fullScreen)\n\tPH_SETTING_BOOL2(setExitedNormaly, exitedNormaly, true)\n\tPH_SETTING_BYTEARRAY(setWindowGeometry, windowGeometry)\n\n\t// PhDocumentWindowSettings\n\tPH_SETTING_STRING(setCurrentDocument, currentDocument)\n\tPH_SETTING_STRING2(setLastDocumentFolder, lastDocumentFolder, QDir::homePath())\n\tPH_SETTING_STRINGLIST(setRecentDocumentList, recentDocumentList)\n\tPH_SETTING_INT2(setMaxRecentDocument, maxRecentDocument, 10)\n\tPH_SETTING_BOOL2(setAutoReload, autoReload, true)\n\n\t// PhFeedbackSettings\n\tQString settingsFileName() {\n\t\treturn _settings.fileName();\n\t}\n\tPH_SETTING_STRINGLIST(setEmailList, emailList)\n\n\t// PeopleDialog\n\tPH_SETTING_BYTEARRAY(setPeopleDialogGeometry, peopleDialogGeometry)\n\n\t// Other settings :\n\tPH_SETTING_STRING(setLastVideoFolder, lastVideoFolder)\n\tPH_SETTING_STRING2(setSelectedFilter, selectedFilter, \"Rythmo files (*.detx *.strip)\")\n\n\tPH_SETTING_INT(setSynchroProtocol, synchroProtocol)\n\tPH_SETTING_STRING(setLTCInputDevice, ltcInputDevice)\n\n\tPH_SETTING_INT2(setLogMask, logMask, 1)\n\n\tPH_SETTING_BOOL2(setDisplayTitle, displayTitle, true)\n\tPH_SETTING_BOOL2(setDisplayNextTC, displayNextTC, true)\n\tPH_SETTING_BOOL2(setDisplayTC, displayTC, true)\n\tPH_SETTING_BOOL2(setDisplayLoop, displayLoop, true)\n\n\tPH_SETTING_BOOL(setUseQuarterFrame, useQuarterFrame)\n\n\tPH_SETTING_STRING2(setVideoFileFilter, videoFileFilter, \" (*.m4v *.mkv *.avi *.mov *.mxf)\")\n\n\tPH_SETTING_BOOL2(setDisplayLogo, displayLogo, true)\n\n\tPH_SETTING_STRING(setLanguage, language)\n\n\tPH_SETTING_BOOL(setHideStrip, hideStrip)\n};\n\n#endif // JOKERSETTINGS_H\n", "name": "app/Joker/JokerSettings.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#include \"JokerWindow.h\"\n#include \"ui_JokerWindow.h\"\n\n#include <QFileDialog>\n#include <QFontDialog>\n#include <QFileOpenEvent>\n#include <QDragEnterEvent>\n#include <QMimeData>\n#include <QWindowStateChangeEvent>\n#include <QMouseEvent>\n\n#include \"PhTools/PhDebug.h\"\n#include \"PhCommonUI/PhTimeCodeDialog.h\"\n#include \"PhCommonUI/PhFeedbackDialog.h\"\n#include \"AboutDialog.h\"\n#include \"PreferencesDialog.h\"\n#include \"PeopleDialog.h\"\n\nJokerWindow::JokerWindow(JokerSettings *settings) :\n\tPhDocumentWindow(settings),\n\tui(new Ui::JokerWindow),\n\t_settings(settings),\n\t_sonySlave(PhTimeCodeType25, settings),\n\t_mediaPanelAnimation(&_mediaPanel, \"windowOpacity\"),\n\t_needToSave(false),\n\t_firstDoc(true),\n\t_numberOfDraw(0)\n{\n\t// Setting up UI\n\tui->setupUi(this);\n\n\t// Due to translation, Qt might not be able to link automatically the menu\n\tui->actionPreferences->setMenuRole(QAction::PreferencesRole);\n\tui->actionAbout->setMenuRole(QAction::AboutRole);\n\n\tconnect(ui->actionFullscreen, SIGNAL(triggered()), this, SLOT(toggleFullScreen()));\n\n\t// Get the pointer to the differents objects :\n\t// strip, video engine and doc\n\t_strip = ui->videoStripView->strip();\n\t_videoEngine = ui->videoStripView->videoEngine();\n\t_doc = _strip->doc();\n\n\t// Pass the settings to the modules\n\t_strip->setSettings(_settings);\n\t_videoEngine->setSettings(_settings);\n\tui->videoStripView->setSettings(_settings);\n\n\t// Initialize the property dialog\n\t_propertyDialog.setDoc(_doc);\n\t_propertyDialog.setVideoEngine(_videoEngine);\n\n\t// Initialize the synchronizer\n\t_synchronizer.setStripClock(_strip->clock());\n\t_synchronizer.setVideoClock(_videoEngine->clock());\n\n\tsetupSyncProtocol();\n\n\t// Setting up the media panel\n\t_mediaPanel.setClock(_strip->clock());\n#warning /// @todo move to CSS file\n\t_mediaPanel.setStyleSheet(\n\t    \"* {\"\n\t    \"\t  color: white;\"\n\t    \"  }\"\n\t    \"  PhMediaPanel { \"\n\t    \"\t  background: qlineargradient(x1: 1, y1: 0, x2: 1, y2: 1, stop: 0 rgb(40,40,40), stop: 1 black);\"\n\t    \"\t  border-style: solid;                                                                          \"\n\t    \"\t  border-width: 4px;                                                                            \"\n\t    \"\t  border-radius: 3px;                                                                           \"\n\t    \"\t  border-color: white;                                                                          \"\n\t    \"  }                                                                                                \"\n\t    \"  QPushButton, QComboBox{                                                                          \"\n\t    \"\t  background: grey;                                                                             \"\n\t    \"\t  border-style: outset;                                                                         \"\n\t    \"\t  border-width: 2px;                                                                            \"\n\t    \"\t  border-radius: 5px;                                                                           \"\n\t    \"\t  border-color: white;                                                                          \"\n\t    \"  }                                                                                                \"\n\t    \"  QLabel#_timecodeLabel{                                                                           \"\n\t    \"\t  padding: 10px;                                                                                \"\n\t    \"  }                                                                                                \"\n\t    );\n\n\tthis->setFocus();\n\n\tif(_settings->stripTestMode()) {\n#warning /// @todo do we warn the user that test mode is on?\n\t\tui->actionTest_mode->setChecked(true);\n\t}\n\n#warning /// @todo move to PhDocumentWindow\n\t// This is for the drag and drop feature\n\tsetAcceptDrops(true);\n\n\tui->actionInvert_colors->setChecked(_settings->invertColor());\n\n\tui->actionShow_ruler->setChecked(_settings->displayRuler());\n\n\tui->actionHide_the_rythmo->setChecked(_settings->hideStrip());\n\n\tif(!_settings->exitedNormaly())\n\t\ton_actionSend_feedback_triggered();\n\n\t_settings->setExitedNormaly(false);\n\n\t_mediaPanel.show();\n\t_mediaPanelState = MediaPanelVisible;\n\n\t// Trigger a timer that will fade off the media panel after 3 seconds\n\tthis->connect(&_mediaPanelTimer, SIGNAL(timeout()), this, SLOT(fadeOutMediaPanel()));\n\t_mediaPanelTimer.start(3000);\n\n\tthis->connect(ui->videoStripView, SIGNAL(beforePaint(PhTimeScale)), this, SLOT(timeCounter(PhTimeScale)));\n}\n\nJokerWindow::~JokerWindow()\n{\n\tdelete ui;\n}\n\nvoid JokerWindow::setupSyncProtocol()\n{\n\tPhClock* clock = NULL;\n\n\t// Disable old protocol\n\t_sonySlave.close();\n\t_ltcReader.close();\n\n\tSynchronizer::SyncType type = (Synchronizer::SyncType)_settings->synchroProtocol();\n\n\tswitch(type) {\n\tcase Synchronizer::Sony:\n\t\t// Initialize the sony module\n\t\tif(_sonySlave.open()) {\n\t\t\tclock = _sonySlave.clock();\n\t\t\tui->videoStripView->setSony(&_sonySlave);\n\t\t}\n\t\telse {\n\t\t\ttype = Synchronizer::NoSync;\n\t\t\tQMessageBox::critical(this, \"\", \"Unable to connect to USB422v module\");\n\t\t}\n\t\tbreak;\n\tcase Synchronizer::LTC:\n\t\t{\n\t\t\tQString input = _settings->ltcInputDevice();\n\t\t\tif(_ltcReader.init(input))\n\t\t\t\tclock = _ltcReader.clock();\n\t\t\telse {\n\t\t\t\tQMessageBox::critical(this, \"\", \"Unable to open \" + input);\n\t\t\t\ttype = Synchronizer::NoSync;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\tcase Synchronizer::NoSync:\n\t\tbreak;\n\t}\n\n\t_synchronizer.setSyncClock(clock, type);\n\n\t// Disable slide if Joker is sync to a protocol\n\t_mediaPanel.setSliderEnable(clock == NULL);\n\n\t_settings->setSynchroProtocol(type);\n}\n\nbool JokerWindow::openDocument(QString fileName)\n{\n\t/// Clear the selected people name list (except for the first document).\n\tif(!_firstDoc)\n\t\t_settings->setSelectedPeopleNameList(QStringList());\n\telse\n\t\t_firstDoc = false;\n\n\tif(!_doc->openStripFile(fileName))\n\t\treturn false;\n\n\t/// If the document is opened successfully :\n\t/// - Update the current document name (settings, windows title)\n\tsetCurrentDocument(fileName);\n\t_watcher.addPath(_doc->filePath());\n\n\t/// - Open the corresponding video file if it exists.\n\tif(openVideoFile(_doc->videoFilePath())) {\n\t\tPhFrame frameIn = _doc->videoFrameIn();\n\t\t_videoEngine->setFirstFrame(frameIn);\n\t\t_videoEngine->setDeinterlace(_doc->videoDeinterlace());\n\t\tui->actionDeinterlace_video->setChecked(_doc->videoDeinterlace());\n\t\t_mediaPanel.setFirstFrame(frameIn);\n\t}\n\telse\n\t\t_videoEngine->close();\n\n\n\t/// - Set the video aspect ratio.\n\tui->actionForce_16_9_ratio->setChecked(_doc->forceRatio169());\n\tui->videoStripView->setForceRatio169(_doc->forceRatio169());\n\n\t/// - Use the document timecode type.\n\t_strip->clock()->setTimeCodeType(_doc->timeCodeType());\n\t/// - Goto to the document last position.\n\t_strip->clock()->setTime(_doc->lastTime());\n\t/// - Disable the need to save flag.\n\t_needToSave = false;\n\n\treturn true;\n}\n\nbool JokerWindow::eventFilter(QObject * sender, QEvent *event)\n{\n\t/// The event filter catch the following event:\n\tswitch (event->type()) {\n\tcase QEvent::FileOpen: /// - FileOpen : To process a file dragged on the application dock icon (MacOS)\n\t\t{\n#warning /// @todo move to PhDocumentWindow\n\t\t\tQString filePath = static_cast<QFileOpenEvent *>(event)->file();\n\t\t\tQString fileType = filePath.split(\".\").last().toLower();\n\t\t\t// As the plist file list all the supported format (which are .joker, .strip, .detx, .avi & .mov)\n\t\t\t// if the file is not a strip or a detx file, it's a video file, we don't need any protection\n\t\t\tif(fileType == \"detx\" or fileType == \"strip\" or fileType == \"joker\") {\n\t\t\t\tif(checkSaveFile())\n\t\t\t\t\topenDocument(filePath);\n\t\t\t}\n\t\t\telse\n\t\t\t\topenVideoFile(filePath);\n\t\t\tbreak;\n\t\t}\n\tcase QEvent::ApplicationDeactivate: /// - ApplicationDeactivate : to hide the mediapanel\n\t\thideMediaPanel();\n\t\tbreak;\n\tcase QEvent::MouseMove: /// - Mouse move show the media panel\n\t\tfadeInMediaPanel();\n\t\tbreak;\n\tcase QEvent::DragEnter: /// - Accept and process a file drop on the window\n\t\tevent->accept();\n\t\tbreak;\n\tcase QEvent::Drop:\n\t\t{\n#warning /// @todo move to PhDocumentWindow\n\t\t\tconst QMimeData* mimeData = static_cast<QDropEvent *>(event)->mimeData();\n\n\t\t\t// If there is one file (not more) we open it\n\t\t\tif (mimeData->urls().length() == 1) {\n\t\t\t\tQString filePath = mimeData->urls().first().toLocalFile();\n\t\t\t\tQString fileType = filePath.split(\".\").last().toLower();\n\t\t\t\tif(fileType == \"detx\" or fileType == \"strip\" or fileType == \"joker\") {\n\t\t\t\t\tif(checkSaveFile())\n\t\t\t\t\t\topenDocument(filePath);\n\t\t\t\t}\n\t\t\t\telse if (fileType == \"avi\" or fileType == \"mov\")\n\t\t\t\t\topenVideoFile(filePath);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\tcase QEvent::MouseButtonDblClick: /// - Double mouse click toggle fullscreen mode\n\t\tif(sender == this)\n\t\t\ttoggleFullScreen();\n\t\tbreak;\n\tcase QEvent::MouseButtonPress:\n\t\t{\n\t\t\tQMouseEvent *mouseEvent = (QMouseEvent*)event;\n\t\t\t//PHDEBUG << sender << mouseEvent->buttons() << mouseEvent->pos() << this->pos();\n\t\t\tif((sender == this) && (mouseEvent->buttons() & Qt::RightButton)) {\n\t\t\t\t/// - Right mouse click on the video open the video file dialog.\n\t\t\t\tif(mouseEvent->y() < this->height() * (1.0f - _settings->stripHeight()))\n\t\t\t\t\ton_actionOpen_Video_triggered();\n\t\t\t\telse /// - Left mouse click on the strip open the strip file dialog.\n\t\t\t\t\ton_actionOpen_triggered();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn PhDocumentWindow::eventFilter(sender, event);\n}\n\nQMenu *JokerWindow::recentDocumentMenu()\n{\n\treturn ui->menuOpen_recent;\n}\n\nQAction *JokerWindow::fullScreenAction()\n{\n\treturn ui->actionFullscreen;\n}\n\nvoid JokerWindow::closeEvent(QCloseEvent *event)\n{\n\t/// Check if the current document has to be saved (it might cancel the action).\n\tif(!checkSaveFile())\n\t\tevent->ignore();\n\telse /// Close the PhMediaPanel.\n\t\t_mediaPanel.close();\n}\n\nvoid JokerWindow::on_actionOpen_triggered()\n{\n\thideMediaPanel();\n\n\tif(checkSaveFile()) {\n\t\tQString filter = tr(\"Rythmo files\") + \" (*.joker *.detx *.mos *.strip);; \"\n\t\t                 + tr(\"Joker files\") + \" (*.joker);; \"\n\t\t                 + tr(\"DetX files\") + \" (*.detx);; \"\n\t\t                 + tr(\"Mosaic files\") + \" (*.mos);; \"\n\t\t                 + tr(\"All files\") + \" (*.*)\";\n\t\tQFileDialog dlg(this, tr(\"Open...\"), _settings->lastDocumentFolder(), filter);\n\n\t\tdlg.selectNameFilter(_settings->selectedFilter());\n\t\tdlg.setOption(QFileDialog::HideNameFilterDetails, false);\n\n\t\tdlg.setFileMode(QFileDialog::ExistingFile);\n\t\tif(dlg.exec()) {\n\t\t\tQString fileName = dlg.selectedFiles()[0];\n\t\t\topenDocument(fileName);\n\t\t\t_settings->setSelectedFilter(dlg.selectedNameFilter());\n\t\t}\n\t}\n\tfadeInMediaPanel();\n}\n\nvoid JokerWindow::on_actionPlay_pause_triggered()\n{\n\tif(_strip->clock()->rate() == 0.0)\n\t\t_strip->clock()->setRate(1.0);\n\telse\n\t\t_strip->clock()->setRate(0.0);\n}\n\nvoid JokerWindow::on_actionPlay_backward_triggered()\n{\n\t_strip->clock()->setRate(-1.0);\n}\n\nvoid JokerWindow::on_actionStep_forward_triggered()\n{\n\t_strip->clock()->setRate(0.0);\n\t_strip->clock()->setFrame(_strip->clock()->frame() + 1);\n}\n\nvoid JokerWindow::on_actionStep_backward_triggered()\n{\n\t_strip->clock()->setRate(0.0);\n\t_strip->clock()->setFrame(_strip->clock()->frame() - 1);\n}\n\nvoid JokerWindow::on_actionStep_time_forward_triggered()\n{\n\t_strip->clock()->setRate(0.0);\n\t_strip->clock()->setTime(_strip->clock()->time() + 1);\n}\n\nvoid JokerWindow::on_actionStep_time_backward_triggered()\n{\n\t_strip->clock()->setRate(0.0);\n\t_strip->clock()->setTime(_strip->clock()->time() - 1);\n}\n\nvoid JokerWindow::on_action_3_triggered()\n{\n\t_strip->clock()->setRate(-3.0);\n}\n\nvoid JokerWindow::on_action_1_triggered()\n{\n\t_strip->clock()->setRate(-1.0);\n}\n\nvoid JokerWindow::on_action_0_5_triggered()\n{\n\t_strip->clock()->setRate(-0.5);\n}\n\nvoid JokerWindow::on_action0_triggered()\n{\n\t_strip->clock()->setRate(0.0);\n}\n\nvoid JokerWindow::on_action0_5_triggered()\n{\n\t_strip->clock()->setRate(0.5);\n}\n\nvoid JokerWindow::on_action1_triggered()\n{\n\t_strip->clock()->setRate(1.0);\n}\n\nvoid JokerWindow::on_action3_triggered()\n{\n\t_strip->clock()->setRate(3.0);\n}\n\nvoid JokerWindow::on_actionOpen_Video_triggered()\n{\n\thideMediaPanel();\n\n\tQString lastFolder = _settings->lastVideoFolder();\n\tQString filter = tr(\"Movie files\") + _settings->videoFileFilter()\n\t                 + \";;\" + tr(\"All files\") + \" (*.*)\";\n\n\tQFileDialog dlg(this, tr(\"Open a video...\"), lastFolder, filter);\n\tif(dlg.exec()) {\n\t\tQString videoFile = dlg.selectedFiles()[0];\n\t\tif(openVideoFile(videoFile))\n\t\t\t_strip->clock()->setTime(_doc->videoTimeIn());\n\t}\n\n\tfadeInMediaPanel();\n}\n\nbool JokerWindow::openVideoFile(QString videoFile)\n{\n\tQFileInfo lastFileInfo(_doc->videoFilePath());\n\tQFileInfo fileInfo(videoFile);\n\tif (fileInfo.exists() && _videoEngine->open(videoFile)) {\n\t\tPhFrame frameIn = _videoEngine->firstFrame();\n\n\t\t_mediaPanel.setFirstFrame(frameIn);\n\t\t_mediaPanel.setMediaLength(_videoEngine->length());\n\n\t\tif(videoFile != _doc->videoFilePath()) {\n\t\t\t_doc->setVideoFilePath(videoFile);\n\t\t\tif(frameIn > 0)\n\t\t\t\t_doc->setVideoFrameIn(frameIn);\n\t\t\t_needToSave = true;\n\t\t}\n\n\t\tif(frameIn == 0) {\n\t\t\tframeIn = _doc->videoFrameIn();\n\t\t\t_videoEngine->setFirstFrame(frameIn);\n\t\t\t_videoEngine->clock()->setFrame(frameIn);\n\t\t\tif(fileInfo.fileName() != lastFileInfo.fileName()) {\n\t\t\t\ton_actionChange_timestamp_triggered();\n\t\t\t\tframeIn = _videoEngine->firstFrame();\n\t\t\t}\n\t\t}\n\n\t\t_videoEngine->clock()->setFrame(frameIn);\n\n\t\t_settings->setLastVideoFolder(fileInfo.absolutePath());\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nvoid JokerWindow::timeCounter(PhTimeScale frequency)\n{\n\tif(_strip->clock()->rate() == 1 && (Synchronizer::SyncType)_settings->synchroProtocol() != Synchronizer::NoSync) {\n\t\t_numberOfDraw++;\n\t\tif(_numberOfDraw >= frequency) {\n\t\t\t_numberOfDraw = 0;\n\t\t\t_settings->setTimePlayed(_settings->timePlayed() + 1);\n\t\t}\n\t}\n}\n\nvoid JokerWindow::on_actionChange_timestamp_triggered()\n{\n\thideMediaPanel();\n\t_strip->clock()->setRate(0);\n\tPhFrame frame;\n\tif(_synchronizer.videoClock()->frame() < _videoEngine->firstFrame())\n\t\tframe = _videoEngine->firstFrame();\n\telse if(_synchronizer.videoClock()->frame() > _videoEngine->firstFrame() + _videoEngine->length())\n\t\tframe = _videoEngine->lastFrame();\n\telse\n\t\tframe = _synchronizer.videoClock()->frame();\n\n\tPhTimeCodeDialog dlg(_strip->clock()->timeCodeType(), frame);\n\tif(dlg.exec() == QDialog::Accepted) {\n\t\tPhFrame frameStamp;\n\t\tif(_synchronizer.videoClock()->frame() > _videoEngine->firstFrame() + _videoEngine->length())\n\t\t\tframeStamp = dlg.frame() - (_videoEngine->length() - 1);\n\t\telse if (_synchronizer.videoClock()->frame() < _videoEngine->firstFrame())\n\t\t\tframeStamp =  dlg.frame();\n\t\telse\n\t\t\tframeStamp = _videoEngine->firstFrame() + dlg.frame() - _synchronizer.videoClock()->frame();\n\n\t\t_videoEngine->setFirstFrame(frameStamp);\n\t\t_strip->clock()->setFrame(dlg.frame());\n\t\t_doc->setVideoFrameIn(frameStamp);\n\t\t_mediaPanel.setFirstFrame(frameStamp);\n\t\t_needToSave = true;\n\t}\n\n\tfadeInMediaPanel();\n}\n\n\n\nvoid JokerWindow::on_actionAbout_triggered()\n{\n\thideMediaPanel();\n\n\tAboutDialog menu;\n\tmenu.exec();\n\n\tfadeInMediaPanel();\n}\n\n\nvoid JokerWindow::on_actionPreferences_triggered()\n{\n\thideMediaPanel();\n\tint oldSynchroProtocol = _settings->synchroProtocol();\n\tQString oldLTCInputDevice = _settings->ltcInputDevice();\n\n\tPreferencesDialog dlg(_settings);\n\tdlg.exec();\n\tif((oldSynchroProtocol != _settings->synchroProtocol()) || (oldLTCInputDevice != _settings->ltcInputDevice())) {\n\t\tPHDEBUG << \"Set protocol:\" << _settings->synchroProtocol();\n\t\tsetupSyncProtocol();\n\t}\n\n\tfadeInMediaPanel();\n}\n\nvoid JokerWindow::fadeInMediaPanel()\n{\n\t// Don't show the mediaPanel if Joker has not thefocus.\n\tif(!this->hasFocus())\n\t\treturn;\n\t// Don't show the mediaPanel if Joker is remote controled.\n\tif(_settings->synchroProtocol() != Synchronizer::NoSync)\n\t\treturn;\n\n\t_mediaPanel.show();\n\t_mediaPanelAnimation.stop();\n\t_mediaPanelAnimation.setDuration(300);\n\t_mediaPanelAnimation.setEndValue(1);\n\t_mediaPanelAnimation.setEasingCurve(QEasingCurve::InOutSine);\n\t_mediaPanelAnimation.start();\n\t_mediaPanelState = MediaPanelVisible;\n\t_mediaPanelTimer.start(3000);\n}\n\nvoid JokerWindow::fadeOutMediaPanel()\n{\n\t// Don't fade out the media panel if the mouse is over it\n\tif(_mediaPanel.underMouse() or _mediaPanel.isMousePressed()) {\n\t\tPHDEBUG << \"Don't hide\";\n\t\t_mediaPanelTimer.start(3000);\n\t\treturn;\n\t}\n\n\tPHDEBUG << _mediaPanelState;\n\tswitch(_mediaPanelState) {\n\tcase MediaPanelVisible:\n\t\tPHDEBUG << \"Hiding\";\n\t\t_mediaPanelAnimation.setDuration(1000);\n\t\t_mediaPanelAnimation.setEndValue(0);\n\t\t_mediaPanelAnimation.setEasingCurve(QEasingCurve::InOutSine);\n\t\t_mediaPanelAnimation.start();\n\t\t_mediaPanelTimer.start(1000);\n\t\t_mediaPanelState = MediaPanelHidding;\n\t\tbreak;\n\tcase MediaPanelHidding:\n\t\thideMediaPanel();\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nvoid JokerWindow::hideMediaPanel()\n{\n\t_mediaPanel.hide();\n\t_mediaPanelState = MediaPanelHidden;\n\t_mediaPanelTimer.stop();\n}\n\n\nvoid JokerWindow::on_actionProperties_triggered()\n{\n\t_propertyDialog.show();\n}\n\nvoid JokerWindow::on_actionTest_mode_triggered()\n{\n\t_settings->setStripTestMode(!_settings->stripTestMode());\n}\n\nvoid JokerWindow::on_actionTimecode_triggered()\n{\n\thideMediaPanel();\n\n\tPhTimeCodeDialog dlg(_strip->clock()->timeCodeType(), _strip->clock()->frame());\n\tif(dlg.exec() == QDialog::Accepted)\n\t\t_strip->clock()->setFrame(dlg.frame());\n\n\tfadeInMediaPanel();\n}\n\nvoid JokerWindow::on_actionNext_element_triggered()\n{\n\tPhTime time = _doc->nextElementTime(_strip->clock()->time());\n\tif(time < PHTIMEMAX)\n\t\t_strip->clock()->setTime(time);\n}\n\nvoid JokerWindow::on_actionPrevious_element_triggered()\n{\n\tPhTime time = _doc->previousElementTime(_strip->clock()->time());\n\tif(time > PHTIMEMIN)\n\t\t_strip->clock()->setTime(time);\n}\n\nvoid JokerWindow::on_actionClear_list_triggered()\n{\n\t//Open the recent group\n\t//\t_settings->beginGroup(\"openRecent\");\n\t//\t//List all keys\n\t//\tQStringList indexes = _settings->allKeys();\n\t//\t//Remove them from\n\t//\tforeach(QString index, indexes)\n\t//\t_settings->remove(index);\n\n\t//\t//Close the group\n\t//\t_settings->endGroup();\n\n\t//Remove the buttons of the UI, keep the separator and the Clear button\n\tforeach(QAction * action, ui->menuOpen_recent->actions())\n\t{\n\t\t// Break if the separator is reached\n\t\tif(action->isSeparator())\n\t\t\tbreak;\n\t\t// Remove it\n\t\tui->menuOpen_recent->removeAction(action);\n\t\tdelete action;\n\t}\n\n\t// Remove all the buttons\n\t//\t_recentFileButtons.clear();\n\tui->menuOpen_recent->setEnabled(false);\n}\n\nvoid JokerWindow::on_actionSave_triggered()\n{\n\tQString fileName = _settings->currentDocument();\n\tQFileInfo info(fileName);\n\tif(!info.exists() || (info.suffix() != \"joker\"))\n\t\ton_actionSave_as_triggered();\n\telse if(_doc->saveStripFile(fileName, _strip->clock()->timeCode()))\n\t\t_needToSave = false;\n\telse\n\t\tQMessageBox::critical(this, \"\", tr(\"Unable to save \") + fileName);\n}\n\nvoid JokerWindow::on_actionSave_as_triggered()\n{\n\thideMediaPanel();\n\n\tQString fileName = _settings->currentDocument();\n\tQString lastFolder = _settings->lastDocumentFolder();\n\t// If there is no current strip file, ask for a name\n\tif(fileName == \"\")\n\t\tfileName = lastFolder;\n\telse {\n\t\tQFileInfo info(fileName);\n\t\tif(info.suffix() != \"joker\")\n\t\t\tfileName = lastFolder + \"/\" + info.completeBaseName() + \".joker\";\n\t}\n\n\tfileName = QFileDialog::getSaveFileName(this, tr(\"Save...\"), fileName, \"*.joker\");\n\tif(fileName != \"\") {\n\t\tif(_doc->saveStripFile(fileName, _strip->clock()->timeCode())) {\n\t\t\t_needToSave = false;\n\t\t\tsetCurrentDocument(fileName);\n\t\t}\n\t\telse\n\t\t\tQMessageBox::critical(this, \"\", tr(\"Unable to save \") + fileName);\n\t}\n}\n\nbool JokerWindow::checkSaveFile()\n{\n\n\tif(_needToSave) {\n\t\t/// If the document need to be saved, ask the user\n\t\t/// whether he wants to save his changes.\n\t\tQString msg = tr(\"Do you want to save your changes ?\");\n\t\tQMessageBox box(QMessageBox::Question, \"\", msg, QMessageBox::Save | QMessageBox::No | QMessageBox::Cancel);\n\t\tbox.setDefaultButton(QMessageBox::Save);\n\t\tswitch(box.exec()) {\n\t\t/// Cancel the caller action if clicking cancel.\n\t\tcase QMessageBox::Cancel:\n\t\t\treturn false;\n\t\t/// Trigger the document save if clicking save:\n\t\tcase QMessageBox::Save:\n\t\t\ton_actionSave_triggered();\n\t\t\t/// If the user cancel the save operation, cancel the operation.\n\t\t\tif(_needToSave)\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\t}\n\t}\n\t/// @return False to interrupt the caller action, true otherwhise.\n\treturn true;\n}\n\nvoid JokerWindow::on_actionSelect_character_triggered()\n{\n\thideMediaPanel();\n\n\tPeopleDialog dlg(this, _doc, _settings);\n\n\tdlg.restoreGeometry(_settings->peopleDialogGeometry());\n\tdlg.exec();\n\t_settings->setPeopleDialogGeometry(dlg.saveGeometry());\n}\n\nvoid JokerWindow::on_actionForce_16_9_ratio_triggered()\n{\n\tui->videoStripView->setForceRatio169(ui->actionForce_16_9_ratio->isChecked());\n\t_needToSave = true;\n}\n\nvoid JokerWindow::on_actionInvert_colors_toggled(bool checked)\n{\n\t_settings->setInvertColor(checked);\n}\n\nvoid JokerWindow::on_actionShow_ruler_toggled(bool display)\n{\n\t_settings->setDisplayRuler(display);\n}\n\nvoid JokerWindow::on_actionChange_ruler_timestamp_triggered()\n{\n\tPhTimeCodeType tcType = _doc->timeCodeType();\n\tPhTimeCodeDialog dlg(tcType, _settings->rulerTimeIn() / PhTimeCode::timePerFrame(tcType), this);\n\tif(dlg.exec())\n\t\t_settings->setRulerTimeIn(dlg.frame() * PhTimeCode::timePerFrame(tcType));\n}\n\nvoid JokerWindow::on_actionNew_triggered()\n{\n\t_doc->reset();\n\ton_actionClose_video_triggered();\n}\n\nvoid JokerWindow::on_actionClose_video_triggered()\n{\n\t_videoEngine->close();\n}\n\nvoid JokerWindow::on_actionSend_feedback_triggered()\n{\n\thideMediaPanel();\n\tPhFeedbackDialog dlg(_settings, this);\n\tdlg.exec();\n\tfadeInMediaPanel();\n}\n\nvoid JokerWindow::on_actionDeinterlace_video_triggered(bool checked)\n{\n\t_videoEngine->setDeinterlace(checked);\n\tif(checked != _doc->videoDeinterlace()) {\n\t\t_doc->setVideoDeinterlace(checked);\n\t\t_needToSave = true;\n\t}\n}\n\nvoid JokerWindow::on_actionHide_the_rythmo_triggered(bool checked)\n{\n\t_settings->setHideStrip(checked);\n}\n", "name": "app/Joker/JokerWindow.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "///\n/// @file\n/// @copyright (C) 2012-2014 Phonations\n/// @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n///\n\n#ifndef JOKERWINDOW_H\n#define JOKERWINDOW_H\n\n#include <QMessageBox>\n#include <QPropertyAnimation>\n\n#include \"PhSync/PhSonySlaveController.h\"\n#include \"PhCommonUI/PhFloatingMediaPanel.h\"\n#include \"PhSync/PhLtcReader.h\"\n\n#include \"PhCommonUI/PhDocumentWindow.h\"\n#include \"VideoStripView.h\"\n#include \"Synchronizer.h\"\n#include \"PropertyDialog.h\"\n#include \"JokerSettings.h\"\n\nnamespace Ui {\nclass JokerWindow;\n}\n\n///\n/// @brief Joker main application window\n///\n/// The JokerWindow class implements the main screen user interface behaviour:\n/// - Display the VideoStripView\n/// - Handling PhFloatingMediaPanel behaviour\n/// - Opening application dialog : preferences, open file, open video file, save , display properties, timestamp, people selection\n/// - Display properties dialog\n/// - Handling controls command\n/// - Connect the application modules: PhVideoEngine, PhGraphicStrip, Synchronizer, PhSonySlaveController, PhLtcReader\n///\nclass JokerWindow : public PhDocumentWindow\n{\n\tQ_OBJECT\n\npublic:\n\t///\n\t/// @brief JokerWindow The JokerWindow constructor\n\t///\n\t/// @param settings The application settings\n\t///\n\texplicit JokerWindow(JokerSettings *settings);\n\t~JokerWindow();\n\n\t///\n\t/// @brief Open a video file\n\t///\n\t/// Open a videofile and set the framestamp to the videofile's value or the strip's value if the first one is not usable.\n\t///\n\t/// @param videoFile The videofile path\n\t///\n\t/// @return True if the videoFile opened well, false otherwise.\n\t///\n\tbool openVideoFile(QString videoFile);\n\npublic slots:\n\t///\n\t/// \\brief timeCounter Slot used to count the time played on nominal speed\n\t/// when the synchro is enabled\n\t///\n\t/// \\param frequency\n\t///\n\tvoid timeCounter(PhTimeScale frequency);\n\nprotected:\n\t///\n\t/// @brief Open all supported strip file\n\t///\n\t/// @param filePath The file path\n\t///\n\tbool openDocument(QString filePath);\n\n\t///\n\t/// @brief Custom event filter\n\t///\n\t/// @param sender The event sender\n\t/// @param event The event\n\t/// @return True if handled, false otherwise\n\t///\n\tbool eventFilter(QObject *sender, QEvent *event);\n\n\t///\n\t/// @brief The PhFloatingMediaPanel state enumeration\n\t///\n\t/// The enumeration is used to handle the different state of the PhFloatingMediaPanel:\n\t/// visible, hidding and hidden for a best fade-in and fade-out effect.\n\t///\n\tenum MediaPanelState {\n\t\tMediaPanelVisible,\n\t\tMediaPanelHidding,\n\t\tMediaPanelHidden\n\t};\n\n\t///\n\t/// @brief Give the ui->menuOpen_recent item to PhDocumentWindow\n\t///\n\t/// PhDocumentWindow will fill the submenu item with the\n\t/// last document opened when calling setCurrentDocument().\n\t/// The max number of item is the PhDocumentWindowSettings::maxRecentDocument().\n\t///\n\t/// @return A reference to the menu item\n\t///\n\tQMenu *recentDocumentMenu();\n\n\t///\n\t/// @brief Give the ui->actionFullscreen to PhWindow\n\t///\n\t/// PhWindow will make it checkable and check and uncheck it\n\t/// each time the user toggle between fullscreen and normal.\n\t/// The action must be connected in JokerWindow constructor.\n\t/// @todo connect the action with PhWindow\n\t/// @return A reference to the action\n\t///\n\tQAction *fullScreenAction();\n\n\t///\n\t/// @brief Setup the synchronisation protocol\n\t///\n\t/// Close all the protocol if opened and setup the one specified\n\t/// by the settings.\n\t/// If it failed to open a protocol, go to the NoSync mode (and store\n\t/// it in the settings).\n\t/// The PhMediaPanel slider is enabled only in the NoSync mode.\n\t///\n\tvoid setupSyncProtocol();\n\n\t///\n\t/// @brief Event called when the user try to close the window.\n\t///\n\t/// @param event The event\n\t///\n\tvoid closeEvent(QCloseEvent *event);\n\n\t///\n\t/// @brief Check if the current document need to be save.\n\t///\n\tbool checkSaveFile();\n\nprivate slots:\n\t// Qt Designer slots\n\tvoid on_actionOpen_triggered();\n\n\tvoid on_actionPlay_pause_triggered();\n\n\tvoid on_actionPlay_backward_triggered();\n\n\tvoid on_actionStep_forward_triggered();\n\n\tvoid on_actionStep_backward_triggered();\n\n\tvoid on_actionStep_time_forward_triggered();\n\n\tvoid on_actionStep_time_backward_triggered();\n\n\tvoid on_action_3_triggered();\n\n\tvoid on_action_1_triggered();\n\n\tvoid on_action_0_5_triggered();\n\n\tvoid on_action0_triggered();\n\n\tvoid on_action0_5_triggered();\n\n\tvoid on_action1_triggered();\n\n\tvoid on_action3_triggered();\n\n\tvoid on_actionOpen_Video_triggered();\n\n\tvoid on_actionChange_timestamp_triggered();\n\n\tvoid on_actionAbout_triggered();\n\n\tvoid on_actionPreferences_triggered();\n\n\tvoid on_actionClear_list_triggered();\n\n\n\t// Custom slots\n\n\tvoid fadeInMediaPanel();\n\n\tvoid fadeOutMediaPanel();\n\n\tvoid hideMediaPanel();\n\n\tvoid on_actionProperties_triggered();\n\n\tvoid on_actionTest_mode_triggered();\n\n\tvoid on_actionTimecode_triggered();\n\n\tvoid on_actionNext_element_triggered();\n\n\tvoid on_actionPrevious_element_triggered();\n\n\tvoid on_actionSave_triggered();\n\n\tvoid on_actionSave_as_triggered();\n\n\tvoid on_actionSelect_character_triggered();\n\n\tvoid on_actionForce_16_9_ratio_triggered();\n\n\tvoid on_actionInvert_colors_toggled(bool checked);\n\n\tvoid on_actionShow_ruler_toggled(bool arg1);\n\n\tvoid on_actionChange_ruler_timestamp_triggered();\n\n\tvoid on_actionNew_triggered();\n\n\tvoid on_actionClose_video_triggered();\n\n\tvoid on_actionSend_feedback_triggered();\n\n\tvoid on_actionDeinterlace_video_triggered(bool checked);\n\n\tvoid on_actionHide_the_rythmo_triggered(bool checked);\n\nprivate:\n\tUi::JokerWindow *ui;\n\tPhGraphicStrip * _strip;\n\tPhVideoEngine * _videoEngine;\n\tPhStripDoc *_doc;\n\tJokerSettings *_settings;\n\tPhSonySlaveController _sonySlave;\n\tSynchronizer _synchronizer;\n\n\tPhFloatingMediaPanel _mediaPanel;\n\tQTimer _mediaPanelTimer;\n\tMediaPanelState _mediaPanelState;\n\tQPropertyAnimation _mediaPanelAnimation;\n\n\tPropertyDialog _propertyDialog;\n\n\tPhLtcReader _ltcReader;\n\tbool _needToSave;\n\tbool _firstDoc;\n\tint _numberOfDraw;\n\n};\n\n#endif // MAINWINDOW_H\n", "name": "app/Joker/JokerWindow.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#include <QApplication>\n#include <QDebug>\n#include <QTranslator>\n\n#include \"PhStrip/PhStripDoc.h\"\n\n#include \"JokerWindow.h\"\n\n/**\n * @brief The application main entry point\n * @param argc Command line argument count\n * @param argv Command line argument list\n * @return 0 if the application works well.\n */\nint main(int argc, char *argv[])\n{\n\tJokerSettings settings;\n\tint logMask = settings.logMask();\n\tPHDEBUG << ORG_NAME << APP_NAME << APP_VERSION;\n\tPhDebug::setLogMask(logMask);\n\tPhDebug::showConsole(true);\n\n\tQApplication a(argc, argv);\n\tQTranslator translator;\n\tif(!settings.language().isEmpty()) {\n\t\ttranslator.load(QCoreApplication::applicationDirPath() + PATH_TO_RESSOURCES + \"/\" + settings.language() + \".qm\");\n\t}\n\telse {\n\t\ttranslator.load(QCoreApplication::applicationDirPath() + PATH_TO_RESSOURCES + \"/\" + QLocale::system().name() + \".qm\");\n\t}\n\ta.installTranslator(&translator);\n\n\n\tJokerWindow w(&settings);\n\n\tw.processArg(argc, argv);\n\tw.show();\n\n\tint result = a.exec();\n\tsettings.setExitedNormaly(result == 0);\n\n\n\treturn result;\n\n}\n", "name": "app/Joker/main.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#include \"PeopleDialog.h\"\n#include \"ui_PeopleDialog.h\"\n#include \"PhTools/PhDebug.h\"\n\nPeopleDialog::PeopleDialog(QWidget *parent, PhStripDoc* doc, JokerSettings *settings) :\n\tQDialog(parent),\n\tui(new Ui::PeopleDialog),\n\t_doc(doc),\n\t_settings(settings)\n{\n\tui->setupUi(this);\n\n\tQStringList peopleList = _settings->selectedPeopleNameList();\n\tforeach(QString name, peopleList) {\n\t\t_oldPeopleNameList.append(name);\n\t}\n\n\tforeach(PhPeople* people, _doc->peoples()) {\n\t\tif(people) {\n\t\t\tQString name = people->name();\n\t\t\tui->peopleList->addItem(name);\n\n\t\t\tif(peopleList.contains(name))\n\t\t\t\tui->peopleList->item(ui->peopleList->count() - 1)->setSelected(true);\n\t\t}\n\t}\n\tif(ui->peopleList->count() == 0) {\n\t\tui->peopleList->addItem(tr(\"The list is empty...\"));\n\t\tui->peopleList->setDisabled(true);\n\t}\n\n#warning /// @todo Check if fixed\n\tui->buttonBox->button(QDialogButtonBox::Ok)->setText(tr(\"Ok\"));\n\tui->buttonBox->button(QDialogButtonBox::Cancel)->setText(tr(\"Cancel\"));\n}\n\nPeopleDialog::~PeopleDialog()\n{\n\tdelete ui;\n}\n\nvoid PeopleDialog::on_peopleList_itemSelectionChanged()\n{\n\tQStringList peopleNameList;\n\n\tforeach(QListWidgetItem* item, ui->peopleList->selectedItems()) {\n\t\tpeopleNameList.append(item->text());\n\t}\n\n\tif(peopleNameList.count() < _doc->peoples().count())\n\t\t_settings->setSelectedPeopleNameList(peopleNameList);\n}\n\nvoid PeopleDialog::on_buttonBox_rejected()\n{\n\tQStringList peopleNameList;\n\tforeach(QString name, _oldPeopleNameList)\n\tpeopleNameList.append(name);\n\n\t_settings->setSelectedPeopleNameList(peopleNameList);\n}\n\nvoid PeopleDialog::on_selectAllButton_clicked()\n{\n\tui->peopleList->selectAll();\n}\n\nvoid PeopleDialog::on_deselectAllButton_clicked()\n{\n\tui->peopleList->clearSelection();\n}\n", "name": "app/Joker/PeopleDialog.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef PEOPLEDIALOG_H\n#define PEOPLEDIALOG_H\n\n#include <QDialog>\n\n#include \"PhStrip/PhStripDoc.h\"\n\n#include \"JokerSettings.h\"\n\nnamespace Ui {\nclass PeopleDialog;\n}\n/**\n * @brief PhPeople selection dialog.\n *\n * This modal dialog allow the final user to select or deselect any PhPeople coming from the PhStripDoc.\n * Selected people will be displayed on the left. Other people will be grayed out on the strip.\n * The next timecode in the upper right part of the application will displayed the next selected people time code.\n */\nclass PeopleDialog : public QDialog\n{\n\tQ_OBJECT\n\npublic:\n\t/**\n\t * @brief The PeopleDialog constructor\n\t *\n\t * By giving the PeopleDialog the application settings, the dialog\n\t * is able to update in real time the PhGraphicStrip display.\n\t *\n\t * @param parent The parent object\n\t * @param doc The current PhStripDoc\n\t * @param settings The application settings\n\t */\n\texplicit PeopleDialog(QWidget *parent, PhStripDoc* doc, JokerSettings *settings);\n\n\t~PeopleDialog();\n\nprivate slots:\n\tvoid on_peopleList_itemSelectionChanged();\n\n\tvoid on_buttonBox_rejected();\n\n\tvoid on_selectAllButton_clicked();\n\n\tvoid on_deselectAllButton_clicked();\n\nprivate:\n\tUi::PeopleDialog *ui;\n\tPhStripDoc* _doc;\n\tJokerSettings *_settings;\n\tQStringList _oldPeopleNameList;\n};\n\n#endif // PEOPLEDIALOG_H\n", "name": "app/Joker/PeopleDialog.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#include <QMessageBox>\n#include <QDir>\n#include <QProcess>\n#include \"ui_PreferencesDialog.h\"\n#include \"PreferencesDialog.h\"\n#include \"PhTools/PhDebug.h\"\n#include \"PhSync/PhLtcReader.h\"\n\nPreferencesDialog::PreferencesDialog(JokerSettings *settings, QWidget *parent) :\n\tQDialog(parent),\n\tui(new Ui::PreferencesDialog),\n\t_settings(settings)\n{\n\t// Load the ui\n\tui->setupUi(this);\n\tthis->setMaximumHeight(this->height());\n\tthis->setMaximumWidth(this->width());\n\tui->tabWidget->setCurrentIndex(0);\n\tthis->setFocus();\n\n\t// Load the old settings\n\t_oldUseQuarterFrame = _settings->useQuarterFrame();\n\t_oldDelay = _settings->screenDelay();\n\t_oldStripHeight = _settings->stripHeight();\n\t_oldHorizontalTimePerPixel = _settings->horizontalTimePerPixel();\n\t_oldBolness = _settings->textBoldness();\n\t_oldFont = _settings->textFontFile();\n\t_oldDisplayTC = _settings->displayTC();\n\t_oldDisplayNextTC = _settings->displayNextTC();\n\t_oldDisplayNextText = _settings->displayNextText();\n\t_oldDisplayTitle = _settings->displayTitle();\n\t_oldDisplayLoop = _settings->displayLoop();\n\t_oldSyncProtocol = _settings->synchroProtocol();\n\t_oldLTCInput = _settings->ltcInputDevice();\n\n\tui->sliderBoldness->setValue(_oldBolness);\n\tui->spinBoxSpeed->setValue(_oldHorizontalTimePerPixel);\n\tif(_oldUseQuarterFrame) {\n\t\tui->radioButtonQF->setChecked(true);\n\t\tui->spinBoxDelay->setValue(_oldDelay / 10);\n\t}\n\telse {\n\t\tui->radioButtonMS->setChecked(true);\n\t\tui->spinBoxDelay->setValue(_oldDelay);\n\t}\n\n\tui->sliderStripHeight->setValue(ui->sliderStripHeight->maximum() * _oldStripHeight);\n\tui->cBoxDisplayTC->setChecked(_oldDisplayTC);\n\tui->cBoxDisplayNextTC->setChecked(_oldDisplayNextTC);\n\tui->cBoxDisplayNextText->setChecked(_oldDisplayNextText);\n\tui->cBoxDisplayTitle->setChecked(_oldDisplayTitle);\n\tui->cBoxDisplayLoop->setChecked(_oldDisplayLoop);\n\n\t//Set the fonts\n\tQStringList userFontList, systemFontList;\n\tQString userDirectory = QDir::homePath();\n\tQDir systemFont(\"/Library/Fonts/\");\n\tQDir userFont(userDirectory + \"/Library/Fonts/\");\n\n\n\tQStringList filters;\n\tfilters.append(\"*.ttf\");\n\tfilters.append(\"*.TTF\");\n\tsystemFont.setNameFilters(filters);\n\tuserFont.setNameFilters(filters);\n\tuserFontList = userFont.entryList();\n\tsystemFontList = systemFont.entryList();\n\n\tforeach(QString fontName, systemFontList)\n\t{\n\t\t_fontList[fontName.split(\".\").first()] = \"/Library/Fonts/\" + fontName;\n\t}\n\tforeach(QString fontName, userFontList)\n\t{\n\t\t_fontList[fontName.split(\".\").first()] = userDirectory + \"/Library/Fonts/\" + fontName;\n\t}\n\tif(!_fontList[\"SWENSON\"].isNull())\n\t\t_fontList[\"SWENSON\"] = QCoreApplication::applicationDirPath() + PATH_TO_RESSOURCES + \"/\" + \"SWENSON.TTF\";\n\n\n\t// _oldFont is : /Path/To/Font.ttf\n\t// So split with \"/\" then take last gives Font.ttf\n\t// Split with \".\" then take first, gives the name of the font\n\tQString oldFontName = _oldFont.split(\"/\").last().split(\".\").first();\n\tforeach(QString fontName, _fontList.keys())\n\t{\n\t\tui->listWidgetFont->addItem(fontName);\n\t\tif(fontName == oldFontName) {\n\t\t\tui->listWidgetFont->item(ui->listWidgetFont->count() - 1)->setSelected(true);\n\t\t\tui->listWidgetFont->setCurrentRow(ui->listWidgetFont->count() - 1);\n\t\t}\n\t}\n\n\tui->listWidgetSync->addItem(\"LTC\");\n\n\tui->listWidgetSync->setCurrentRow(_oldSyncProtocol);\n\n\tif(_oldSyncProtocol == Synchronizer::Sony)\n\t\tshowParamSony(true);\n\telse if(_oldSyncProtocol == Synchronizer::LTC)\n\t\tshowParamLTC(true);\n\telse {\n\t\tshowParamLTC(false);\n\t\tshowParamSony(false);\n\t}\n\n//\tui->buttonBox->button(QDialogButtonBox::Ok)->setText(tr(\"Ok\"));\n//\tui->buttonBox->button(QDialogButtonBox::Cancel)->setText(tr(\"Cancel\"));\n\n\t//Set the language\n\tQDir appDirectory(QCoreApplication::applicationDirPath() + PATH_TO_RESSOURCES + \"/\");\n\n\n\n\tQStringList filtersLang;\n\tfiltersLang.append(\"*.qm\");\n\tappDirectory.setNameFilters(filtersLang);\n\tQStringList languageFileList = appDirectory.entryList();\n\n\n\t_langNameMap[\"\"] = tr(\"<System default>\");\n\tui->cboBoxLang->addItem(_langNameMap[\"\"], \"\");\n\n\tforeach(QString tradFile, languageFileList)\n\t{\n\t\tQFileInfo info(tradFile);\n\t\tQString lang = info.baseName();\n\t\tif (lang == \"en_US\")\n\t\t\t_langNameMap[lang] = tr(\"English\");\n\t\telse if(lang == \"fr_FR\")\n\t\t\t_langNameMap[lang] = tr(\"French\");\n\t\telse\n\t\t\t_langNameMap[lang] = lang;\n\t\tui->cboBoxLang->addItem(_langNameMap[lang], lang);\n\t}\n\n\tui->cboBoxLang->setCurrentText(_langNameMap[_settings->language()]);\n}\n\nPreferencesDialog::~PreferencesDialog()\n{\n\tdelete ui;\n}\n\nvoid PreferencesDialog::on_buttonBox_accepted()\n{\n\tif(ui->cboBoxLang->currentData() != _settings->language()) {\n\t\tQMessageBox::warning(this, tr(\"Information\"),\n\t\t                     tr(\"You change the language to \\\"%1\\\".\\n\"\n\t\t                        \"You need to restart %2 to apply you changes.\").arg(ui->cboBoxLang->currentText(), APP_NAME),\n\t\t                     QMessageBox::Ok,\n\t\t                     QMessageBox::Ok);\n\t\t_settings->setLanguage(ui->cboBoxLang->currentData().toString());\n\t}\n\tclose();\n}\n\nvoid PreferencesDialog::on_buttonBox_rejected()\n{\n\t_settings->setUseQuarterFrame(_oldUseQuarterFrame);\n\t_settings->setScreenDelay(_oldDelay);\n\t_settings->setStripHeight(_oldStripHeight);\n\t_settings->setHorizontalTimePerPixel(_oldHorizontalTimePerPixel);\n\t_settings->setTextBoldness(_oldBolness);\n\t_settings->setTextFontFile(_oldFont);\n\t_settings->setDisplayTC(_oldDisplayTC);\n\t_settings->setDisplayNextTC(_oldDisplayNextTC);\n\t_settings->setDisplayNextText(_oldDisplayNextText);\n\t_settings->setDisplayTitle(_oldDisplayTitle);\n\t_settings->setDisplayLoop(_oldDisplayLoop);\n\t_settings->setLTCInputDevice(_oldLTCInput);\n\n\tclose();\n}\n\nvoid PreferencesDialog::on_spinBoxDelay_valueChanged(int delay)\n{\n\tif(_settings->useQuarterFrame())\n\t\t_settings->setScreenDelay(delay * 10);\n\telse\n\t\t_settings->setScreenDelay(delay);\n}\n\nvoid PreferencesDialog::on_spinBoxSpeed_valueChanged(int speed)\n{\n\t_settings->setHorizontalTimePerPixel(speed);\n}\n\nvoid PreferencesDialog::on_radioButtonQF_toggled(bool checked)\n{\n\t_settings->setUseQuarterFrame(checked);\n\tif(checked)\n\t\tui->spinBoxDelay->setValue(_settings->screenDelay() / 10);\n\telse\n\t\tui->spinBoxDelay->setValue(_settings->screenDelay());\n\tui->spinBoxDelay->selectAll();\n}\n\nvoid PreferencesDialog::on_sliderStripHeight_valueChanged(int position)\n{\n\t_settings->setStripHeight(((float)position / ui->sliderStripHeight->maximum()));\n}\n\nvoid PreferencesDialog::on_sliderBoldness_valueChanged(int value)\n{\n\t_settings->setTextBoldness(value);\n}\n\nvoid PreferencesDialog::on_lineEditFilter_textEdited(const QString &arg1)\n{\n\tui->listWidgetFont->clear();\n\tforeach(QString fontName, _fontList.keys())\n\t{\n\t\tif(fontName.contains(&arg1, Qt::CaseInsensitive))\n\t\t\tui->listWidgetFont->addItem(fontName);\n\t}\n}\n\nvoid PreferencesDialog::on_listWidgetFont_currentItemChanged(QListWidgetItem *current, QListWidgetItem *previous)\n{\n\tQ_UNUSED(previous);\n\tif(current)\n\t\t_settings->setTextFontFile(_fontList[current->text()]);\n}\n\nvoid PreferencesDialog::on_cBoxDisplayTC_clicked()\n{\n\t_settings->setDisplayTC(ui->cBoxDisplayTC->isChecked());\n}\n\nvoid PreferencesDialog::on_cBoxDisplayNextTC_clicked()\n{\n\t_settings->setDisplayNextTC(ui->cBoxDisplayNextTC->isChecked());\n}\n\nvoid PreferencesDialog::on_cBoxDisplayNextText_clicked()\n{\n\t_settings->setDisplayNextText(ui->cBoxDisplayNextText->isChecked());\n}\n\nvoid PreferencesDialog::on_cBoxDisplayTitle_clicked()\n{\n\t_settings->setDisplayTitle(ui->cBoxDisplayTitle->isChecked());\n}\n\nvoid PreferencesDialog::on_cBoxDisplayLoop_clicked()\n{\n\t_settings->setDisplayLoop(ui->cBoxDisplayLoop->isChecked());\n}\n\nvoid PreferencesDialog::on_listWidgetSync_currentItemChanged(QListWidgetItem *current, QListWidgetItem *previous)\n{\n\tQ_UNUSED(current);\n\tQ_UNUSED(previous);\n\tint protocol = ui->listWidgetSync->currentRow();\n\tswitch(protocol) {\n\tcase Synchronizer::Sony:\n\t\tshowParamSony(true);\n\t\tbreak;\n\tcase Synchronizer::LTC:\n\t\tshowParamLTC(true);\n\t\tbreak;\n\tdefault:\n\t\tshowParamLTC(false);\n\t\tshowParamSony(false);\n\t\tbreak;\n\t}\n\t_settings->setSynchroProtocol(protocol);\n}\n\nvoid PreferencesDialog::showParamLTC(bool show)\n{\n\tif(show) {\n\t\tui->listWidgetInputs->clear();\n\t\tui->listWidgetInputs->setVisible(1);\n\t\tui->lblInputs->setVisible(1);\n\t\tshowParamSony(false);\n\t\tui->listWidgetInputs->addItems(PhLtcReader::inputList());\n\t\tforeach(QString inputName, PhLtcReader::inputList()) {\n\t\t\tPHDEBUG << inputName;\n\t\t}\n\n\t\tif(ui->listWidgetInputs->findItems(_settings->ltcInputDevice(), Qt::MatchExactly).count() > 0)\n\t\t\tui->listWidgetInputs->findItems(_settings->ltcInputDevice(), Qt::MatchExactly).first()->setSelected(1);\n\t}\n\telse {\n\t\tui->lblInputs->setVisible(0);\n\t\tui->listWidgetInputs->setVisible(0);\n\t}\n}\n\nvoid PreferencesDialog::showParamSony(bool show)\n{\n\tif(show) {\n\t\tui->spinBoxSonyHighSpeed->setVisible(1);\n\t\tui->lineEditSonyID->setVisible(1);\n\t\tui->lblSonyHighSpeed->setVisible(1);\n\t\tui->lblSonyID->setVisible(1);\n\t\tshowParamLTC(false);\n\t}\n\telse {\n\t\tui->spinBoxSonyHighSpeed->setVisible(0);\n\t\tui->lineEditSonyID->setVisible(0);\n\t\tui->lblSonyHighSpeed->setVisible(0);\n\t\tui->lblSonyID->setVisible(0);\n\t}\n}\n\n\nvoid PreferencesDialog::on_listWidgetInputs_currentItemChanged(QListWidgetItem *current, QListWidgetItem *previous)\n{\n\tQ_UNUSED(previous);\n\t_settings->setLTCInputDevice(current->text());\n}\n\n", "name": "app/Joker/PreferencesDialog.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef PREFERENCESDIALOG_H\n#define PREFERENCESDIALOG_H\n\n#include <QDialog>\n#include <QListWidgetItem>\n\n#include \"Synchronizer.h\"\n#include \"JokerSettings.h\"\n\nnamespace Ui {\nclass PreferencesDialog;\n}\n/**\n * @brief Joker preferences dialog\n *\n * The dialog contains the following user settings:\n * - General HUD: enable/disable element like current timecode\n * - Synchronization: delay, sync mode, sync mode configuration\n * - PhGraphicStrip setting: boldness, speed, font, height\n * - Log\n */\nclass PreferencesDialog : public QDialog\n{\n\tQ_OBJECT\n\npublic:\n\t/**\n\t * @brief The PreferencesDialog constructor\n\t *\n\t * @param settings The application settings\n\t * @param parent The parent object\n\t */\n\texplicit PreferencesDialog(JokerSettings *settings, QWidget *parent = 0);\n\t~PreferencesDialog();\n\nprivate slots:\n\n\tvoid on_spinBoxDelay_valueChanged(int delay);\n\tvoid on_radioButtonQF_toggled(bool checked);\n\tvoid on_sliderStripHeight_valueChanged(int position);\n\tvoid on_spinBoxSpeed_valueChanged(int speed);\n\tvoid on_listWidgetFont_currentItemChanged(QListWidgetItem *current, QListWidgetItem *previous);\n\n\tvoid on_buttonBox_accepted();\n\n\tvoid on_buttonBox_rejected();\n\n\tvoid on_sliderBoldness_valueChanged(int value);\n\n\tvoid on_lineEditFilter_textEdited(const QString &arg1);\n\n\tvoid on_cBoxDisplayTC_clicked();\n\n\tvoid on_cBoxDisplayNextTC_clicked();\n\n\tvoid on_cBoxDisplayNextText_clicked();\n\n\tvoid on_cBoxDisplayTitle_clicked();\n\n\tvoid on_cBoxDisplayLoop_clicked();\n\n\tvoid on_listWidgetSync_currentItemChanged(QListWidgetItem *current, QListWidgetItem *previous);\n\n\tvoid on_listWidgetInputs_currentItemChanged(QListWidgetItem *current, QListWidgetItem *previous);\n\nprivate:\n\tUi::PreferencesDialog *ui;\n\tJokerSettings *_settings;\n\tQString _oldFont;\n\tbool _oldUseQuarterFrame;\n\tint _oldDelay;\n\tint _oldHorizontalTimePerPixel;\n\tint _oldBolness;\n\tfloat _oldStripHeight;\n\tbool _oldDisplayTC;\n\tbool _oldDisplayNextTC;\n\tbool _oldDisplayNextText;\n\tbool _oldDisplayTitle;\n\tbool _oldDisplayLoop;\n\tint _oldSyncProtocol;\n\tQString _oldLTCInput;\n\n\tQMap<QString, QString> _fontList;\n\tQMap<QString, QString> _langNameMap;\n\n\n\tvoid showParamLTC(bool show);\n\tvoid showParamSony(bool show);\n};\n\n#endif // PREFERENCESDIALOG_H\n", "name": "app/Joker/PreferencesDialog.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#include \"PropertyDialog.h\"\n#include \"ui_PropertyDialog.h\"\n\nPropertyDialog::PropertyDialog(QWidget *parent) :\n\tQDialog(parent),\n\tui(new Ui::PropertyDialog),\n\t_doc(NULL)\n{\n\tui->setupUi(this);\n}\n\nPropertyDialog::~PropertyDialog()\n{\n\tdelete ui;\n}\n\nvoid PropertyDialog::setDoc(PhStripDoc *doc)\n{\n\t_doc = doc;\n}\n\nvoid PropertyDialog::setVideoEngine(PhVideoEngine *videoEngine)\n{\n\t_videoEngine = videoEngine;\n}\n\nvoid PropertyDialog::showEvent(QShowEvent *)\n{\n\tui->titleLabel->setText(\"-\");\n\tui->tcInLabel->setText(\"-\");\n\tui->tcOutLabel->setText(\"-\");\n\tui->authorLabel->setText(\"-\");\n\tui->peopleNumberLabel->setText(\"-\");\n\tui->charNumberLabel->setText(\"-\");\n\n\tui->videoFileLabel->setText(\"-\");\n\tui->videoTCInLabel->setText(\"-\");\n\tui->videoTCOutLabel->setText(\"-\");\n\tui->resolutionLabel->setText(\"-\");\n\tui->fpsLabel->setText(\"-\");\n\tui->codecNameLabel->setText(\"-\");\n\n\tif(_doc) {\n\t\tui->titleLabel->setText(_doc->title());\n\n\t\tif(_doc->authorName().length())\n\t\t\tui->authorLabel->setText(_doc->authorName());\n\n\t\tPhTime timeIn = _doc->timeIn();\n\t\tif(timeIn > 0)\n\t\t\tui->tcInLabel->setText(PhTimeCode::stringFromTime(timeIn, _doc->timeCodeType()));\n\n\t\tPhTime timeOut = _doc->timeOut();\n\t\tif(timeOut > 0)\n\t\t\tui->tcOutLabel->setText(PhTimeCode::stringFromTime(timeOut, _doc->timeCodeType()));\n\n\t\tint peopleNumber = _doc->peoples().count();\n\t\tui->peopleNumberLabel->setText(QString::number(peopleNumber));\n\n\t\tint charNumber = 0;\n\t\tforeach(PhStripText * text, _doc->texts())\n\t\tcharNumber += text->content().length();\n\t\tui->charNumberLabel->setText(QString::number(charNumber));\n\t}\n\n\tif(_videoEngine) {\n\t\tif(_videoEngine->fileName().length())\n\t\t\tui->videoFileLabel->setText(_videoEngine->fileName());\n\n\t\tif(_videoEngine->firstFrame())\n\t\t\tui->videoTCInLabel->setText(PhTimeCode::stringFromFrame(_videoEngine->firstFrame(), _videoEngine->clock()->timeCodeType()));\n\n\t\tif(_videoEngine->length())\n\t\t\tui->videoTCOutLabel->setText(PhTimeCode::stringFromFrame(_videoEngine->firstFrame() + _videoEngine->length(), _videoEngine->clock()->timeCodeType()));\n\n\t\tui->resolutionLabel->setText(QString::number(_videoEngine->width()) + \"x\" + QString::number(_videoEngine->height()));\n\n\t\tui->fpsLabel->setText(QString::number(_videoEngine->framePerSecond()));\n\n\t\tif(_videoEngine->codecName().length())\n\t\t\tui->codecNameLabel->setText(_videoEngine->codecName());\n\t}\n}\n", "name": "app/Joker/PropertyDialog.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef PROPERTYDIALOG_H\n#define PROPERTYDIALOG_H\n\n#include <QDialog>\n#include \"PhStrip/PhStripDoc.h\"\n#include \"PhVideo/PhVideoEngine.h\"\n\nnamespace Ui {\nclass PropertyDialog;\n}\n\n/**\n * @brief Show some properties of the strip file and the matching video.\n */\nclass PropertyDialog : public QDialog\n{\n\tQ_OBJECT\n\npublic:\n\t/**\n\t * @brief The PropertyDialog constructor\n\t * @param parent The parent object\n\t */\n\texplicit PropertyDialog(QWidget *parent = 0);\n\t~PropertyDialog();\n\n\t/**\n\t * @brief Set the document\n\t *\n\t * Attach the given doc to the window in order to access informations.\n\t *\n\t * @param doc The application document\n\t */\n\tvoid setDoc(PhStripDoc * doc);\n\t/**\n\t * @brief Set the video engine\n\t *\n\t * Attach the given video engine to the window in order to access informations.\n\t *\n\t * @param videoEngine The application video engine\n\t */\n\tvoid setVideoEngine(PhVideoEngine *videoEngine);\n\nprotected:\n\t/**\n\t * @brief Called when the dialog is shown\n\t *\n\t * Set up the dialog with the revelent informations.\n\t */\n\tvoid showEvent(QShowEvent *);\n\nprivate:\n\tUi::PropertyDialog *ui;\n\tPhStripDoc *_doc;\n\tPhVideoEngine *_videoEngine;\n};\n\n#endif // PROPERTYDIALOG_H\n", "name": "app/Joker/PropertyDialog.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#include \"PhTools/PhDebug.h\"\n#include \"Synchronizer.h\"\n\nSynchronizer::Synchronizer()\n\t: _syncType(NoSync),\n\t_stripClock(NULL),\n\t_videoClock(NULL),\n\t_syncClock(NULL),\n\t_settingStripFrame(false),\n\t_settingVideoFrame(false),\n\t_settingSonyFrame(false),\n\t_settingStripRate(false),\n\t_settingVideoRate(false),\n\t_settingSonyRate(false)\n{\n}\n\nvoid Synchronizer::setStripClock(PhClock *clock)\n{\n\t_stripClock = clock;\n\tconnect(_stripClock, SIGNAL(frameChanged(PhFrame, PhTimeCodeType)), this, SLOT(onStripFrameChanged(PhFrame, PhTimeCodeType)));\n\tconnect(_stripClock, SIGNAL(rateChanged(PhRate)), this, SLOT(onStripRateChanged(PhRate)));\n}\n\nvoid Synchronizer::setVideoClock(PhClock *clock)\n{\n\t_videoClock = clock;\n\tconnect(_videoClock, SIGNAL(frameChanged(PhFrame, PhTimeCodeType)), this, SLOT(onVideoFrameChanged(PhFrame, PhTimeCodeType)));\n\tconnect(_videoClock, SIGNAL(rateChanged(PhRate)), this, SLOT(onVideoRateChanged(PhRate)));\n\tconnect(_videoClock, SIGNAL(tcTypeChanged(PhTimeCodeType)), this, SLOT(onVideoTCTypeChanged(PhTimeCodeType)));\n}\n\nvoid Synchronizer::setSyncClock(PhClock *clock, SyncType type)\n{\n\t_syncClock = clock;\n\t_syncType = type;\n\tif(_syncClock) {\n\t\tconnect(_syncClock, SIGNAL(frameChanged(PhFrame, PhTimeCodeType)), this, SLOT(onSyncFrameChanged(PhFrame, PhTimeCodeType)));\n\t\tconnect(_syncClock, SIGNAL(rateChanged(PhRate)), this, SLOT(onSyncRateChanged(PhRate)));\n\t}\n}\n\nvoid Synchronizer::onStripFrameChanged(PhFrame frame, PhTimeCodeType)\n{\n\tif(!_settingStripFrame) {\n\t\tPHDBG(2) << frame;\n\t\tif(_syncClock) {\n\t\t\t// Apply precise correction.\n\t\t\t// We don't change sony clock because this would desynchronize the sony master.\n\t\t\tif(qAbs(frame - _syncClock->frame()) > 1) {\n\t\t\t\tPHDEBUG << \"correct :\" << _stripClock->frame() << _syncClock->frame();\n\t\t\t\t_settingStripFrame = true;\n\t\t\t\t_stripClock->setFrame(_syncClock->frame());\n\t\t\t\t_settingStripFrame = false;\n\t\t\t}\n\t\t}\n\n\t\tif(_syncType != Sony) {\n\t\t\t_settingVideoFrame = true;\n\t\t\t_videoClock->setFrame(frame);\n\t\t\t_settingVideoFrame = false;\n\t\t}\n\t}\n}\n\nvoid Synchronizer::onStripRateChanged(PhRate rate)\n{\n\tif(!_settingStripRate) {\n\t\tPHDEBUG << rate;\n\t\tif(_syncClock) {\n\t\t\t_settingSonyRate = true;\n\t\t\t_syncClock->setRate(rate);\n\t\t\t_settingSonyRate = false;\n\t\t}\n\t\t_settingVideoRate = true;\n\t\t_videoClock->setRate(rate);\n\t\t_settingVideoRate = false;\n\t}\n}\n\nvoid Synchronizer::onVideoFrameChanged(PhFrame, PhTimeCodeType)\n{\n//\tif(!_settingVideoFrame)\n//\t\tPHDEBUG << frame;\n}\n\nvoid Synchronizer::onVideoRateChanged(PhRate)\n{\n}\n\nvoid Synchronizer::onVideoTCTypeChanged(PhTimeCodeType tcType)\n{\n\tPHDEBUG << tcType;\n\t_stripClock->setTimeCodeType(tcType);\n\tif(_syncClock)\n\t\t_syncClock->setTimeCodeType(tcType);\n}\n\nvoid Synchronizer::onSyncFrameChanged(PhFrame frame, PhTimeCodeType)\n{\n\tif(!_settingSonyFrame) {\n\t\tPHDBG(3) << frame;\n\t\tif(_syncType == Sony) {\n\t\t\t_settingVideoFrame = true;\n\t\t\t_videoClock->setFrame(frame);\n\t\t\t_settingVideoFrame = false;\n\t\t}\n\t\t// We apply correction here only when there is a significant change of sony frame.\n\t\t// Precise correction occurs in onStripFrameChanged() that is called after\n\t\t// on SonyFrameChanged (see VideoStripView::paint()).\n\t\tPhFrame error = qAbs(frame - _stripClock->frame());\n\t\tif((error > 10) || ((_stripClock->rate() == 0) && (error > 0))) {\n\t\t\tPHDEBUG << \"correct error:\" << frame << _stripClock->frame();\n\t\t\t_settingStripFrame = true;\n\t\t\t_stripClock->setFrame(frame);\n\t\t\t_settingStripFrame = false;\n\t\t}\n\t}\n}\n\nvoid Synchronizer::onSyncRateChanged(PhRate rate)\n{\n\tif(!_settingSonyRate) {\n\t\tPHDEBUG << rate;\n\t\t_settingStripRate = true;\n\t\t_stripClock->setRate(rate);\n\t\t_settingStripRate = false;\n\t\t_settingVideoRate = true;\n\t\t_videoClock->setRate(rate);\n\t\t_settingVideoFrame = false;\n\t}\n}\n", "name": "app/Joker/Synchronizer.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef SYNCHRONIZER_H\n#define SYNCHRONIZER_H\n\n#include <QObject>\n\n#include \"PhTools/PhClock.h\"\n\n/**\n * @brief Provide a synchronisation system between the strip, the video and the external sync signal\n */\nclass Synchronizer : public QObject\n{\n\tQ_OBJECT\npublic:\n\t/**\n\t * @brief The different kind of synchronization enumeration used by Joker\n\t */\n\tenum SyncType {\n\t\tNoSync = 0,\n\t\tSony = 1,\n\t\tLTC = 2,\n\t};\n\n\tSynchronizer();\n\n\t/**\n\t * @brief Set the strip clock\n\t * @param clock The strip clock\n\t */\n\tvoid setStripClock(PhClock *clock);\n\n\t/**\n\t * @brief Get the strip clock\n\t * @return The strip clock\n\t */\n\tPhClock * stripClock() {\n\t\treturn _stripClock;\n\t}\n\n\t/**\n\t * @brief Set the videoClock\n\t * @param clock The video clock\n\t */\n\tvoid setVideoClock(PhClock *clock);\n\n\t/**\n\t * @brief Get the video clock\n\t * @return The video clock\n\t */\n\tPhClock * videoClock() {\n\t\treturn _videoClock;\n\t}\n\n\t/**\n\t * @brief Set the synchronization clock\n\t * @param clock The synchronization clock\n\t * @param type The desired PhTimeCodeType\n\t */\n\tvoid setSyncClock(PhClock *clock, SyncType type);\n\n\t/**\n\t * @brief Get the Synchronization clock\n\t * @return The Synchronization clock.\n\t */\n\tPhClock * syncClock() {\n\t\treturn _syncClock;\n\t}\n\nprivate slots:\n\tvoid onStripFrameChanged(PhFrame frame, PhTimeCodeType tcType);\n\tvoid onStripRateChanged(PhRate rate);\n\tvoid onVideoFrameChanged(PhFrame frame, PhTimeCodeType tcType);\n\tvoid onVideoRateChanged(PhRate rate);\n\tvoid onVideoTCTypeChanged(PhTimeCodeType tcType);\n\tvoid onSyncFrameChanged(PhFrame frame, PhTimeCodeType tcType);\n\tvoid onSyncRateChanged(PhRate rate);\nprivate:\n\tint _syncType;\n\tPhClock * _stripClock;\n\tPhClock * _videoClock;\n\tPhClock * _syncClock;\n\tbool _settingStripFrame;\n\tbool _settingVideoFrame;\n\tbool _settingSonyFrame;\n\tbool _settingStripRate;\n\tbool _settingVideoRate;\n\tbool _settingSonyRate;\n};\n\n#endif // SYNCHRONIZER_H\n", "name": "app/Joker/Synchronizer.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#include <QtGlobal>\n#include <QApplication>\n#include <QMouseEvent>\n\n#include \"VideoStripView.h\"\n\nVideoStripView::VideoStripView(QWidget *parent) :\n\tPhGraphicView(parent),\n\t_settings(NULL),\n\t_videoEngine(false),\n\t_sony(NULL),\n\t_titleText(_strip.getHUDFont(), \"\"),\n\t_tcText(_strip.getHUDFont(), \"00:00:00:00\"),\n\t_nextTCText(_strip.getHUDFont(), \"00:00:00:00\"),\n\t_noVideoSyncError(_strip.getHUDFont(), \"No video sync\"),\n\t_currentPeopleName(_strip.getHUDFont(), \"\")\n{\n\tqApp->installEventFilter(this);\n}\n\nvoid VideoStripView::setSettings(JokerSettings *settings)\n{\n\t_settings = settings;\n\t_strip.setSettings(settings);\n\tthis->setGraphicSettings(settings);\n}\n\nvoid VideoStripView::setSony(PhSonyController *sony)\n{\n\t_sony = sony;\n\tif(_sony) {\n\t\tconnect(_sony, SIGNAL(videoSync()), this, SLOT(onVideoSync()));\n\t\t_lastVideoSyncElapsed.start();\n\t}\n}\n\nbool VideoStripView::init()\n{\n\t_titleBackgroundRect.setColor(QColor(0, 0, 128));\n\t_titleText.setColor(QColor(255, 255, 255));\n\t_tcText.setColor(Qt::green);\n\t_nextTCText.setColor(Qt::red);\n\t_noVideoSyncError.setColor(QColor(0, 0, 0));\n\t_currentPeopleName.setColor(QColor(128, 128, 128));\n\n\tconnect(this, SIGNAL(beforePaint(PhTimeScale)), _strip.clock(), SLOT(tick(PhTimeScale)));\n\t_logo.setFilename(QCoreApplication::applicationDirPath() + PATH_TO_RESSOURCES + \"/phonations.png\");\n\t_logo.init();\n\n\treturn _strip.init();\n}\n\nvoid VideoStripView::paint()\n{\n\tPHDBG(1) << _strip.clock()->time() - (_sony ? _sony->clock()->time() : 0);\n\n\tQList<PhPeople*> selectedPeoples;\n\tforeach(QString name, _settings->selectedPeopleNameList()) {\n\t\tPhPeople *people = _strip.doc()->peopleByName(name);\n\t\tif(people)\n\t\t\tselectedPeoples.append(people);\n\t}\n\n\tint y = 0;\n\tQString title = _strip.doc()->title();\n\tif(_strip.doc()->episode().length() > 0)\n\t\ttitle += \" #\" + _strip.doc()->episode();\n\n\tif(_settings->displayTitle() && (title.length() > 0)) {\n\t\tint titleHeight = this->height() / 40;\n\t\t_titleBackgroundRect.setRect(0, y, this->width(), titleHeight);\n\t\tint titleWidth = title.length() * titleHeight / 2;\n\t\tint titleX = (this->width() - titleWidth) / 2;\n\t\t_titleText.setRect(titleX, y, titleWidth, titleHeight);\n\t\ty += titleHeight;\n\t\t_titleText.setContent(title);\n\t\t_titleText.setZ(5);\n\t\t_titleBackgroundRect.setZ(5);\n\t}\n\n\tfloat stripHeightRatio = 0.25f;\n\tif(_settings) {\n\t\tif(_settings->hideStrip())\n\t\t\tstripHeightRatio = 0;\n\t\telse\n\t\t\tstripHeightRatio = _settings->stripHeight();\n\t}\n\n\tint stripHeight = (this->height() - y) * stripHeightRatio;\n\tint videoHeight = this->height() - y - stripHeight;\n\n\tint tcOffset = 0;\n\tif(_settings->displayNextTC())\n\t\ttcOffset = _nextTCText.getHeight();\n\tif(_settings->displayTitle())\n\t\ttcOffset += _titleText.getHeight();\n\n\t_strip.draw(0, y + videoHeight, this->width(), stripHeight, tcOffset, selectedPeoples);\n\tforeach(QString info, _strip.infos()) {\n\t\tthis->addInfo(info);\n\t}\n\n\t// The strip must be the first drawn object, otherwise it masks previous drawings.\n\tif(_settings->displayTitle() && (title.length() > 0)) {\n\t\t_titleBackgroundRect.draw();\n\t\t_titleText.draw();\n\t}\n\n\tint tcWidth = 200;\n\n\tif((videoHeight > 0)) {\n\t\tif(_videoEngine.height() > 0) {\n\t\t\tint videoWidth;\n\t\t\tif(_forceRatio169)\n\t\t\t\tvideoWidth = videoHeight * 16 / 9;\n\t\t\telse\n\t\t\t\tvideoWidth = videoHeight * _videoEngine.width() / _videoEngine.height();\n\n\t\t\tint blackStripHeight = 0; // Height of the upper black strip when video is too large\n\t\t\tint realVideoHeight = videoHeight;\n\t\t\tif(videoWidth > this->width()) {\n\t\t\t\tvideoWidth = this->width();\n\t\t\t\tif(_forceRatio169)\n\t\t\t\t\trealVideoHeight = videoWidth  * 9 / 16;\n\t\t\t\telse\n\t\t\t\t\trealVideoHeight = videoWidth  * _videoEngine.height() / _videoEngine.width();\n\t\t\t}\n\t\t\tblackStripHeight = (this->height() - stripHeight - realVideoHeight) / 2;\n\n\t\t\tint videoX = (this->width() - videoWidth) / 2;\n\t\t\t_videoEngine.drawVideo(videoX, y + blackStripHeight, videoWidth, realVideoHeight);\n\n\t\t\t// adjust tc size\n\t\t\tif(videoX > tcWidth)\n\t\t\t\ttcWidth = videoX;\n\t\t\telse if( this->width() < 2 * tcWidth)\n\t\t\t\ttcWidth = this->width() / 2;\n\t\t}\n\t\telse if(_settings->displayLogo()) {\n\t\t\t// The logo file is 500px in native format\n\t\t\tint logoHeight = _logo.originalSize().height();\n\t\t\tint logoWidth = _logo.originalSize().width();\n\t\t\tif(videoHeight < logoHeight) {\n\t\t\t\tlogoHeight = videoHeight;\n\t\t\t\tlogoWidth = _logo.originalSize().width() * logoHeight / _logo.originalSize().height();\n\t\t\t}\n\t\t\tif(this->width() < logoWidth) {\n\t\t\t\tlogoWidth = this->width();\n\t\t\t\tlogoHeight = _logo.originalSize().height() * logoWidth / _logo.originalSize().width();\n\t\t\t}\n\t\t\t_logo.setRect((this->width() - logoHeight) / 2, (videoHeight - logoHeight) / 2, logoHeight, logoHeight);\n\t\t\t_logo.draw();\n\n\t\t}\n\t}\n\n\tPhClock *clock = _videoEngine.clock();\n\tlong delay = (int)(24 * _settings->screenDelay() * clock->rate());\n\tPhTime clockTime = clock->time() + delay;\n\tint tcHeight = tcWidth / 5;\n\n\tif(_settings->displayTC()) {\n\t\t_tcText.setRect(0, y, tcWidth, tcHeight);\n\t\t_tcText.setContent(PhTimeCode::stringFromTime(clockTime, clock->timeCodeType()));\n\t\t_tcText.draw();\n\t}\n\n\tif(_settings->displayNextTC()) {\n\t\tPhStripText *nextText = NULL;\n\n\t\t_nextTCText.setRect(this->width() - tcWidth, y, tcWidth, tcHeight);\n\t\ty += tcHeight;\n\n\t\t/// The next time code will be the next element of the people from the list.\n\t\tif(selectedPeoples.count()) {\n\t\t\tnextText = _strip.doc()->nextText(selectedPeoples, clockTime);\n\t\t\tif(nextText == NULL)\n\t\t\t\tnextText = _strip.doc()->nextText(selectedPeoples, 0);\n\n\t\t\tint peopleHeight = this->height() / 30;\n\t\t\tforeach(PhPeople* people, selectedPeoples) {\n\t\t\t\tint peopleNameWidth = people->name().length() * peopleHeight / 2;\n\t\t\t\t_currentPeopleName.setRect(10, y, peopleNameWidth, peopleHeight);\n\t\t\t\t_currentPeopleName.setContent(people->name());\n\t\t\t\t_currentPeopleName.draw();\n\t\t\t\ty += peopleHeight;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tnextText = _strip.doc()->nextText(clockTime);\n\t\t\tif(nextText == NULL)\n\t\t\t\tnextText = _strip.doc()->nextText(0);\n\t\t}\n\n\t\tif(nextText != NULL) {\n\t\t\t_nextTCText.setContent(PhTimeCode::stringFromTime(nextText->timeIn(), clock->timeCodeType()));\n\t\t\t_nextTCText.draw();\n\t\t}\n\t}\n\n\tPhStripLoop * currentLoop = _strip.doc()->previousLoop(clockTime);\n\tif(currentLoop) {\n\t\tint loopNumber = currentLoop->number();\n\t\tPhGraphicText gCurrentLoop(_strip.getHUDFont(), QString::number(loopNumber));\n\t\tint loopHeight = 60;\n\t\tint loopWidth = _strip.getHUDFont()->getNominalWidth(QString::number(loopNumber)) * ((float) loopHeight / _strip.getHUDFont()->getHeight());\n\t\tgCurrentLoop.setRect(10, this->height() - stripHeight - loopHeight, loopWidth, loopHeight);\n\t\tgCurrentLoop.setColor(Qt::blue);\n\t\tgCurrentLoop.draw();\n\t}\n\n\t_noVideoSyncError.setRect(this->width() / 2 - 100, this->height() / 2 - 25, 200, 50);\n\tif(_lastVideoSyncElapsed.elapsed() > 1000) {\n\t\tint red = (_lastVideoSyncElapsed.elapsed() - 1000) / 4;\n\t\tif (red > 255)\n\t\t\tred = 255;\n\t\t_noVideoSyncError.setColor(QColor(red, 0, 0));\n\t\t_noVideoSyncError.draw();\n\t}\n\telse\n\t\t_noVideoSyncError.setColor(QColor(0, 0, 0));\n}\n\nbool VideoStripView::eventFilter(QObject *, QEvent *event)\n{\n\tswitch(event->type()) {\n\tcase QEvent::MouseMove:\n\t\t{\n\t\t\tQMouseEvent * mouseEvent = (QMouseEvent*)event;\n\t\t\tfloat stripHeight = this->height() * _settings->stripHeight();\n\t\t\tif((mouseEvent->pos().y() > (this->height() - stripHeight) * 0.95)\n\t\t\t   && (mouseEvent->pos().y() < (this->height() - stripHeight) * 1.05)) {\n\t\t\t\tQApplication::setOverrideCursor(Qt::SizeVerCursor);\n\t\t\t\tif(mouseEvent->buttons() & Qt::LeftButton)\n\t\t\t\t\t_settings->setStripHeight(1.0 - ((float) mouseEvent->pos().y() /(float) this->height()));\n\t\t\t}\n\t\t\telse\n\t\t\t\tQApplication::setOverrideCursor(Qt::ArrowCursor);\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n\treturn false;\n}\n\nvoid VideoStripView::onVideoSync()\n{\n\t_lastVideoSyncElapsed.restart();\n}\n", "name": "app/Joker/VideoStripView.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef VIDEOSTRIPVIEW_H\n#define VIDEOSTRIPVIEW_H\n\n#include <QTime>\n\n#include \"PhGraphic/PhGraphicView.h\"\n#include \"PhVideo/PhVideoEngine.h\"\n#include \"PhGraphicStrip/PhGraphicStrip.h\"\n#include \"PhSync/PhSonyController.h\"\n\n#include \"JokerSettings.h\"\n\n/**\n * @brief The Joker main view\n *\n * This PhGraphicView display the following graphic elements:\n * - the PhVideoEngine\n * - the PhGraphicStrip\n * - the current timecode\n * - the next text timecode (if a people list is currently selected, the\n * next text timecode display the one from the list)\n * - An error message if no video sync is received in sony mode\n * The view layout is configured via the settings.\n */\nclass VideoStripView : public PhGraphicView\n{\n\tQ_OBJECT\npublic:\n\t/**\n\t * @brief VideoStripView constructor\n\t * @param parent The parent object\n\t */\n\texplicit VideoStripView(QWidget *parent = 0);\n\n\t/**\n\t * @brief Get the view's video engine\n\t *\n\t * @return The PhVideoEngine used by the view.\n\t */\n\tPhVideoEngine * videoEngine() {\n\t\treturn &_videoEngine;\n\t}\n\n\t/**\n\t * @brief Get the view's strip\n\t *\n\t * @return The PhGraphicStrip used by the view.\n\t */\n\tPhGraphicStrip * strip() {\n\t\treturn &_strip;\n\t}\n\n\t/**\n\t * @brief Attach the given settings to the view\n\t *\n\t * @param settings The settings\n\t */\n\tvoid setSettings(JokerSettings *settings);\n\n\t/**\n\t * @brief Set the PhSonyController\n\t *\n\t * @param sony The controller\n\t */\n\tvoid setSony(PhSonyController * sony);\n\n\t/*!\n\t * \\brief Set if the video should be displayed with a forced aspect ratio\n\t * \\param force\n\t */\n\tvoid setForceRatio169(bool force) {\n\t\t_forceRatio169 = force;\n\t}\n\nprotected:\n\t/**\n\t * @brief Initialize the VideoStripView elements.\n\t *\n\t * @return True if success false otherwise\n\t */\n\tbool init();\n\t/**\n\t * @brief Paint the VideoStripView elements.\n\t *\n\t * Automatic call, process media information and displays it on the screen.\n\t */\n\tvoid paint();\n\n\t/**\n\t * @brief Get the mouse event of the view\n\t *\n\t * This event filter check for mouse move event in order to:\n\t * - Display vertical resize cursor around the edge between the video and the strip\n\t * - Resize the strip if the user drag the edge\n\t * @param sender The event sender\n\t * @param event The event\n\t * @return Always false\n\t */\n\tbool eventFilter(QObject *sender, QEvent *event);\nprivate slots:\n\tvoid onVideoSync();\n\nprivate:\n\tJokerSettings *_settings;\n\tPhVideoEngine _videoEngine;\n\tPhGraphicStrip _strip;\n\tPhSonyController *_sony;\n\tQTime _lastVideoSyncElapsed;\n\n\tPhGraphicText _titleText;\n\tPhGraphicSolidRect _titleBackgroundRect;\n\tPhGraphicText _tcText;\n\tPhGraphicText _nextTCText;\n\tPhGraphicText _noVideoSyncError;\n\tPhGraphicText _currentPeopleName;\n\n\tPhGraphicImage _logo;\n\n\tbool _forceRatio169;\n};\n\n#endif // VIDEOSTRIPVIEW_H\n", "name": "app/Joker/VideoStripView.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef LTCTOOLSETTINGS_H\n#define LTCTOOLSETTINGS_H\n\n#include \"PhTools/PhGenericSettings.h\"\n\n/**\n * @brief The LTCTool application settings\n */\nclass LTCToolSettings : protected PhGenericSettings\n{\npublic:\n\tPH_SETTING_BOOL2(setGenerate, generate, true)\n\tPH_SETTING_BOOL2(setRead, read, true)\n\n\tPH_SETTING_INT2(setFirstFrame, firstFrame, 25 * 60 * 60)\n\tPH_SETTING_INT2(setLength, length, 25 * 60)\n\n\tPH_SETTING_STRING(setAudioOutput, audioOutput)\n\tPH_SETTING_STRING(setAudioInput, audioInput)\n\n\tPH_SETTING_INT2(setLogMask, logMask, 1)\n};\n\n#endif // LTCTOOLSETTINGS_H\n", "name": "app/LTCTool/LTCToolSettings.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#include \"LTCToolWindow.h\"\n#include \"ui_LTCToolWindow.h\"\n#include \"PhCommonUI/PhTimeCodeDialog.h\"\n#include \"PreferencesDialog.h\"\n\nLTCToolWindow::LTCToolWindow(LTCToolSettings *settings, QWidget *parent) :\n\tQMainWindow(parent),\n\tui(new Ui::LTCToolWindow),\n\t_settings(settings),\n\t_ltcWriter(PhTimeCodeType25),\n\t_ltcReader(PhTimeCodeType25),\n\t_lastFrame(-1),\n\t_frameDelta(-1),\n\t_lastRate(-1)\n{\n\tui->setupUi(this);\n\n\ton_generateCheckBox_clicked(_settings->generate());\n\ton_readCheckBox_clicked(_settings->read());\n\n\t_ltcWriter.clock()->setFrame(_settings->firstFrame());\n\tui->widgetMaster->setMediaLength(_settings->length());\n\tui->widgetMaster->setFirstFrame(_settings->firstFrame());\n\tui->widgetMaster->setClock(_ltcWriter.clock());\n\n\tconnect(_ltcReader.clock(),  SIGNAL(frameChanged(PhFrame, PhTimeCodeType)), this, SLOT(onSlaveFrameChanged(PhFrame, PhTimeCodeType)));\n\tconnect(_ltcReader.clock(),  SIGNAL(rateChanged(PhRate)), this, SLOT(onSlaveRateChanged(PhRate)));\n\n\tupdateInfos();\n\n\tconnect(_ltcWriter.clock(), SIGNAL(frameChanged(PhFrame, PhTimeCodeType)), this, SLOT(onFrameChanged(PhFrame, PhTimeCodeType)));\n\n\tconnect(&_ltcReader, SIGNAL(audioProcessed(int, int)), this, SLOT(onAudioProcessed(int, int)));\n\n}\n\nLTCToolWindow::~LTCToolWindow()\n{\n\tdelete ui;\n}\n\nvoid LTCToolWindow::on_actionSet_TC_In_triggered()\n{\n\tPhTimeCodeDialog dlg(_ltcWriter.clock()->timeCodeType(), ui->widgetMaster->getFirstFrame());\n\tif(dlg.exec()) {\n\t\tui->widgetMaster->setFirstFrame(dlg.frame());\n\t\t_ltcWriter.clock()->setFrame(ui->widgetMaster->getFirstFrame());\n\t\tupdateInfos();\n\t}\n}\n\nvoid LTCToolWindow::on_actionSet_TC_Out_triggered()\n{\n\tPhTimeCodeDialog dlg(_ltcWriter.clock()->timeCodeType(), ui->widgetMaster->getFirstFrame() + ui->widgetMaster->getMediaLength());\n\tif(dlg.exec()) {\n\t\tif(dlg.frame() > ui->widgetMaster->getFirstFrame())\n\t\t\tui->widgetMaster->setMediaLength(dlg.frame() - ui->widgetMaster->getFirstFrame());\n\t\telse\n\t\t\tPHDEBUG << \"Can't set a TC Out inferior to TC In\";\n\t\tupdateInfos();\n\t}\n}\n\nvoid LTCToolWindow::updateInfos()\n{\n\tQString tcIn;\n\tQString tcOut;\n\n\t_settings->setFirstFrame((int) ui->widgetMaster->getFirstFrame());\n\t_settings->setLength((int) ui->widgetMaster->getMediaLength());\n\n\n\ttcIn = PhTimeCode::stringFromFrame(ui->widgetMaster->getFirstFrame(), _ltcWriter.clock()->timeCodeType());\n\ttcOut = PhTimeCode::stringFromFrame(ui->widgetMaster->getFirstFrame() + ui->widgetMaster->getMediaLength(), _ltcWriter.clock()->timeCodeType());\n\n\tui->generateInfoLabel->setText(tcIn + \" -> \" + tcOut);\n}\n\nvoid LTCToolWindow::on_actionPreferences_triggered()\n{\n\tPreferencesDialog dlg(_settings->audioOutput(), _settings->audioInput());\n\tif(dlg.exec()) {\n\t\tPHDEBUG << dlg.selectedAudioOutput();\n\t\t_settings->setAudioOutput(dlg.selectedAudioOutput());\n\t\t_settings->setAudioInput(dlg.selectedAudioInput());\n\n\t\tif(_settings->generate())\n\t\t\tsetupOutput();\n\t\tif(_settings->read())\n\t\t\tsetupInput();\n\t}\n}\n\nvoid LTCToolWindow::onFrameChanged(PhFrame frame, PhTimeCodeType)\n{\n\tif(ui->cBoxLoop->isChecked() and frame > ui->widgetMaster->getMediaLength())\n\t\t_ltcWriter.clock()->setFrame(ui->widgetMaster->getFirstFrame());\n}\n\nvoid LTCToolWindow::onSlaveFrameChanged(PhFrame frame, PhTimeCodeType tcType)\n{\n\tupdateSlaveInfo();\n}\n\nvoid LTCToolWindow::onSlaveRateChanged(PhRate rate)\n{\n\tupdateSlaveInfo();\n}\n\nvoid LTCToolWindow::updateSlaveInfo()\n{\n\tPhFrame frame = _ltcReader.clock()->frame();\n\tPhTimeCodeType tcType = _ltcReader.clock()->timeCodeType();\n\tPhRate rate = _ltcReader.clock()->rate();\n\tif((frame - _lastFrame != _frameDelta) || (rate != _lastRate)) {\n\t\t_frameDelta = frame - _lastFrame;\n\t\tui->readInfoLabel->setText(QString(\"%1 / %2 x%3\")\n\t\t                           .arg(_frameDelta)\n\t\t                           .arg(PhTimeCode::stringFromFrame(frame, tcType))\n\t\t                           .arg(_ltcReader.clock()->rate()));\n\t}\n\t_lastFrame = frame;\n\t_lastRate = rate;\n\n\tui->lblSlave->setText(PhTimeCode::stringFromFrame(frame, tcType));\n}\n\nvoid LTCToolWindow::setupOutput()\n{\n\t_ltcWriter.close();\n\tif(!_ltcWriter.init(_settings->audioOutput())) {\n\t\tQMessageBox::warning(this, tr(\"Error\"),\n\t\t                     tr(\"Error while loading the output device.\\n\"\n\t\t                        \"See log for more informations\"),\n\t\t                     QMessageBox::Ok);\n\t\ton_generateCheckBox_clicked(false);\n\t}\n}\n\nvoid LTCToolWindow::setupInput()\n{\n\t_ltcReader.close();\n\tif(!_ltcReader.init(_settings->audioInput())) {\n\t\tQMessageBox::warning(this, tr(\"Error\"),\n\t\t                     tr(\"Error while loading the input device.\\n\"\n\t\t                        \"See log for more informations\"),\n\t\t                     QMessageBox::Ok);\n\t\ton_readCheckBox_clicked(false);\n\t}\n}\n\nvoid LTCToolWindow::on_generateCheckBox_clicked(bool checked)\n{\n\tui->generatorGroupBox->setEnabled(checked);\n\tui->generateCheckBox->setChecked(checked);\n\t_settings->setGenerate(checked);\n\tif(checked)\n\t\tsetupOutput();\n\telse\n\t\t_ltcWriter.close();\n}\n\nvoid LTCToolWindow::on_readCheckBox_clicked(bool checked)\n{\n\tui->readerGroupBox->setEnabled(checked);\n\tui->readCheckBox->setChecked(checked);\n\t_settings->setRead(checked);\n\tif(checked)\n\t\tsetupInput();\n\telse\n\t\t_ltcReader.close();\n}\n\nvoid LTCToolWindow::onAudioProcessed(int minLevel, int maxLevel)\n{\n\tui->minMaxLevelLabel->setText(QString(\"%1 / %2\").arg(minLevel).arg(maxLevel));\n}\n", "name": "app/LTCTool/LTCToolWindow.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef LTCTOOLWINDOW_H\n#define LTCTOOLWINDOW_H\n\n#include <QMainWindow>\n#include <QTimer>\n#include <QMessageBox>\n\n#include \"PhTools/PhClock.h\"\n#include \"PhSync/PhLtcWriter.h\"\n#include \"PhSync/PhLtcReader.h\"\n\n#include \"LTCToolSettings.h\"\n\nnamespace Ui {\nclass LTCToolWindow;\n}\n/*!\n * \\brief LTCTool main application window\n *\n * The LTCToolWindow class implements the main screen user interface behaviour:\n * - Display the generator TC in / TC out\n * - Display the generator PhMediaPanel\n * - Display the reader timecode label\n * - Opening application dialog : preferences, set TC in, set TC out\n * - Connect the application modules to the interface: PhLtcWriter andPhLtcReader\n */\nclass LTCToolWindow : public QMainWindow\n{\n\tQ_OBJECT\n\npublic:\n\t/*!\n\t * \\brief The LTCToolWindow constructor\n\t * \\param settings The application settings\n\t * \\param parent\n\t */\n\texplicit LTCToolWindow(LTCToolSettings *settings, QWidget *parent = 0);\n\t~LTCToolWindow();\n\nprivate slots:\n\t/* QT auto slots */\n\tvoid on_actionSet_TC_In_triggered();\n\tvoid on_actionSet_TC_Out_triggered();\n\tvoid on_actionPreferences_triggered();\n\n\t/**\n\t * If the application loops the LTC,\n\t * reset clock to tcIn if tc > tcOut\n\t */\n\tvoid onFrameChanged(PhFrame, PhTimeCodeType);\n\tvoid onSlaveFrameChanged(PhFrame frame, PhTimeCodeType tcType);\n\tvoid onSlaveRateChanged(PhRate rate);\n\tvoid updateSlaveInfo();\n\n\tvoid on_generateCheckBox_clicked(bool checked);\n\n\tvoid on_readCheckBox_clicked(bool checked);\n\n\tvoid onAudioProcessed(int minLevel, int maxLevel);\n\nprivate:\n\tvoid setupOutput();\n\tvoid updateInfos();\n\tUi::LTCToolWindow *ui;\n\tLTCToolSettings *_settings;\n\tPhClock *_writingClock;\n\tPhLtcWriter _ltcWriter;\n\tPhLtcReader _ltcReader;\n\n\tPhFrame _lastFrame;\n\tPhFrame _frameDelta;\n\tPhRate _lastRate;\n\n\tvoid setupInput();\n};\n\n#endif // LTCTOOLWINDOW_H\n", "name": "app/LTCTool/LTCToolWindow.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#include \"LTCToolWindow.h\"\n#include <QApplication>\n\n#include \"LTCToolSettings.h\"\n\n/**\n * @brief The application main entry point\n * @param argc Command line argument count\n * @param argv Command line argument list\n * @return 0 if the application works well.\n */\nint main(int argc, char *argv[])\n{\n\tLTCToolSettings settings;\n\n\tPhDebug::setLogMask(settings.logMask());\n\n\tQApplication a(argc, argv);\n\tLTCToolWindow w(&settings);\n\tw.show();\n\n\treturn a.exec();\n}\n", "name": "app/LTCTool/main.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#include \"PreferencesDialog.h\"\n#include \"ui_PreferencesDialog.h\"\n\n#include \"PhAudio/PhAudioOutput.h\"\n#include \"PhAudio/PhAudioInput.h\"\n\nPreferencesDialog::PreferencesDialog(QString audioOutput, QString audioInput, QWidget *parent) :\n\tQDialog(parent),\n\tui(new Ui::PreferencesDialog)\n{\n\tui->setupUi(this);\n\tQList<QString> outputList = PhAudioOutput::outputList();\n\tui->comboBoxOutput->addItems(outputList);\n\tif(outputList.contains(audioOutput))\n\t\tui->comboBoxOutput->setCurrentText(audioOutput);\n\n\tQList<QString> inputList = PhAudioInput::inputList();\n\tui->comboBoxInput->addItems(inputList);\n\tif(inputList.contains(audioInput))\n\t\tui->comboBoxInput->setCurrentText(audioInput);\n}\n\nPreferencesDialog::~PreferencesDialog()\n{\n\tdelete ui;\n}\n\nQString PreferencesDialog::selectedAudioOutput()\n{\n\treturn ui->comboBoxOutput->currentText();\n}\n\nQString PreferencesDialog::selectedAudioInput()\n{\n\treturn ui->comboBoxInput->currentText();\n}\n\n", "name": "app/LTCTool/PreferencesDialog.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef PREFERENCESDIALOG_H\n#define PREFERENCESDIALOG_H\n\n#include <QDialog>\n\nnamespace Ui {\nclass PreferencesDialog;\n}\n\n/*!\n * \\brief LTCTool preferences dialog\n *\n * It allow the user to select the desired input and output.\n */\nclass PreferencesDialog : public QDialog\n{\n\tQ_OBJECT\n\npublic:\n\t/*!\n\t * \\brief Preferences Panel\n\t *\n\t * Create a modal QDialog which prompt the user for devices.\n\t *\n\t * \\param audioOutput\tThe current output device.\n\t * \\param audioInput\tThe current input device.\n\t * \\param parent\t\tThe parent.\n\t */\n\texplicit PreferencesDialog(QString audioOutput, QString audioInput, QWidget *parent = 0);\n\t~PreferencesDialog();\n\t/*!\n\t * \\brief selectedAudioOutput\n\t * \\return The selected output device\n\t */\n\tQString selectedAudioOutput();\n\t/*!\n\t * \\brief selectedAudioInput\n\t * \\return The selected input device\n\t */\n\tQString selectedAudioInput();\n\nprivate:\n\tUi::PreferencesDialog *ui;\n};\n\n#endif // PREFERENCESDIALOG_H\n", "name": "app/LTCTool/PreferencesDialog.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include \"PhTools/PhDebug.h\"\n\n#include \"PhAudio.h\"\n\nPhAudio::PhAudio(QObject *parent) :\n\tQObject(parent),\n\t_stream(NULL),\n\t_paInitOk(false)\n{\n\tPaError err = Pa_Initialize();\n\tif(err == paNoError) {\n\t\tPHDEBUG << \"Port audio initialized:\" << Pa_GetVersionText();\n\t\t_paInitOk = true;\n\t}\n\telse {\n\t\tPHDEBUG << Pa_GetErrorText(err);\n\t}\n}\n\nPhAudio::~PhAudio()\n{\n\tif(_paInitOk) {\n\t\tclose();\n\t\tPa_Terminate();\n\t}\n}\n\nbool PhAudio::init(QString deviceName)\n{\n\tQ_UNUSED(deviceName)\n\treturn _paInitOk;\n}\n\nvoid PhAudio::close()\n{\n\tif(_stream) {\n\t\tPa_CloseStream( _stream );\n\t\t_stream = NULL;\n\t}\n}\n\nint PhAudio::audioCallback(const void *inputBuffer, void *outputBuffer, unsigned long framesPerBuffer, const PaStreamCallbackTimeInfo *, PaStreamCallbackFlags, void *userData)\n{\n\tPhAudio* audio = (PhAudio*)userData;\n\treturn audio->processAudio(inputBuffer, outputBuffer, framesPerBuffer);\n}\n", "name": "libs/PhAudio/PhAudio.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef PHAUDIO_H\n#define PHAUDIO_H\n\n#include <QObject>\n\n#include <portaudio.h>\n\n/**\n * @brief A generic audio device\n *\n * It connects the audio callback to the child audio device processAudio() method.\n */\nclass PhAudio : public QObject\n{\n\tQ_OBJECT\npublic:\n\t/**\n\t * @brief PhAudio constructor\n\t * @param parent The parent object\n\t */\n\texplicit PhAudio(QObject *parent = 0);\n\n\t~PhAudio();\n\n\t/**\n\t * @brief Initialize the device\n\t *\n\t * The method only check if portaudio is initialized.\n\t *\n\t * @param deviceName The device name\n\t * @return True if success, false otherwise\n\t */\n\tvirtual bool init(QString deviceName);\n\n\t/**\n\t * @brief Close the audio device\n\t */\n\tvoid close();\n\nsignals:\n\npublic slots:\n\nprotected:\n\t/**\n\t * @brief Send/request audio buffer for processing\n\t *\n\t * This method depends if it is an output or an input device:\n\t * - output : ask for the next buffer audio data to be filled.\n\t * - input : provide the latest read data.\n\t *\n\t * @param inputBuffer The input data buffer\n\t * @param outputBuffer The output data buffer\n\t * @param framesPerBuffer The number of frame in the buffer\n\t * @return A PaStreamCallbackResult value\n\t */\n\tvirtual int processAudio(const void *inputBuffer, void *outputBuffer, unsigned long framesPerBuffer) = 0;\n\n\t/** @brief The stream */\n\tPaStream *_stream;\n\n\t/**\n\t * @brief The audio callback\n\t *\n\t * This callback only redirect to the processAudio() method.\n\t *\n\t * @param inputBuffer The input data buffer\n\t * @param outputBuffer The output data buffer\n\t * @param framesPerBuffer The number of frame in the buffer\n\t * @param userData A pointer to the PhAudio device\n\t * @return A PaStreamCallbackResult value\n\t */\n\tstatic int audioCallback(const void *inputBuffer, void *outputBuffer,\n\t                         unsigned long framesPerBuffer, const PaStreamCallbackTimeInfo*, PaStreamCallbackFlags,\n\t                         void *userData );\n\nprivate:\n\tbool _paInitOk;\n};\n\n#endif // PHAUDIO_H\n", "name": "libs/PhAudio/PhAudio.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include \"PhTools/PhDebug.h\"\n#include \"PhAudioInput.h\"\n\nPhAudioInput::PhAudioInput(QObject *parent)\n\t: PhAudio(parent)\n{\n}\n\nbool PhAudioInput::init(QString deviceName)\n{\n\tif(!PhAudio::init(deviceName)) {\n\t\treturn false;\n\t}\n\n\tint deviceCount = Pa_GetDeviceCount();\n\n\tPaStreamParameters streamParameters;\n\tstreamParameters.device = Pa_GetDefaultInputDevice();\n\tconst PaDeviceInfo *deviceInfo = Pa_GetDeviceInfo(streamParameters.device);\n\tstreamParameters.channelCount = 1;\n\tstreamParameters.sampleFormat = paUInt8;\n\tstreamParameters.suggestedLatency = 0;\n\tstreamParameters.hostApiSpecificStreamInfo = NULL;\n\n\tbool isThereInput = false;\n\tbool deviceFound = false;\n\n\tfor(int i = 0; i < deviceCount; i++ ) {\n\t\tdeviceInfo = Pa_GetDeviceInfo( i );\n\t\tif(deviceInfo->maxInputChannels > 0 ) {\n\t\t\tisThereInput = true;\n\t\t\tif(deviceName == deviceInfo->name) {\n\t\t\t\tdeviceFound = true;\n\t\t\t\tstreamParameters.device = i;\n\t\t\t\tdeviceInfo = Pa_GetDeviceInfo(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif(!isThereInput) {\n\t\tPHDBG(0) << \"No output device\";\n\t\treturn false;\n\t}\n\tif(deviceName.length() and !deviceFound) {\n\t\tPHDBG(0) << \"Desired input not found :\" << deviceName;\n\t\treturn false;\n\t}\n\n\tPHDBG(0) << \"Opening \" << deviceInfo->name;\n\n#warning /// @todo use the settings for sample rate and frame per buffer\n\tPaError err = Pa_OpenStream(&_stream, &streamParameters, NULL, 48000, 256, paNoFlag, audioCallback, this);\n\tif(err != paNoError) {\n\t\tPHDBG(0) << \"Error while opening the stream : \" << Pa_GetErrorText(err);\n\t\treturn false;\n\t}\n\n\tif(err != paNoError)\n\t\treturn false;\n\n\tif(Pa_StartStream( _stream ) != paNoError)\n\t\treturn false;\n\n\tPHDEBUG << deviceInfo->name << \"is now open.\";\n\n\treturn true;\n}\n\nQList<QString> PhAudioInput::inputList()\n{\n\tPa_Initialize();\n\tQList<QString> names;\n\tint numDevices = Pa_GetDeviceCount();\n\tif( numDevices <= 0 )\n\t\tPHDBG(21) << \"ERROR: Pa_CountDevices returned \" << numDevices;\n\telse {\n\t\tconst PaDeviceInfo *deviceInfo;\n\t\tfor(int i = 0; i < numDevices; i++ ) {\n\t\t\tdeviceInfo = Pa_GetDeviceInfo( i );\n\t\t\tif(deviceInfo->maxInputChannels > 0)\n\t\t\t\tnames.append(QString::fromLatin1(deviceInfo->name));\n\t\t}\n\t}\n\tPa_Terminate();\n\n\treturn names;\n}\n\nint PhAudioInput::processAudio(const void *inputBuffer, void *, unsigned long framesPerBuffer)\n{\n\tconst char *buffer = (const char*)inputBuffer;\n\n\tint minLevel = 0;\n\tint maxLevel = 0;\n\tfor(unsigned long i = 0; i < framesPerBuffer; i++) {\n\t\tif(buffer[i] < minLevel)\n\t\t\tminLevel = buffer[i];\n\t\tif(buffer[i] > maxLevel)\n\t\t\tmaxLevel = buffer[i];\n\t}\n\n\temit audioProcessed(minLevel, maxLevel);\n\n\treturn paContinue;\n}\n", "name": "libs/PhAudio/PhAudioInput.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef PHAUDIOINPUT_H\n#define PHAUDIOINPUT_H\n\n#include \"PhAudio.h\"\n\n/**\n * @brief A generic audio input device\n *\n * Initialize an audio input device. The child must provide an implementation\n * for the processAudio() method.\n */\nclass PhAudioInput : public PhAudio\n{\n\tQ_OBJECT\npublic:\n\t/**\n\t * @brief PhAudioInput constructor\n\t * @param parent The parent object\n\t */\n\texplicit PhAudioInput(QObject *parent = 0);\n\n\t/**\n\t * @brief Initialize the input device\n\t *\n\t * It initialize the input device on the given name if it's found,\n\t * or take the default input device if not.\n\t * @param deviceName The desired input device name\n\t * @return True if succeed, false otherwise\n\t */\n\tbool init(QString deviceName);\n\n\t/**\n\t * @brief Get the input list\n\t * @return Return all the input devices\n\t */\n\tstatic QList<QString> inputList();\n\nsignals:\n\t/**\n\t * @brief Called after audio buffer has been processed\n\t * @param minLevel The minimum audio level of the buffer\n\t * @param maxLevel The maximum audio level of the buffer\n\t */\n\tvoid audioProcessed(int minLevel, int maxLevel);\n\nprotected:\n\tvirtual int processAudio(const void *inputBuffer, void *, unsigned long framesPerBuffer);\n};\n\n#endif // PHAUDIOINPUT_H\n", "name": "libs/PhAudio/PhAudioInput.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include \"PhTools/PhDebug.h\"\n#include \"PhAudioOutput.h\"\n\nPhAudioOutput::PhAudioOutput(QObject *parent)\n\t: PhAudio(parent)\n{\n}\n\nbool PhAudioOutput::init(QString deviceName)\n{\n\tPHDBG(0) << deviceName;\n\n\tif(!PhAudio::init(deviceName)) {\n\t\treturn false;\n\t}\n\n\tint deviceCount = Pa_GetDeviceCount();\n\tif( deviceCount <= 0 ) {\n\t\tPHDBG(0) << \"ERROR: Pa_CountDevices returned \" << deviceCount;\n\t\treturn false;\n\t}\n\n\tPaStreamParameters streamParameters;\n\tstreamParameters.device = Pa_GetDefaultOutputDevice();\n\tstreamParameters.channelCount = 1;\n\tstreamParameters.sampleFormat = paInt8;\n\tstreamParameters.suggestedLatency = 0;\n\tstreamParameters.hostApiSpecificStreamInfo = NULL;\n\n\tbool isThereOutput = false;\n\tbool deviceFound = false;\n\n\tfor(int i = 0; i < deviceCount; i++ ) {\n\t\tconst PaDeviceInfo *deviceInfo;\n\t\tdeviceInfo = Pa_GetDeviceInfo( i );\n\t\tif(deviceInfo->maxOutputChannels > 0 ) {\n\t\t\tisThereOutput = true;\n\t\t\tif(deviceName == QString::fromLatin1(deviceInfo->name)) {\n\t\t\t\tdeviceFound = true;\n\t\t\t\tstreamParameters.device = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif(!isThereOutput) {\n\t\tPHDBG(0) << \"No output device\";\n\t\treturn false;\n\t}\n\tif(deviceName.length() and !deviceFound) {\n\t\tPHDBG(0) << \"Desired output not found :\" << deviceName;\n\t\treturn false;\n\t}\n\n#warning /// @todo use the settings for sample rate and frame per buffer\n\tPaError err = Pa_OpenStream(&_stream, NULL, &streamParameters, 48000, 1920, paNoFlag, audioCallback, this);\n\n\tif(err != paNoError) {\n\t\tPHDBG(0) << \"Error while opening the stream : \" << Pa_GetErrorText(err);\n\t\treturn false;\n\t}\n\n\terr = Pa_StartStream( _stream );\n\tif(err != paNoError) {\n\t\tPHDBG(0) << \"Error while opening the stream : \" << Pa_GetErrorText(err);\n\t\treturn false;\n\t}\n\n\tPHDEBUG << Pa_GetDeviceInfo(streamParameters.device)->name << \"is now open.\";\n\n\treturn true;\n}\n\nQList<QString> PhAudioOutput::outputList()\n{\n\tQList<QString> names;\n\tint numDevices = Pa_GetDeviceCount();\n\tif( numDevices <= 0 )\n\t\tPHDBG(0) << \"ERROR: Pa_CountDevices returned \" << numDevices;\n\telse {\n\t\tconst PaDeviceInfo *deviceInfo;\n\t\tfor(int i = 0; i < numDevices; i++ ) {\n\t\t\tdeviceInfo = Pa_GetDeviceInfo( i );\n\t\t\tif(deviceInfo->maxOutputChannels > 0) {\n\t\t\t\t//PHDEBUG << deviceInfo->name;\n\t\t\t\tnames.append(QString::fromLatin1(deviceInfo->name));\n\t\t\t}\n\t\t}\n\t}\n\n\tforeach(QString string, names) {\n\t\tPHDEBUG << string;\n\t}\n\n\treturn names;\n}\n", "name": "libs/PhAudio/PhAudioOutput.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef PHAUDIOOUTPUT_H\n#define PHAUDIOOUTPUT_H\n\n#include \"PhAudio.h\"\n\n/**\n * @brief A generic audio output device\n *\n * Initialize an audio input device. The child must provide an implementation\n * for the processAudio() method.\n */\nclass PhAudioOutput : public PhAudio\n{\npublic:\n\t/**\n\t * @brief PhAudioOutput constructor\n\t * @param parent The parent object\n\t */\n\tPhAudioOutput(QObject *parent = 0);\n\n\t/**\n\t * @brief Initialize the output device\n\t *\n\t * It initialize the output device on the given name if it's found,\n\t * or take the default output device if not.\n\t * @param deviceName The desired output device name\n\t * @return True if succeed, false otherwise\n\t */\n\tbool init(QString deviceName);\n\n\t/**\n\t * @brief Get the output list\n\t * @return Return all the output devices\n\t */\n\tstatic QList<QString> outputList();\n};\n\n#endif // PHAUDIOOUTPUT_H\n", "name": "libs/PhAudio/PhAudioOutput.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include <QFileInfo>\n#include <QMessageBox>\n\n#include \"PhTools/PhDebug.h\"\n\n#include \"PhDocumentWindow.h\"\n\nPhDocumentWindow::PhDocumentWindow(PhDocumentWindowSettings *settings)\n\t: PhWindow(settings),\n\t_settings(settings)\n{\n\tconnect(&_watcher, SIGNAL(fileChanged(QString)), this, SLOT(onExternalChange(QString)));\n}\n\nvoid PhDocumentWindow::processArg(int argc, char *argv[])\n{\n#warning /// @todo move to PhApplication\n\n\tfor(int i = 1; i < argc; i++) {\n\t\tif(QFile::exists(argv[i]))\n\t\t\t_settings->setCurrentDocument(argv[i]);\n\t}\n\tif(QFile::exists(_settings->currentDocument()))\n\t\topenDocument(_settings->currentDocument());\n\telse\n\t\tupdateRecentDocumentMenu();\n}\n\nvoid PhDocumentWindow::setCurrentDocument(QString fileName)\n{\n\tif(!_watcher.files().isEmpty())\n\t\t_watcher.removePaths(_watcher.files());\n\tif(_watcher.addPath(fileName))\n\t\tPHDEBUG << \"now watching \" << fileName;\n\t_settings->setCurrentDocument(fileName);\n\t_settings->setLastDocumentFolder(QFileInfo(fileName).absolutePath());\n\tthis->setWindowTitle(fileName);\n\n\tQStringList recentDocList = _settings->recentDocumentList();\n\trecentDocList.removeAll(fileName);\n\trecentDocList.insert(0, fileName);\n\twhile(recentDocList.size() > _settings->maxRecentDocument())\n\t\trecentDocList.removeLast();\n\n\t_settings->setRecentDocumentList(recentDocList);\n\n\tupdateRecentDocumentMenu();\n}\n\nvoid PhDocumentWindow::onOpenRecentDocumentTriggered()\n{\n#warning /// @todo check to save if needed\n\topenDocument(sender()->objectName());\n}\n\nvoid PhDocumentWindow::updateRecentDocumentMenu()\n{\n\tif(recentDocumentMenu()) {\n\t\tQStringList recentDocList = _settings->recentDocumentList();\n\n\t\tif(_settings->recentDocumentList().count()) {\n\t\t\trecentDocumentMenu()->clear();\n\t\t\tforeach(QString doc, recentDocList) {\n\t\t\t\tQAction *action = recentDocumentMenu()->addAction(doc);\n\t\t\t\taction->setObjectName(doc);\n\t\t\t\tconnect(action, SIGNAL(triggered()), this, SLOT(onOpenRecentDocumentTriggered()));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid PhDocumentWindow::onExternalChange(QString path)\n{\n\tPHDEBUG << \"File changed :\" << path;\n\topenDocument(_settings->currentDocument());\n}\n", "name": "libs/PhCommonUI/PhDocumentWindow.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef PHDOCUMENTWINDOW_H\n#define PHDOCUMENTWINDOW_H\n\n#include <QMenu>\n#include <QFileSystemWatcher>\n#include <QTime>\n\n#include \"PhWindow.h\"\n#include \"PhDocumentWindowSettings.h\"\n\n/**\n * @brief Common window behaviour for application handling document\n *\n * This class provide common user interface mechanism for application\n * handling document:\n * -\n */\nclass PhDocumentWindow : public PhWindow\n{\n\tQ_OBJECT\npublic:\n\t/**\n\t * @brief PhDocumentWindow constructor\n\t * @param settings The document window settings\n\t */\n\texplicit PhDocumentWindow(PhDocumentWindowSettings *settings);\n\n\t/**\n\t * @brief Process the application argument\n\t *\n\t * Open the file path in the application argument if it exists.\n\t *\n\t * @param argc The arguments count\n\t * @param argv The arguments values\n\t */\n\tvirtual void processArg(int argc, char *argv[]);\nprotected:\n\t/**\n\t * @brief Open a document\n\t * @param fileName The document file name\n\t * @return True if success, false otherwise\n\t */\n\tvirtual bool openDocument(QString fileName) = 0;\n\n\t/**\n\t * @brief Set the current document\n\t *\n\t * Update the current document settings, the windows title and the recent file list.\n\t *\n\t * @param fileName The document file name\n\t */\n\tvoid setCurrentDocument(QString fileName);\n\n\t/**\n\t * @brief The recent document menu item\n\t *\n\t * In order to make the recent document history work,\n\t * the child window must implement this method to give\n\t * the UI menu element to PhDocumentWindow.\n\t *\n\t * @return A menu item reference\n\t */\n\tvirtual QMenu *recentDocumentMenu() = 0;\n\n\t/**\n\t * @brief The file watcher\n\t */\n\tQFileSystemWatcher _watcher;\n\npublic slots:\n\t/**\n\t * @brief On external file change\n\t *\n\t * Handle external changes and reload the file.\n\t * @param path\n\t */\n\tvoid onExternalChange(QString path);\n\nprivate slots:\n\tvoid onOpenRecentDocumentTriggered();\n\nprivate:\n\tvoid updateRecentDocumentMenu();\n\tPhDocumentWindowSettings * _settings;\n};\n\n#endif // PHDOCUMENTWINDOW_H\n", "name": "libs/PhCommonUI/PhDocumentWindow.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef PHDOCUMENTWINDOWSETTINGS_H\n#define PHDOCUMENTWINDOWSETTINGS_H\n\n#include <QString>\n\n#include \"PhWindowSettings.h\"\n\n/**\n * @brief The settings for PhDocumentWindow\n */\nclass PhDocumentWindowSettings : public PhWindowSettings\n{\npublic:\n\t/**\n\t * @brief Get the current document\n\t * @return A file name\n\t */\n\tvirtual QString currentDocument() = 0;\n\t/**\n\t * @brief Set the current document\n\t * @param currentDocument A file name\n\t */\n\tvirtual void setCurrentDocument(QString currentDocument) = 0;\n\n\t/**\n\t * @brief Get the last document folder\n\t * @return A folder path\n\t */\n\tvirtual QString lastDocumentFolder() = 0;\n\t/**\n\t * @brief Set the last document folder\n\t * @param lastDocumentFolder A folder path\n\t */\n\tvirtual void setLastDocumentFolder(QString lastDocumentFolder) = 0;\n\n\t/**\n\t * @brief Get the recent document list\n\t * @return A list of file name\n\t */\n\tvirtual QStringList recentDocumentList() = 0;\n\t/**\n\t * @brief Set the recent document list\n\t * @param list A list of file name\n\t */\n\tvirtual void setRecentDocumentList(QStringList list) = 0;\n\n\t/**\n\t * @brief Get the maximun number of recent document\n\t * @return A number of document\n\t */\n\tvirtual int maxRecentDocument() = 0;\n\n\t/**\n\t * @brief Get the file auto reload property\n\t * @return True if autoreload enabled, false otherwise\n\t */\n\tvirtual bool autoReload() = 0;\n\n\n};\n\n#endif // PHDOCUMENTWINDOWSETTINGS_H\n", "name": "libs/PhCommonUI/PhDocumentWindowSettings.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * Copyright (C) 2012-2014 Phonations\n * License: http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#include <QDir>\n#include <QDateTime>\n#include <QMessageBox>\n#include <QProcess>\n#include <QHostInfo>\n\n#include \"PhFeedbackDialog.h\"\n#include \"ui_PhFeedbackDialog.h\"\n\n\nPhFeedbackDialog::PhFeedbackDialog(PhFeedbackSettings *settings, QWidget *parent) :\n\tQDialog(parent),\n\tui(new Ui::PhFeedbackDialog),\n\t_settings(settings)\n{\n\n\tui->setupUi(this);\n\n\tui->problemLabel->setText(ui->problemLabel->text().arg(QString(APP_NAME)));\n\n\tif(!_settings->emailList().isEmpty())\n\t\tui->comboBoxEmails->addItems(_settings->emailList());\n}\n\nPhFeedbackDialog::~PhFeedbackDialog()\n{\n\tdelete ui;\n}\n\nvoid PhFeedbackDialog::on_buttonBox_accepted()\n{\n\tQStringList emails;\n\tfor(int i = 0; i < ui->comboBoxEmails->count(); i++) {\n\t\temails += ui->comboBoxEmails->itemText(i);\n\t}\n\temails.removeOne(ui->comboBoxEmails->currentText());\n\temails.insert(0, ui->comboBoxEmails->currentText());\n\t_settings->setEmailList(emails);\n\n\n\n\tQString systemConfig;\n\tQString crashLog;\n\tQString appLog;\n\tQString header;\n\tQString preferences;\n\n\n\theader = \"\";\n\n\theader += \"--------Feedback report: \" + QString(APP_NAME) + \" v\" + QString(APP_VERSION) + \"--------\\n\";\n\theader += \"From : \" + ui->comboBoxEmails->currentText() + \"\\n\";\n\tif(!ui->textEditComment->toPlainText().isEmpty())\n\t\theader += \"Message : \" + ui->textEditComment->toPlainText() + \"\\n\";\n\n\n\t// Get the system infos\n\tsystem(\"/usr/sbin/system_profiler SPHardwareDataType > out\");\n\tQFile systemInfoFile(\"./out\");\n\tif(!systemInfoFile.open(QIODevice::ReadOnly))\n\t\tPHDEBUG << systemInfoFile.errorString();\n\telse {\n\t\tQTextStream in(&systemInfoFile);\n\t\twhile(!in.atEnd()) {\n\t\t\tsystemConfig += in.readLine() + \"\\n\";\n\t\t}\n\t\tsystemInfoFile.close();\n\t\tsystem(\"rm out\");\n\t}\n\n\n\t// Get the preferences\n\tQString cmd = \"defaults read com.Phonations.\" + QString(APP_NAME) + \" > out\";\n\tsystem(PHNQ(cmd));\n\tQFile preferencesFile(\"./out\");\n\tif(!preferencesFile.open(QIODevice::ReadOnly)) {\n\t\tPHDEBUG << preferencesFile.errorString();\n\t}\n\telse {\n\t\tQTextStream in(&preferencesFile);\n\t\twhile(!in.atEnd()) {\n\t\t\tpreferences += in.readLine() + \"\\n\";\n\t\t}\n\t\tpreferencesFile.close();\n\t\tsystem(\"rm out\");\n\t}\n\n\n\t// Get the application log\n\tQFile applicationLogFile(QDir::homePath() + \"/Library/Logs/Phonations/\" + APP_NAME + \".log\");\n\tif(!applicationLogFile.open(QIODevice::ReadOnly)) {\n\t\tPHDEBUG << applicationLogFile.errorString();\n\t}\n\telse {\n\t\tQTextStream in(&applicationLogFile);\n\t\twhile(!in.atEnd()) {\n\t\t\tappLog += in.readLine()  + \"\\n\";\n\t\t}\n\t\t// Stripping only the end of the log\n\t\tif(appLog.length() > 10000)\n\t\t\tappLog = appLog.mid(appLog.length() - 10000);\n\t\tapplicationLogFile.close();\n\t}\n\n\n\t// Get the crash log\n\tQString crashFolder = QDir::homePath() + \"/Library/Logs/DiagnosticReports/\";\n\tQDir crashDir(crashFolder);\n\n\tQStringList crashFilters;\n\tcrashFilters.append(QString(APP_NAME) + \"*.crash\" );\n\tcrashDir.setNameFilters(crashFilters);\n\tQStringList crashFiles = crashDir.entryList();\n\tQString lastCrashFilePath = crashFolder + crashFiles.first();\n\tPHDEBUG << \"last crash log:\" << lastCrashFilePath;\n\tforeach(QString file, crashFiles)\n\t{\n\t\tQString filePath = crashFolder + file;\n\t\tif(QFileInfo(filePath).created() > QFileInfo(lastCrashFilePath).created())\n\t\t\tlastCrashFilePath = filePath;\n\t}\n\tPHDEBUG << lastCrashFilePath;\n\tQFile crashFile(lastCrashFilePath);\n\tif(!crashFile.open(QIODevice::ReadOnly)) {\n\t\tPHDEBUG << \"Crash log : \" << crashFile.errorString();\n\t}\n\telse {\n\t\tQTextStream in(&crashFile);\n\t\twhile(!in.atEnd()) {\n\t\t\tcrashLog += in.readLine()  + \"\\n\";\n\t\t}\n\t\tcrashFile.close();\n\t}\n\n\n\tQString name = QString(\"name=%1&\").arg(QHostInfo::localHostName());\n\n\theader.remove(\"[=|&]\");\n\theader.insert(0, \"header=\");\n\theader.append(\"&\");\n\n\tQString post;\n\n\tpost = name + header;\n\n\tif(!preferences.isEmpty()) {\n\t\tpreferences.remove(\"[=|&]\");\n\t\tpreferences.insert(0, \"preferences=\");\n\t\tpreferences.append(\"&\");\n\t\tpost += preferences;\n\t\tPHDEBUG << \"add preferences:\" << preferences.length();\n\t}\n\n\tif(!systemConfig.isEmpty()) {\n\t\tsystemConfig.remove(\"[=|&]\");\n\t\tsystemConfig.insert(0, \"configuration=\");\n\t\tsystemConfig.append(\"&\");\n\t\tpost += systemConfig;\n\t\tPHDEBUG << \"add systemConfig:\" << systemConfig.length();\n\t}\n\n\tif(!appLog.isEmpty()) {\n\t\tappLog.replace(\"&\", \"amp\");\n\t\tappLog.insert(0, \"applicationLog=\");\n\t\tappLog.append(\"&\");\n\t\tpost += appLog;\n\t\tPHDEBUG << \"add appLog:\" << appLog.length();\n\t}\n\n\tif(!crashLog.isEmpty()) {\n\t\tcrashLog.remove(\"[=|&]\");\n\t\tcrashLog.insert(0, \"crashLog=\");\n\t\tcrashLog.append(\"&\");\n\t\tpost += crashLog;\n\t\tPHDEBUG << \"add crashLog:\" << crashLog.length();\n\t}\n\n\tQNetworkRequest request(QUrl(\"http://www.phonations.com/feedback.php\"));\n\trequest.setHeader(QNetworkRequest::ContentTypeHeader, \"application/x-www-form-urlencoded\");\n\tQNetworkAccessManager *manager = new QNetworkAccessManager(this);\n\tconnect(manager, SIGNAL(finished(QNetworkReply*)), this, SLOT(onSyncRequestFinished(QNetworkReply*)));\n\n\t// Send it\n\tmanager->post(request, post.toUtf8());\n\tQMessageBox::information(this, \"Information\",\n\t                         tr(\"Thank you for your feedback!\"),\n\t                         QMessageBox::Ok, QMessageBox::Ok);\n\thide();\n}\n\nvoid PhFeedbackDialog::on_buttonBox_rejected()\n{\n\thide();\n}\n\nvoid PhFeedbackDialog::onSyncRequestFinished(QNetworkReply * reply)\n{\n\tdelete reply;\n}\n", "name": "libs/PhCommonUI/PhFeedbackDialog.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * Copyright (C) 2012-2014 Phonations\n * License: http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef FEEDBACKDIALOG_H\n#define FEEDBACKDIALOG_H\n\n#include <QDialog>\n#include <QNetworkRequest>\n#include <QNetworkAccessManager>\n#include <QJsonObject>\n#include <QNetworkReply>\n\n#include \"PhTools/PhDebug.h\"\n\n#include \"PhFeedbackSettings.h\"\n\n\n\nnamespace Ui {\nclass PhFeedbackDialog;\n}\n\n/**\n * @brief The FeedbackDialog class\n *\n * This class allow the user to send crash\n * report, logs and informations about the\n * machine configuration.\n */\nclass PhFeedbackDialog : public QDialog\n{\n\tQ_OBJECT\n\npublic:\n\t/**\n\t * @brief FeedbackDialog\n\t *\n\t * Default constructor of the feedback module,\n\t * You MUST provide settings to make it work\n\t * normally.\n\t *\n\t * @param settings\n\t * @param parent\n\t */\n\texplicit PhFeedbackDialog(PhFeedbackSettings *settings, QWidget *parent = 0);\n\t~PhFeedbackDialog();\n\nprivate slots:\n\tvoid on_buttonBox_accepted();\n\n\tvoid on_buttonBox_rejected();\n\n\tvoid onSyncRequestFinished(QNetworkReply*reply);\n\nprivate:\n\tUi::PhFeedbackDialog *ui;\n\tPhFeedbackSettings *_settings;\n};\n\n#endif // FEEDBACKDIALOG_H\n", "name": "libs/PhCommonUI/PhFeedbackDialog.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * Copyright (C) 2012-2014 Phonations\n * License: http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef PHFEEDBACKSETTINGS_H\n#define PHFEEDBACKSETTINGS_H\n\n#include \"PhTools/PhGenericSettings.h\"\n\n/**\n * @brief The PhFeedbackSettings class\n *\n */\nclass PhFeedbackSettings\n{\npublic:\n\t/**\n\t * @brief The setting file path\n\t * @return The path\n\t */\n\tvirtual QString settingsFileName() = 0;\n\n\t/**\n\t * @brief emailList\n\t * @return The users list.\n\t */\n\tvirtual QStringList emailList() = 0;\n\t/**\n\t * @brief setEmailList\n\t *\n\t * Replace the current list with the provided one.\n\t *\n\t * @param emails\n\t */\n\tvirtual void setEmailList(QStringList emails) = 0;\n\n};\n#endif // PHFEEDBACKSETTINGS_H\n", "name": "libs/PhCommonUI/PhFeedbackSettings.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#include \"PhFloatingMediaPanel.h\"\n\n#include <QMouseEvent>\n\nPhFloatingMediaPanel::PhFloatingMediaPanel(QWidget *parent) :\n\tPhMediaPanel(parent),\n\t_mousePressed(false),\n\t_mousePressedLocation(-1, -1)\n{\n\t// assign flags\n\tsetWindowFlags(this->windowFlags() | Qt::WindowStaysOnTopHint | Qt::FramelessWindowHint | Qt::NoDropShadowWindowHint);\n}\n\nvoid PhFloatingMediaPanel::mousePressEvent( QMouseEvent *event)\n{\n\t_mousePressed = true;\n\t_mousePressedLocation = event->pos();\n}\n\nvoid PhFloatingMediaPanel::mouseReleaseEvent( QMouseEvent * )\n{\n\t_mousePressed = false;\n}\n\nvoid PhFloatingMediaPanel::mouseMoveEvent( QMouseEvent *event)\n{\n\tif(_mousePressed)\n\t\tthis->move(event->globalPos() - _mousePressedLocation);\n}\n\nbool PhFloatingMediaPanel::isMousePressed()\n{\n\treturn _mousePressed;\n}\n", "name": "libs/PhCommonUI/PhFloatingMediaPanel.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n\n#ifndef PHFLOATINGMEDIAPANEL_H\n#define PHFLOATINGMEDIAPANEL_H\n\n#include <QDialog>\n\n#include \"PhMediaPanel.h\"\n\n/**\n * @brief A floating version of a PhMediaPanel\n *\n * It provides a nice media panel which can control the desired slave (any player).\n *\n */\nclass PhFloatingMediaPanel : public PhMediaPanel\n{\n\tQ_OBJECT\n\npublic:\n\t/**\n\t * @brief PhFloatingMediaPanel constructor\n\t * @param parent The parent object\n\t */\n\texplicit PhFloatingMediaPanel(QWidget *parent = 0);\n\t/**\n\t * @brief Check if mouse button is pressed on PhFloatingMediaPanel\n\t *\n\t * Allow any PhFloatingMediaPanel user to know if the mouse is currently pressed over it.\n\t *\n\t * @return True if the mouse button is pressed, else otherwise\n\t */\n\tbool isMousePressed();\n\nprivate:\n\t// For moving with mouse\n\tbool _mousePressed;\n\tQPoint _mousePressedLocation;\n\n\tvoid mousePressEvent( QMouseEvent * event);\n\tvoid mouseReleaseEvent( QMouseEvent * event );\n\tvoid mouseMoveEvent( QMouseEvent * event );\n};\n\n#endif // PHFLOATINGMEDIAPANEL_H\n", "name": "libs/PhCommonUI/PhFloatingMediaPanel.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#if LEAP\n\n#include <QDebug>\n#include \"PhLeap.h\"\n\nusing namespace Leap;\n\nPhLeap::PhLeap(QObject *parent) : QObject(parent) {\n}\n\nvoid PhLeap::onFrame(const Controller& controller)\n{\n\n\tif(controller.frame().fingers().count() == 1) {\n\t\temit setPosition((controller.frame(1).fingers().leftmost().tipPosition().x - controller.frame().fingers().leftmost().tipPosition().x) * 4);\n\t}\n\tif(controller.frame().fingers().count() == 2) {\n\t\temit setRate(controller.frame().fingers().leftmost().tipPosition().x / 5);\n\t}\n}\n\n#endif\n", "name": "libs/PhCommonUI/PhLeap.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef PHLEAP_H\n#define PHLEAP_H\n\n\n#include <QObject>\n\n#if LEAP\n\n#include \"Leap.h\"\n\nusing namespace Leap;\n\n\nclass PhLeap : public QObject, public Listener\n{\n\n\tQ_OBJECT\n\npublic:\n\texplicit PhLeap(QObject *parent = 0);\n\tvirtual void onFrame(const Controller&);\n\nsignals:\n\tvoid setPosition(int move);\n\tvoid setRate(float move);\n\n\n};\n\n#endif\n#endif // PHLEAP_H\n", "name": "libs/PhCommonUI/PhLeap.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#include <QEvent>\n#include <QApplication>\n\n#include \"PhTools/PhDebug.h\"\n#include \"PhLockableSpinBox.h\"\n\nPhLockableSpinBox::PhLockableSpinBox(QWidget *parent) :\n\tQSpinBox(parent), _pressCounter(0)\n{\n\tsetEnabled(false);\n\tthis->installEventFilter(this);\n}\n\nbool PhLockableSpinBox::eventFilter(QObject *sender, QEvent *event)\n{\n\tQ_UNUSED(sender);\n\tswitch(event->type()) {\n\tcase QEvent::MouseButtonPress:\n\t\tif(_pressTimer.elapsed() > 250)\n\t\t\t_pressCounter = 0;\n\t\tPHDEBUG << _pressCounter++;\n\t\t_pressTimer.restart();\n\t\tif(_pressCounter > 7) {\n\t\t\tPHDEBUG << \"switch\";\n\t\t\tthis->setEnabled(true);\n\t\t\t_pressCounter = 0;\n\t\t}\n\t\tif(QApplication::keyboardModifiers().testFlag(Qt::ControlModifier) == true)\n\t\t\tthis->setEnabled(true);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n", "name": "libs/PhCommonUI/PhLockableSpinBox.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef PHLOCKABLESPINBOX_H\n#define PHLOCKABLESPINBOX_H\n\n#include <QSpinBox>\n#include <QTime>\n\n/**\n * @brief A lockable spin box\n *\n * This spin box is disabled by default: click eight times on it to enable.\n */\nclass PhLockableSpinBox : public QSpinBox\n{\n\tQ_OBJECT\npublic:\n\t/**\n\t * @brief PhLockableSpinBox constructor\n\t * @param parent The parent widget\n\t */\n\texplicit PhLockableSpinBox(QWidget *parent = 0);\n\nprotected:\n\t/**\n\t * @brief Filter the mouse button press event\n\t * @param sender The sender object\n\t * @param event The event\n\t *\n\t * Each times the spin box is clicked, check the last click.\n\t * If the last click was within the last 250 ms, increment the counter.\n\t * If the counter is equal to eight, enable the spin box.\n\t *\n\t * @return Always false\n\t */\n\tbool eventFilter(QObject *sender, QEvent *event);\n\nprivate:\n\tint _pressCounter;\n\tQTime _pressTimer;\n};\n\n#endif // PHLOCKABLESPINBOX_H\n", "name": "libs/PhCommonUI/PhLockableSpinBox.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#include \"PhMediaPanel.h\"\n#include \"ui_PhMediaPanel.h\"\n\nPhMediaPanel::PhMediaPanel(QWidget *parent) :\n\tQWidget(parent),\n\tui(new Ui::PhMediaPanel),\n\t_clock(NULL),\n\t_firstFrame(0),\n\t_mediaLength(0)\n{\n\tui->setupUi(this);\n\n\t//Buttons Init\n\n\tui->_playButton->setIcon(style()->standardIcon(QStyle::SP_MediaPlay));\n\tconnect(ui->_playButton, SIGNAL(clicked()), this, SLOT(onPlayPause()));\n\n\tui->_fastForwardButton->setIcon(style()->standardIcon(QStyle::SP_MediaSeekForward));\n\tconnect(ui->_fastForwardButton, SIGNAL(clicked()), this, SLOT(onFastForward()));\n\n\tui->_fastRewindButton->setIcon(style()->standardIcon(QStyle::SP_MediaSeekBackward));\n\tconnect(ui->_fastRewindButton, SIGNAL(clicked()), this, SLOT(onRewind()));\n\n\tui->_backButton->setIcon(style()->standardIcon(QStyle::SP_MediaSkipBackward));\n\tconnect(ui->_backButton, SIGNAL(clicked()), this, SLOT(onBack()));\n\n\tui->_nextFrameButton->setIcon(style()->standardIcon(QStyle::SP_ArrowForward));\n\tconnect(ui->_nextFrameButton, SIGNAL(clicked()), this, SLOT(onNextFrame()));\n\n\tui->_previousFrameButton->setIcon(style()->standardIcon(QStyle::SP_ArrowBack));\n\tconnect(ui->_previousFrameButton, SIGNAL(clicked()), this, SLOT(onPreviousFrame()));\n\n\tconnect(ui->_slider, SIGNAL(sliderMoved(int)), this, SLOT(onSliderChanged(int)));\n\n\t//Combobox Init\n\n\tui->_rateSelectionBox->addItem(\"23.98 fps\");\n\tui->_rateSelectionBox->addItem(\"24 fps\");\n\tui->_rateSelectionBox->addItem(\"25 fps\");\n\tui->_rateSelectionBox->addItem(\"29.97 fps\");\n\n\tconnect(ui->_rateSelectionBox, SIGNAL(currentIndexChanged(int)), this, SLOT(onTCTypeComboChanged()));\n\n\tui->_playButton->setDefault(true);\n}\n\n\nPhMediaPanel::~PhMediaPanel()\n{\n\tdelete ui;\n}\n\n\nvoid PhMediaPanel::setTCType(PhTimeCodeType tcType)\n{\n\tonTimeCodeTypeChanged(tcType);\n\n\tif(_clock)\n\t\t_clock->setTimeCodeType(tcType);\n}\n\n\nPhTimeCodeType PhMediaPanel::timeCodeType() const\n{\n\tswitch(ui->_rateSelectionBox->currentIndex()) {\n\tcase 0:\n\t\treturn PhTimeCodeType2398;\n\tcase 1:\n\t\treturn PhTimeCodeType24;\n\tcase 3:\n\t\treturn PhTimeCodeType2997;\n\tdefault:\n\t\treturn PhTimeCodeType25;\n\t}\n}\n\n\nvoid PhMediaPanel::setFirstFrame(PhFrame firstFrame)\n{\n\t_firstFrame = firstFrame;\n\tui->_slider->setMinimum(firstFrame);\n\tui->_slider->setMaximum(_firstFrame + _mediaLength);\n}\n\n\nPhFrame PhMediaPanel::getFirstFrame() const\n{\n\treturn _firstFrame;\n}\n\n\nvoid PhMediaPanel::setMediaLength(PhFrame length)\n{\n\t_mediaLength = length;\n\tui->_slider->setMaximum(_firstFrame + length);\n}\n\n\nPhFrame PhMediaPanel::getMediaLength()\n{\n\treturn _mediaLength;\n}\n\nvoid PhMediaPanel::setSliderEnable(bool isEnabled)\n{\n\tui->_slider->setEnabled(isEnabled);\n}\n\nvoid PhMediaPanel::setClock(PhClock *clock)\n{\n\t_clock = clock;\n\tif(_clock) {\n\t\tsetTCType(_clock->timeCodeType());\n\t\tui->_timecodeLabel->setText(PhTimeCode::stringFromFrame(_clock->frame(), _clock->timeCodeType()));\n\t\tconnect(_clock, SIGNAL(frameChanged(PhFrame, PhTimeCodeType)), this, SLOT(onFrameChanged(PhFrame, PhTimeCodeType)));\n\t\tconnect(_clock, SIGNAL(rateChanged(PhRate)), this, SLOT(onRateChanged(PhRate)));\n\t\tconnect(_clock, SIGNAL(tcTypeChanged(PhTimeCodeType)), this, SLOT(onTimeCodeTypeChanged(PhTimeCodeType)));\n\t}\n}\n\n\nvoid PhMediaPanel::onRateChanged(PhRate rate)\n{\n\tui->_rateLabel->setText(\"x\"+QString::number(rate));\n\tif(rate != 0)\n\t\tui->_playButton->setIcon(style()->standardIcon(QStyle::SP_MediaPause));\n\telse\n\t\tui->_playButton->setIcon(style()->standardIcon(QStyle::SP_MediaPlay));\n}\n\nvoid PhMediaPanel::onTimeCodeTypeChanged(PhTimeCodeType tcType)\n{\n\tswitch(tcType) {\n\tcase PhTimeCodeType2398:\n\t\tui->_rateSelectionBox->setCurrentIndex(0);\n\t\tbreak;\n\tcase PhTimeCodeType24:\n\t\tui->_rateSelectionBox->setCurrentIndex(1);\n\t\tbreak;\n\tcase PhTimeCodeType25:\n\t\tui->_rateSelectionBox->setCurrentIndex(2);\n\t\tbreak;\n\tcase PhTimeCodeType2997:\n\t\tui->_rateSelectionBox->setCurrentIndex(3);\n\t\tbreak;\n\t}\n}\n\nvoid PhMediaPanel::onPlayPause()\n{\n\tif(_clock) {\n\t\tif(_clock->rate())\n\t\t\t_clock->setRate(0);\n\t\telse\n\t\t\t_clock->setRate(1);\n\t}\n\temit playPause();\n}\n\nvoid PhMediaPanel::onFastForward()\n{\n\tif(_clock)\n\t\t_clock->setRate(3);\n\temit fastForward();\n}\n\nvoid PhMediaPanel::onRewind()\n{\n\tif(_clock)\n\t\t_clock->setRate(-3);\n\temit rewind();\n}\n\nvoid PhMediaPanel::onBack()\n{\n\tif(_clock)\n\t\t_clock->setFrame(_firstFrame);\n\temit back();\n}\n\nvoid PhMediaPanel::onNextFrame()\n{\n\tif(_clock) {\n\t\t_clock->setRate(0);\n\t\t_clock->setFrame(_clock->frame() + 1);\n\t}\n\temit nextFrame();\n}\n\nvoid PhMediaPanel::onPreviousFrame()\n{\n\tif(_clock) {\n\t\t_clock->setRate(0);\n\t\t_clock->setFrame(_clock->frame() - 1);\n\t}\n\temit previousFrame();\n}\n\nvoid PhMediaPanel::onSliderChanged(int position)\n{\n\tPhFrame frame = (PhFrame)position;\n\tif(_clock)\n\t\t_clock->setFrame(frame);\n\temit goToFrame(frame, timeCodeType());\n}\n\nvoid PhMediaPanel::onTCTypeComboChanged()\n{\n\tif(_clock)\n\t\t_clock->setTimeCodeType(timeCodeType());\n\temit timeCodeTypeChanged(timeCodeType());\n}\n\nvoid PhMediaPanel::onFrameChanged(PhFrame frame, PhTimeCodeType tcType)\n{\n\tui->_timecodeLabel->setText(PhTimeCode::stringFromFrame(frame, tcType));\n\tui->_slider->setSliderPosition(frame);\n}\n\n", "name": "libs/PhCommonUI/PhMediaPanel.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef PHMEDIAPANEL_H\n#define PHMEDIAPANEL_H\n\n#include <QWidget>\n\n#include \"PhTools/PhClock.h\"\n\nnamespace Ui {\nclass PhMediaPanel;\n}\n\n/**\n * @brief Widget for media control\n *\n * This widget contains the main button, slider and combobox\n * to control a media stream such as video, audio or a graphic strip band.\n *\n * If connected to a clock, it can update it when the user interact with it.\n * Otherwise, only signal are triggered and the element display (timecode text,\n * scrollbar position, button state) when calling the corresponding slots.\n */\nclass PhMediaPanel : public QWidget\n{\n\tQ_OBJECT\n\npublic:\n\t/**\n\t * @brief PhMediaPanel constructor\n\t * @param parent The object owner.\n\t */\n\texplicit PhMediaPanel(QWidget *parent = 0);\n\n\t~PhMediaPanel();\n\t/**\n\t * @brief set TC Type\n\t * @param tcType The type coming from PhTimeCodeType\n\t */\n\tvoid setTCType(PhTimeCodeType tcType);\n\t/**\n\t * @brief set the first Frame\n\t * @param firstFrame Desired PhFrame\n\t */\n\tvoid setFirstFrame(PhFrame firstFrame);\n\t/**\n\t * @brief set the media length\n\t * Set the media length and adjust the slider\n\t *\n\t * @param length the desired length\n\t */\n\tvoid setMediaLength(PhFrame length);\n\t/**\n\t * @brief set Slider Enable\n\t * @param isEnabled : true if the slider must be enabled, false otherwise.\n\t */\n\tvoid setSliderEnable(bool isEnabled);\n\n\t/**\n\t * @brief set the clock\n\t * @param clock the clock which will master the PhMediaPanel\n\t */\n\tvoid setClock(PhClock * clock);\n\n\n\t/**\n\t * @brief get the first PhFrame\n\t * @return the corresponding PhFrame\n\t */\n\tPhFrame getFirstFrame() const;\n\n\t/**\n\t * @brief get the media Length\n\t * @return _mediaLength the media length\n\t */\n\tPhFrame getMediaLength();\n\n\t/**\n\t * @brief get the timecode Type\n\t * @return a PhTimeCodeType from the enum\n\t */\n\tPhTimeCodeType timeCodeType() const;\n\nsignals:\n\n\t/**\n\t * @brief Send signal when the play/pause button is pressed.\n\t */\n\tvoid playPause();\n\t/**\n\t * @brief Send signal when the fastForward button is pressed.\n\t */\n\tvoid fastForward();\n\t/**\n\t * @brief Send signal when the rewind button is pressed.\n\t */\n\tvoid rewind();\n\t/**\n\t * @brief Send signal when the back button is pressed.\n\t */\n\tvoid back();\n\t/**\n\t * @brief Send signal when the nextFrame button is pressed.\n\t */\n\tvoid nextFrame();\n\t/**\n\t * @brief Send signal when the previousFrame button is pressed.\n\t */\n\tvoid previousFrame();\n\t/**\n\t * @brief Go to the desired frame\n\t * @param frame the desired frame\n\t * @param tcType the desired PhTimeCodeType\n\t */\n\tvoid goToFrame(PhFrame frame, PhTimeCodeType tcType);\n\t/**\n\t * @brief Send a signal when the timecode type change\n\t * @param tcType the correponding PhTimeCodeType\n\t */\n\tvoid timeCodeTypeChanged(PhTimeCodeType tcType);\npublic slots:\n\n\t/**\n\t * @brief Handle a modicifation of the frame\n\t * @param frame the new frame\n\t * @param tcType the corresponding PhTimeCodeType\n\t */\n\tvoid onFrameChanged(PhFrame frame, PhTimeCodeType tcType);\n\t/**\n\t * @brief Handle a modification of the playing rate\n\t * @param rate the new rate\n\t */\n\tvoid onRateChanged(PhRate rate);\n\t/**\n\t * @brief handle a modification of the timecode type\n\t * @param tcType the new PhTimeCodeType\n\t */\n\tvoid onTimeCodeTypeChanged(PhTimeCodeType tcType);\n\nprivate slots:\n\tvoid onPlayPause();\n\tvoid onFastForward();\n\tvoid onRewind();\n\tvoid onBack();\n\tvoid onNextFrame();\n\tvoid onPreviousFrame();\n\tvoid onSliderChanged(int position);\n\tvoid onTCTypeComboChanged();\n\nprivate:\n\tUi::PhMediaPanel *ui;\n\tPhClock *_clock;\n\tPhFrame _firstFrame;\n\tPhFrame _mediaLength; //number of frames of the media\n};\n\n#endif // PHMEDIAPANEL_H\n", "name": "libs/PhCommonUI/PhMediaPanel.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#include \"PhTimeCodeDialog.h\"\n#include \"ui_PhTimeCodeDialog.h\"\n#include <QDialogButtonBox>\n#include <QPushButton>\n\nPhTimeCodeDialog::PhTimeCodeDialog(PhTimeCodeType tcType, PhFrame frame, QWidget *parent) :\n\tQDialog(parent),\n\tui(new Ui::PhTimeCodeDialog)\n{\n\tui->setupUi(this);\n\tui->_timecodeEdit->setFrame(frame, tcType);\n\n\tconnect(ui->cancelButton, SIGNAL(clicked()), this, SLOT(reject()));\n\tconnect(ui->okButton, SIGNAL(clicked()), this, SLOT(accept()));\n\n\tui->okButton->setDefault(true);\n}\n\nPhTimeCodeDialog::~PhTimeCodeDialog()\n{\n\tdelete ui;\n}\n\nPhFrame PhTimeCodeDialog::frame()\n{\n\treturn ui->_timecodeEdit->frame();\n}\n\nvoid PhTimeCodeDialog::onFrameChanged(PhFrame, PhTimeCodeType)\n{\n\tif(ui->_timecodeEdit->isTimeCode())\n\t\tui->okButton->setEnabled(true);\n\telse\n\t\tui->okButton->setEnabled(false);\n}\n", "name": "libs/PhCommonUI/PhTimeCodeDialog.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef PHTIMECODEDIALOG_H\n#define PHTIMECODEDIALOG_H\n\n#include <QDialog>\n\n#include \"PhTools/PhTimeCode.h\"\n\nnamespace Ui {\nclass PhTimeCodeDialog;\n}\n\n/**\n * @brief A modal dialog box for entering timecode.\n *\n * Launch the dialog using the TimeCodeDialog::exec() method.\n * If it return QDialog::Accepted, it means that a timecode value\n * was input and validated.\n * Otherwise the user pressed cancel.\n */\nclass PhTimeCodeDialog : public QDialog\n{\n\tQ_OBJECT\n\npublic:\n\t/**\n\t * @brief PhTimeCodeDialog constructor\n\t * @param tcType Timecode type to use for string to frame conversion.\n\t * @param frame The dialog initial frame.\n\t * @param parent The object owner.\n\t */\n\texplicit PhTimeCodeDialog(PhTimeCodeType tcType, PhFrame frame = 0, QWidget *parent = 0);\n\n\t~PhTimeCodeDialog();\n\n\t/**\n\t * @brief Current frame value entered in the text field\n\t * @return A frame value.\n\t */\n\tPhFrame frame();\n\n\nprivate slots:\n\tvoid onFrameChanged(PhFrame frame, PhTimeCodeType tcType);\n\nprivate:\n\tUi::PhTimeCodeDialog *ui;\n};\n\n#endif // PHTIMECODEDIALOG_H\n", "name": "libs/PhCommonUI/PhTimeCodeDialog.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#include \"PhTimeCodeEdit.h\"\n\nPhTimeCodeEdit::PhTimeCodeEdit(QWidget *parent) :\n\tQLineEdit(parent)\n{\n\tsetFrame(0, PhTimeCodeType25);\n\tconnect(this, SIGNAL(textChanged(QString)), this, SLOT(onTextChanged(QString)));\n\tthis->installEventFilter(this);\n\t//Only accept numbers and \":\" it avoid the use of special\n\t//chars like ` or ^\n\tQRegExp rx(\"([0-9]|:){11}\");\n\tsetValidator(new QRegExpValidator(rx, this));\n\t_mousePressed = false;\n\t_selectedIndex = 0;\n}\n\nvoid PhTimeCodeEdit::setFrame(PhFrame frame, PhTimeCodeType tcType)\n{\n\t_tcType = tcType;\n\tthis->setText(PhTimeCode::stringFromFrame(frame, tcType));\n\tif(_oldFrame.length() == 0)\n\t\t_oldFrame = this->text();\n\n}\n\nbool PhTimeCodeEdit::isTimeCode()\n{\n\tPhFrame frame;\n\tQString text;\n\tframe = PhTimeCode::frameFromString(this->text(), _tcType);\n\ttext = PhTimeCode::stringFromFrame(frame, _tcType);\n\n\tif(text == this->text())\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nPhFrame PhTimeCodeEdit::frame()\n{\n\treturn PhTimeCode::frameFromString(this->text(), _tcType);\n}\n\nvoid PhTimeCodeEdit::onTextChanged(QString text)\n{\n\tif(isTimeCode()) {\n\t\tPhFrame frame = PhTimeCode::frameFromString(text, _tcType);\n\t\temit frameChanged(frame, _tcType);\n\t}\n}\n\nbool PhTimeCodeEdit::eventFilter(QObject *, QEvent *event)\n{\n\tint keyPressed;\n\tswitch (event->type()) {\n\tcase QEvent::KeyPress:\n\t\tkeyPressed = static_cast<QKeyEvent *>(event)->key();\n\t\tswitch (keyPressed) {\n\t\tcase Qt::Key_0:\n\t\tcase Qt::Key_1:\n\t\tcase Qt::Key_2:\n\t\tcase Qt::Key_3:\n\t\tcase Qt::Key_4:\n\t\tcase Qt::Key_5:\n\t\tcase Qt::Key_6:\n\t\tcase Qt::Key_7:\n\t\tcase Qt::Key_8:\n\t\tcase Qt::Key_9:\n\t\t\tif(_addedNumbers.length() < 8) {\n\t\t\t\t_addedNumbers.append(QString::number(keyPressed % 0x30));\n\t\t\t\tcompute(true);\n\t\t\t}\n\t\t\treturn true;\n\t\tcase Qt::Key_Backspace:\n\t\t\tif(_addedNumbers.length()) {\n\t\t\t\t_addedNumbers.remove(_addedNumbers.length() - 1, 1);\n\t\t\t\tcompute(false);\n\t\t\t}\n\t\t\treturn true;\n\t\tcase Qt::Key_Escape:\n\t\tcase Qt::Key_Enter:\n\t\tcase Qt::Key_Return:\n\t\t\treturn false;\n\t\tdefault:\n\t\t\treturn true;\n\t\t}\n\tcase QEvent::MouseButtonPress:\n\t\tQApplication::setOverrideCursor(Qt::SizeVerCursor);\n\t\t_mousePressed = true;\n\t\t_mousePressedLocation = static_cast<QMouseEvent *>(event)->pos();\n#warning /// @todo make it font size independant\n\t\tif(_mousePressedLocation.x() > 110 and _mousePressedLocation.x() < 145) {\n\t\t\t_selectedIndex = 0;\n\t\t}\n\t\telse if(_mousePressedLocation.x() >= 145 and _mousePressedLocation.x() < 190) {\n\t\t\t_selectedIndex = 3;\n\t\t}\n\t\telse if(_mousePressedLocation.x() >= 190 and _mousePressedLocation.x() < 230) {\n\t\t\t_selectedIndex = 6;\n\t\t}\n\t\telse if(_mousePressedLocation.x() >= 230 and _mousePressedLocation.x() < 270) {\n\t\t\t_selectedIndex = 9;\n\t\t}\n\t\treturn true;\n\tcase QEvent::MouseButtonRelease:\n\t\tQApplication::setOverrideCursor(Qt::ArrowCursor);\n\t\t_mousePressed = false;\n\t\treturn true;\n\tcase QEvent::MouseMove:\n\t\t{\n\t\t\tif(_mousePressed) {\n\t\t\t\tint y = static_cast<QMouseEvent *>(event)->pos().y();\n\t\t\t\tPhFrame currentFrame = PhTimeCode::frameFromString(this->text(), _tcType);\n\n\t\t\t\tif(_selectedIndex == 0) {\n\t\t\t\t\tif(_mousePressedLocation.y() > y)\n\t\t\t\t\t\tcurrentFrame += 25 * 60 * 60;\n\t\t\t\t\telse\n\t\t\t\t\t\tcurrentFrame -= 25 * 60 * 60;\n\t\t\t\t}\n\t\t\t\telse if(_selectedIndex == 3) {\n\t\t\t\t\tif(_mousePressedLocation.y() > y)\n\t\t\t\t\t\tcurrentFrame += 25 * 60;\n\t\t\t\t\telse\n\t\t\t\t\t\tcurrentFrame -= 25 * 60;\n\t\t\t\t}\n\t\t\t\telse if(_selectedIndex == 6) {\n\t\t\t\t\tif(_mousePressedLocation.y() > y)\n\t\t\t\t\t\tcurrentFrame += 25;\n\t\t\t\t\telse\n\t\t\t\t\t\tcurrentFrame -= 25;\n\t\t\t\t}\n\t\t\t\telse if(_selectedIndex == 9) {\n\t\t\t\t\tif(_mousePressedLocation.y() > y)\n\t\t\t\t\t\tcurrentFrame++;\n\t\t\t\t\telse\n\t\t\t\t\t\tcurrentFrame--;\n\t\t\t\t}\n\n\t\t\t\t_mousePressedLocation.setY(y);\n\t\t\t\tthis->setText(PhTimeCode::stringFromFrame(currentFrame, _tcType));\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nvoid PhTimeCodeEdit::compute(bool add)\n{\n\tQString currentText;\n\tif(add)\n\t\tcurrentText = this->text();\n\telse\n\t\tcurrentText = _oldFrame;\n\tcurrentText.remove(\":\");\n\n\tint i = 0;\n\twhile(i < _addedNumbers.length()) {\n\t\tcurrentText.replace(currentText.length() - 1 - i, 1, _addedNumbers.at(_addedNumbers.length() - 1 - i));\n\t\ti++;\n\t}\n\t//Current text is xxxxxxxx\n\tcurrentText.insert(2, \":\");\n\t//xx:xxxxxx\n\tcurrentText.insert(5, \":\");\n\t//xx:xx:xxxx\n\tcurrentText.insert(8, \":\");\n\t//xx:xx:xx:xx\n\n\tthis->setText(currentText);\n\tonTextChanged(this->text());\n}\n\nvoid PhTimeCodeEdit::paintEvent(QPaintEvent *e)\n{\n\tif(_mousePressed) {\n\t\tif(text().contains(\"-\"))\n\t\t\tsetSelection(_selectedIndex + 1, 2);\n\t\telse\n\t\t\tsetSelection(_selectedIndex, 2);\n\t}\n\telse\n\t\tdeselect();\n\tQLineEdit::paintEvent(e);\n}\n\n\n", "name": "libs/PhCommonUI/PhTimeCodeEdit.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef TIMECODEEDIT_H\n#define TIMECODEEDIT_H\n\n#include <QWidget>\n#include <QEvent>\n#include <QLineEdit>\n#include <QKeyEvent>\n#include <QRegExpValidator>\n#include <QApplication>\n\n#include \"PhTools/PhTimeCode.h\"\n#include \"PhTools/PhDebug.h\"\n\n/**\n * @brief Provides an UI to edit a timecode\n */\nclass PhTimeCodeEdit : public QLineEdit\n{\n\tQ_OBJECT\n\npublic:\n\t/**\n\t * @brief PhTimeCodeEdit constructor\n\t * @param parent The parent object\n\t */\n\texplicit PhTimeCodeEdit(QWidget *parent = 0);\n\n\t/**\n\t * @brief set Frame\n\t *\n\t * The corresponding timecode will be displayed on the window.\n\t * For example, if frame = 32 and tcType = PhTimeCodeType24, the\n\t * window will display 00:00:01:12\n\t * @param frame the desired PhFrame\n\t * @param tcType the corresponding PhTimeCodeType\n\t */\n\tvoid setFrame(PhFrame frame, PhTimeCodeType tcType);\n\n\t/**\n\t * @brief Check the timecode\n\t * @return true if the input is correct, false otherwise\n\t */\n\tbool isTimeCode();\n\t/**\n\t * @brief Current frame value entered in the text field\n\t * @return A frame value.\n\t */\n\tPhFrame frame();\n\nsignals:\n\n\t/**\n\t * @brief Send a signal when the text box frame changed\n\t * @param frame the new frame\n\t * @param tcType the new PhTimeCodeType\n\t */\n\tvoid frameChanged(PhFrame frame, PhTimeCodeType tcType);\n\nprivate slots:\n\tvoid onTextChanged(QString text);\n\nprivate:\n\tPhTimeCodeType _tcType;\n\tbool eventFilter(QObject *sender, QEvent *event);\n\tQString _oldFrame;\n\tQString _addedNumbers;\n\tvoid compute(bool add);\n\tint _selectedIndex;\n\n\tbool _mousePressed;\n\tQPoint _mousePressedLocation;\n\n\tvoid paintEvent(QPaintEvent *);\n};\n\n#endif // TIMECODEEDIT_H\n", "name": "libs/PhCommonUI/PhTimeCodeEdit.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include <QTimer>\n#include <QAction>\n#include <QGuiApplication>\n\n#include \"PhTools/PhDebug.h\"\n\n#include \"PhWindow.h\"\n\nPhWindow::PhWindow(PhWindowSettings *settings) :\n\tQMainWindow(NULL),\n\t_settings(settings)\n{\n\t// Set up a filter for catching event\n\tthis->installEventFilter(this);\n\n\tif(_settings->fullScreen()) {\n\t\tPHDEBUG << \"Going fullscreen...\";\n\t\tQTimer::singleShot(1000, this, SLOT(showFullScreen()));\n\t}\n\telse {\n\t\tPHDEBUG << \"Restoring geometry...\";\n\t\tQMainWindow::restoreGeometry(_settings->windowGeometry());\n\t}\n\n\tconnect(qApp, SIGNAL(applicationStateChanged(Qt::ApplicationState)), this, SLOT(onApplicationStateChange(Qt::ApplicationState)));\n}\n\nbool PhWindow::eventFilter(QObject *sender, QEvent *event)\n{\n\tQ_UNUSED(sender)\n\tswitch(event->type()) {\n\tcase QEvent::WindowStateChange:\n\t\t{\n\t\t\t_settings->setFullScreen(QMainWindow::isFullScreen());\n\t\t\t_settings->setWindowGeometry(QMainWindow::saveGeometry());\n\t\t\tif(this->fullScreenAction()) {\n\t\t\t\tthis->fullScreenAction()->setCheckable(true);\n\t\t\t\tthis->fullScreenAction()->setChecked(QMainWindow::isFullScreen());\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n\nvoid PhWindow::moveEvent(QMoveEvent *)\n{\n\t_settings->setWindowGeometry(QMainWindow::saveGeometry());\n}\n\nvoid PhWindow::resizeEvent(QResizeEvent *)\n{\n\t_settings->setWindowGeometry(QMainWindow::saveGeometry());\n}\n\nvoid PhWindow::onApplicationStateChange(Qt::ApplicationState state)\n{\n\tswitch(state) {\n\tcase Qt::ApplicationActive:\n\t\tonApplicationActivate();\n\t\tbreak;\n\tcase Qt::ApplicationInactive:\n\t\tonApplicationDeactivate();\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nvoid PhWindow::toggleFullScreen()\n{\n\tPHDEBUG;\n\tif(QMainWindow::isFullScreen())\n\t\tQMainWindow::showNormal();\n\telse\n\t\tQMainWindow::showFullScreen();\n}\n", "name": "libs/PhCommonUI/PhWindow.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef PHWINDOW_H\n#define PHWINDOW_H\n\n#include <QKeyEvent>\n#include <QMainWindow>\n\n#include \"PhWindowSettings.h\"\n\n/**\n * @brief Common window behaviour for application\n *\n * This class provide common user interface mechanism:\n * - Save window geometry\n */\nclass PhWindow : public QMainWindow\n{\n\tQ_OBJECT\npublic:\n\t/**\n\t * @brief PhWindow constructor\n\t * @param settings The window settings\n\t */\n\texplicit PhWindow(PhWindowSettings *settings);\n\npublic slots:\n\t/**\n\t * @brief Toggle between fullscreen and normal\n\t */\n\tvoid toggleFullScreen();\n\nprotected:\n\t/**\n\t * @brief Custom event filter\n\t *\n\t * The event filter catch the following event:\n\t * - WindowStateChange: to update the fullscreen setting\n\t *\n\t * @param sender The event sender\n\t * @param event The event\n\t * @return True if handled, false otherwise\n\t */\n\tvirtual bool eventFilter(QObject *sender, QEvent *event);\n\t/**\n\t * @brief moveEvent Store the window geometry in the settings\n\t */\n\tvoid moveEvent(QMoveEvent *);\n\t/**\n\t * @brief resizeEvent Store the window geometry in the settings\n\t */\n\tvoid resizeEvent(QResizeEvent *);\n\n\t/**\n\t * @brief The fullScreen action\n\t *\n\t * In order to update the fullScreen action check\n\t * according to the fullscreen test (trigger by the\n\t * toogleFullscreen() slot or by clicking the fullscreen\n\t * top right icon (under MacOS), the child window must\n\t * implement this method to give the action to PhWindow.\n\t * The action must be connected by the child\n\t * to the toogleFullscreen() slot.\n\t *\n\t * @return An action reference\n\t */\n\tvirtual QAction *fullScreenAction() {\n\t\treturn NULL;\n\t}\n\n\t/**\n\t * @brief Called when the application is activated\n\t */\n\tvirtual void onApplicationActivate() {\n\t};\n\n\t/**\n\t * @brief Called when the application is deactivated\n\t */\n\tvirtual void onApplicationDeactivate() {\n\t}\n\nprivate slots:\n\tvoid onApplicationStateChange(Qt::ApplicationState state);\n\nprivate:\n\tPhWindowSettings *_settings;\n};\n\n#endif // PHWINDOW_H\n", "name": "libs/PhCommonUI/PhWindow.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef PHWINDOWSETTINGS_H\n#define PHWINDOWSETTINGS_H\n\n#include <QByteArray>\n\n/**\n * @brief The settings for PhDocumentWindow\n */\nclass PhWindowSettings\n{\npublic:\n\t/**\n\t * @brief PhWindowSettings constructor\n\t */\n\tPhWindowSettings() : _fullScreen(false) {\n\t}\n\n\t/**\n\t * @brief The window full screen status\n\t * @return True if full screen, false otherwise\n\t */\n\tvirtual bool fullScreen() {\n\t\treturn _fullScreen;\n\t}\n\t/**\n\t * @brief Store the fullscreen status\n\t * @param fullScreen True if full screen, false otherwise\n\t */\n\tvirtual void setFullScreen(bool fullScreen) {\n\t\t_fullScreen = fullScreen;\n\t}\n\n\t/**\n\t * @brief Get the last window geometry\n\t * @return A byte array\n\t */\n\tvirtual QByteArray windowGeometry() = 0;\n\t/**\n\t * @brief Store the window geometry\n\t * @param geometry A byte array\n\t */\n\tvirtual void setWindowGeometry(QByteArray geometry) = 0;\n\nprivate:\n\tbool _fullScreen;\n};\n\n#endif // PHWINDOWSETTINGS_H\n", "name": "libs/PhCommonUI/PhWindowSettings.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#include <QtGlobal>\n\n#if defined(Q_OS_WIN)\n#include <GL/glu.h>\n#else\n#include <glu.h>\n#endif\n\n#include \"PhFont.h\"\n#include \"PhTools/PhDebug.h\"\n\nPhFont::PhFont() : _texture(-1), _glyphHeight(0), _boldness(0)\n{\n}\n\nbool PhFont::setFontFile(QString fontFile)\n{\n\tif(fontFile != this->_fontFile) {\n\t\tPHDEBUG << fontFile;\n\t\tthis->_fontFile = fontFile;\n\t\treturn init(this->_fontFile);\n\t}\n\treturn true;\n}\n\nQString PhFont::getFontFile()\n{\n\treturn _fontFile;\n}\n\nint PhFont::computeMaxFontSize(QString file)\n{\n\tint size = 25;\n\tint fontHeight = 128;\n\tint low = 0, high = 1000;\n\twhile (low < high) {\n\t\tsize = (low + high) / 2;\n\t\tTTF_Font * font = TTF_OpenFont(file.toStdString().c_str(), size);\n\t\tif (fontHeight == TTF_FontHeight(font))\n\t\t\tbreak;\n\t\telse if (fontHeight < TTF_FontHeight(font))\n\t\t\thigh = size - 1;\n\t\telse\n\t\t\tlow = size + 1;\n\t\tTTF_CloseFont(font);\n\t}\n\tTTF_Font * font = TTF_OpenFont(file.toStdString().c_str(), size);\n\tif(fontHeight < TTF_FontHeight(font))\n\t\tsize--;\n\tTTF_CloseFont(font);\n\n\treturn size;\n}\n\n// This will split the setting of the bolness and the fontfile, which allow to change the boldness without reloading a font\nbool PhFont::init(QString fontFile)\n{\n\tint size = computeMaxFontSize(fontFile);\n\tPHDEBUG << \"Opening\" << fontFile << \"at size\" << size;\n\tTTF_Font * font = TTF_OpenFont(fontFile.toStdString().c_str(), size);\n\n\n\tif(!font)\n\t\treturn false;\n\n\t//Font foreground color is white\n\tSDL_Color color = {255, 255, 255, 255};\n\n\t// used to set the base surface\n\tUint32 rmask = 0x000000ff;\n\tUint32 gmask = 0x0000ff00;\n\tUint32 bmask = 0x00ff0000;\n\tUint32 amask = 0xff000000;\n\tSDL_Surface * matrixSurface = SDL_CreateRGBSurface(0, 2048, 2048, 32, rmask, gmask, bmask, amask);\n\n\t// Font background color is transparent\n\tUint32 backgroundColor = 0x00000000;\n\tSDL_FillRect(matrixSurface, NULL, backgroundColor);\n\n\t// Space between glyph\n\tint space = 128;\n\t_glyphHeight = 0;\n\n\t//set the boldness\n\tPHDEBUG << \"Setting the font boldness to :\" << _boldness;\n\tfor(int i = 0; i <= _boldness; i++) {\n\t\tTTF_SetFontOutline(font, i);\n\t\t// We get rid of the 32 first useless char\n\t\tfor(Uint16 ch = 32; ch < 256; ++ch) {\n\t\t\tif(TTF_GlyphIsProvided(font, ch)) {\n\t\t\t\tint minx, maxx, miny, maxy, advance;\n\t\t\t\tTTF_GlyphMetrics(font, ch, &minx, &maxx, &miny, &maxy, &advance);\n\t\t\t\tif(advance != 0) {\n\t\t\t\t\t// First render the glyph to a surface\n\t\t\t\t\tSDL_Surface * glyphSurface = TTF_RenderGlyph_Blended(font, ch, color);\n\t\t\t\t\tif (!glyphSurface)\n\t\t\t\t\t\tPHDEBUG << \"Error during the Render Glyph of \" << (char) ch << SDL_GetError();\n\t\t\t\t\tSDL_Rect glyphRect;\n\t\t\t\t\tglyphRect.x = (ch % 16) * space;\n\t\t\t\t\tglyphRect.y = (ch / 16) * space;\n\t\t\t\t\tglyphRect.w = glyphSurface->w;\n\t\t\t\t\tglyphRect.h = glyphSurface->h;\n\t\t\t\t\tif(glyphRect.h > _glyphHeight)\n\t\t\t\t\t\t_glyphHeight = glyphRect.h;\n\t\t\t\t\t//PHDEBUG << ch << (char) ch << minx << maxx << miny << maxy << advance << _glyphHeight;\n\t\t\t\t\t// Then blit it to the matrix\n\t\t\t\t\tSDL_BlitSurface( glyphSurface, NULL, matrixSurface, &glyphRect );\n\n\t\t\t\t\t// Store information about the glyph\n\t\t\t\t\t_glyphAdvance[ch] = advance;\n\n\t\t\t\t\tSDL_FreeSurface(glyphSurface);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tPHDEBUG <<\" Error with Glyph of char:\" << ch << (char) ch << minx << maxx << miny << maxy << advance;\n\t\t\t}\n\t\t\telse\n\t\t\t\t_glyphAdvance[ch] = 0;\n\t\t}\n\t}\n\n\tglEnable( GL_TEXTURE_2D );\n\t// Have OpenGL generate a texture object handle for us\n\tglGenTextures( 1, &_texture );\n\n\t// Bind the texture object\n\tglBindTexture( GL_TEXTURE_2D, _texture );\n\n\n\t// Edit the texture object's image data using the information SDL_Surface gives us\n\tglTexImage2D( GL_TEXTURE_2D, 0, matrixSurface->format->BytesPerPixel, matrixSurface->w, matrixSurface->h, 0,\n\t              GL_RGBA, GL_UNSIGNED_BYTE, matrixSurface->pixels);\n\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n\n\t// Once the texture is created, the surface is no longer needed.\n\tSDL_FreeSurface(matrixSurface);\n\tTTF_CloseFont(font);\n\n\treturn true;\n}\n\nint PhFont::getAdvance(unsigned char ch)\n{\n\treturn _glyphAdvance[ch];\n}\n\nvoid PhFont::select()\n{\n\tglBindTexture(GL_TEXTURE_2D, (GLuint)_texture);\n}\n\nint PhFont::getBoldness() const\n{\n\treturn _boldness;\n}\n\nint PhFont::getNominalWidth(QString string)\n{\n\tint width = 0;\n\tforeach(QChar c, string) {\n\t\twidth += getAdvance(c.toLatin1());\n\t}\n\treturn width;\n}\n\nvoid PhFont::setBoldness(int value)\n{\n\tif(_boldness != value) {\n\t\t_boldness = value;\n\t\tinit(_fontFile);\n\t}\n}\n\n", "name": "libs/PhGraphic/PhFont.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license: http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef PHFONT_H\n#define PHFONT_H\n\n#include <QString>\n\n#include <QtGlobal>\n#if defined(Q_OS_MAC)\n#include <SDL2_ttf/SDL_ttf.h>\n#else\n#include <SDL2/SDL_ttf.h>\n#endif\n\n/**\n * @brief Describe the font appearance for PhGraphicText\n *\n * The PhFont instance are initialized with a true type font file.\n * The boldness can be configured.\n */\nclass PhFont\n{\npublic:\n\t/**\n\t * @brief PhFont constructor\n\t */\n\tPhFont();\n\n\t/**\n\t * @brief Set the source font file.\n\t * @param fontFile Path to the new font file\n\t * @return true if the font was loaded successfully, false otherwise.\n\t */\n\tbool setFontFile(QString fontFile);\n\n\t/**\n\t * @brief Get the font file\n\t * @return the path to the font file\n\t */\n\tQString getFontFile();\n\n\t/**\n\t * @brief Get the regular advance offset of a character.\n\t *\n\t * The returned value is correspond to the amount of pixel the character at a regular text size (100).\n\t * This value must be converted proportionaly if the text width is scaled.\n\t * @param ch ASCII index of the character.\n\t * @return A value in pixel.\n\t */\n\tint getAdvance(unsigned char ch);\n\n\t/**\n\t * @brief Get the regular height of the font.\n\t *\n\t * The returned value is correspond to the amount of pixel the character at a regular text size (100).\n\t * This value must be converted proportionaly if the text width is scaled.\n\t * @return A value in pixel.\n\t */\n\tint getHeight() {\n\t\treturn _glyphHeight;\n\t}\n\n\t/**\n\t * @brief Select the font for the further rendering operation.\n\t */\n\tvoid select();\n\n\t/**\n\t * @brief Set the font boldness\n\t * The boldness is created using <a href=http://www.libsdl.org/projects/SDL_ttf/docs/SDL_ttf_24.html#SEC24>TTF_SetFontOutline</a>\n\t * multiple times from 0 to value\n\t * @param value the number of pass\n\t */\n\tvoid setBoldness(int value);\n\n\t/**\n\t * @brief Get boldness\n\t * @return the number of outline pass\n\t */\n\tint getBoldness() const;\n\n\t/**\n\t * @brief Get the nominal width of a given string\n\t * @param string to be measured\n\t * @return The length\n\t */\n\tint getNominalWidth(QString string);\n\n\t/**\n\t * @brief Compute the maximum font size\n\t * @param file A font file\n\t *\n\t * Compute the maximum font size to initialize the font with\n\t * so the glyph never take more than 128 pixel\n\t * @return A font size.\n\t */\n\tstatic int computeMaxFontSize(QString file);\nprivate:\n\t/**\n\t * @brief _texture\n\t * The texture reference\n\t */\n\tunsigned int _texture;\n\n\tbool init(QString _fontFile);\n\n\t/**\n\t * @brief Store the regular advance of each glyph.\n\t */\n\tint _glyphAdvance[256];\n\n\t/**\n\t * @brief Store the regular advance of the font.\n\t */\n\tint _glyphHeight;\n\n\tQString _fontFile;\n\n\tint _boldness;\n};\n\n#endif // PHFONT_H\n", "name": "libs/PhGraphic/PhFont.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include \"PhGraphicArrow.h\"\n\nPhGraphicArrow::PhGraphicArrow(PhGraphicArrow::PhGraphicArrowDirection direction, int x, int y, int w, int h)\n\t: PhGraphicRect(x, y, w, h),\n\t_direction(direction)\n\n{\n}\n\nvoid PhGraphicArrow::setDirection(PhGraphicArrow::PhGraphicArrowDirection direction)\n{\n\t_direction = direction;\n}\n\nvoid PhGraphicArrow::draw()\n{\n\tglColor3f(_color.redF(), _color.greenF(), _color.blueF());\n\n\tint thickness = _h / 10;\n\tint nose = _h / 3;\n\n\tswitch (_direction) {\n\tcase DownLeftToUpRight:\n\t\tglBegin(GL_QUADS);\n\t\t{\n\t\t\tglVertex3i(_x,      _y + thickness, _z);\n\t\t\tglVertex3i(_x+ thickness,      _y, _z);\n\t\t\tglVertex3i(_x + _w, _y + _h- thickness,  _z);\n\t\t\tglVertex3i(_x + _w - thickness, _y + _h,  _z);\n\t\t}\n\t\tglEnd();\n\n\t\tglBegin(GL_TRIANGLES);\n\t\t{\n\t\t\tglVertex3i(_x + _w, _y + _h,  _z);\n\t\t\tglVertex3i(_x + _w - nose, _y + _h,  _z);\n\t\t\tglVertex3i(_x + _w, _y + _h- nose,  _z);\n\t\t}\n\t\tglEnd();\n\t\tbreak;\n\tcase UpLefToDownRight:\n\t\tglBegin(GL_QUADS);\n\t\t{\n\t\t\tglVertex3i(_x + _w -thickness, _y, _z);\n\t\t\tglVertex3i(_x,      _y + _h-thickness,  _z);\n\t\t\tglVertex3i(_x+thickness,      _y + _h,  _z);\n\t\t\tglVertex3i(_x + _w, _y+thickness, _z);\n\t\t}\n\t\tglEnd();\n\t\tglBegin(GL_TRIANGLES);\n\t\t{\n\t\t\tglVertex3i(_x + _w, _y,  _z);\n\t\t\tglVertex3i(_x + _w - nose, _y,  _z);\n\t\t\tglVertex3i(_x + _w, _y + nose,  _z);\n\t\t}\n\t\tglEnd();\n\t\tbreak;\n\t}\n}\n", "name": "libs/PhGraphic/PhGraphicArrow.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef PHGRAPHICARROW_H\n#define PHGRAPHICARROW_H\n\n#include \"PhGraphicRect.h\"\n\n/**\n * @brief A graphic diagonal arrow\n */\nclass PhGraphicArrow : public PhGraphicRect\n{\npublic:\n\t/**\n\t * @brief The PhGraphicArrowDirection enum\n\t *\n\t * This graphic arrow can point\n\t * - from the down/left corner to the upper/right corner\n\t * - from the upper/left corner to the down/right corner\n\t */\n\tenum PhGraphicArrowDirection {\n\t\tDownLeftToUpRight,\n\t\tUpLefToDownRight,\n\t};\n\n\t/**\n\t * @brief PhGraphicArrow constructor\n\t * @param direction The direction\n\t * @param x The x coordinate\n\t * @param y The y coordinate\n\t * @param w The width\n\t * @param h The height\n\t */\n\tPhGraphicArrow(PhGraphicArrowDirection direction = DownLeftToUpRight, int x = 0, int y = 0, int w = 0, int h = 0);\n\n\t/**\n\t * @brief Set the direction\n\t * @param direction The direction\n\t */\n\tvoid setDirection(PhGraphicArrowDirection direction);\n\n\t/**\n\t * @brief Get the direction\n\t * @return The direction\n\t */\n\tint direction() {\n\t\treturn _direction;\n\t}\n\n\t/**\n\t * @brief Draw the arrow\n\t */\n\tvoid draw();\n\nprivate:\n\tPhGraphicArrowDirection _direction;\n};\n\n#endif // PHGRAPHICARROW_H\n", "name": "libs/PhGraphic/PhGraphicArrow.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include \"PhGraphicDashedLine.h\"\n\nPhGraphicDashedLine::PhGraphicDashedLine(int dashCount, int x, int y, int w, int h) :\n\tPhGraphicRect(x, y, w, h),\n\t_dashCount(dashCount)\n{\n\tif(_dashCount <= 0)\n\t\t_dashCount = 1;\n}\n\nvoid PhGraphicDashedLine::setDashCount(int dashCount)\n{\n\t_dashCount = dashCount;\n}\n\nvoid PhGraphicDashedLine::draw()\n{\n\tglColor3f(_color.redF(), _color.greenF(), _color.blueF());\n\n\tint width = _w / (2 * _dashCount - 1);\n\tint x = _x;\n\tfor(int i = 0; i < _dashCount; i++) {\n\t\tglBegin(GL_QUADS);\n\t\t{\n\t\t\tglVertex3i(x,      _y, _z);\n\t\t\tglVertex3i(x + width, _y, _z);\n\t\t\tglVertex3i(x + width, _y + _h,  _z);\n\t\t\tglVertex3i(x,      _y + _h,  _z);\n\t\t}\n\t\tx += 2 * width;\n\t}\n\tglEnd();\n}\n", "name": "libs/PhGraphic/PhGraphicDashedLine.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef PHGRAPHICDASHEDLINE_H\n#define PHGRAPHICDASHEDLINE_H\n\n#include \"PhGraphicRect.h\"\n\n/**\n * @brief A graphic horizontal dashed line\n *\n * This graphic line contains a serie of rectangle filled by an solid color and specified by\n * a color, position and size (inherited from PhGraphicRect)\n */\nclass PhGraphicDashedLine : public PhGraphicRect\n{\npublic:\n\t/**\n\t * @brief PhGraphicDashedLine constructor\n\t * @param dashCount The number of dash\n\t * @param x The x coordinate\n\t * @param y The y coordinate\n\t * @param w The width\n\t * @param h The height\n\t */\n\tPhGraphicDashedLine(int dashCount = 1, int x = 0, int y = 0, int w = 0, int h = 0);\n\n\t/**\n\t * @brief Set the number of dash\n\t * @param dashCount The number of dash\n\t */\n\tvoid setDashCount(int dashCount);\n\n\t/**\n\t * @brief Get the number of dash\n\t * @return The number of dash\n\t */\n\tint dashCount() {\n\t\treturn _dashCount;\n\t}\n\n\t/**\n\t * @brief Draw a dashed line\n\t */\n\tvoid draw();\n\nprivate:\n\tint _dashCount;\n};\n\n#endif // PHGRAPHICDASHEDLINE_H\n", "name": "libs/PhGraphic/PhGraphicDashedLine.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include <QtMath>\n\n#include \"PhGraphicDisc.h\"\n\nPhGraphicDisc::PhGraphicDisc(int x, int y, int radius, int resolution)\n\t: PhGraphicObject(x, y),\n\t_radius(radius),\n\t_resolution(resolution)\n{\n\n}\n\nvoid PhGraphicDisc::draw()\n{\n\tglBegin(GL_TRIANGLE_FAN);\n\t{\n\t\tglVertex3f( _x, _y, _z);\n\t\tfor( int i = 0; i <= _resolution; i++ ) {\n\t\t\tfloat angle = i * 2 * M_PI / _resolution;\n\t\t\tglVertex3f( _x + sin( angle ) * _radius, _y + cos( angle ) * _radius, _z);\n\t\t}\n\t}\n\tglEnd();\n}\n", "name": "libs/PhGraphic/PhGraphicDisc.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef PHGRAPHICDISC_H\n#define PHGRAPHICDISC_H\n\n#include \"PhGraphicObject.h\"\n\n/**\n * @brief A graphic disc\n *\n * A PhGraphicDisc is described by :\n * - its position (x, y, z)\n * - its radius\n * - its resolution\n */\nclass PhGraphicDisc : public PhGraphicObject\n{\npublic:\n\t/**\n\t * @brief PhGraphicDisc\n\t * @param x\n\t * @param y\n\t * @param radius\n\t * @param resolution\n\t */\n\tPhGraphicDisc(int x = 0, int y = 0, int radius = 0, int resolution = 36);\n\n\t/**\n\t * @brief Get the radius\n\t * @return the radius size in pixel\n\t */\n\tint radius() {\n\t\treturn _radius;\n\t}\n\t/**\n\t * @brief Set the radius size in pixel\n\t * @param radius\n\t */\n\tvoid setRadius(int radius) {\n\t\t_radius = radius;\n\t}\n\t/**\n\t * @brief resolution\n\t * @return\n\t */\n\tint resolution() {\n\t\treturn _resolution;\n\t}\n\t/**\n\t * @brief setResolution\n\t * @param resolution\n\t */\n\tvoid setResolution(int resolution) {\n\t\t_resolution = resolution;\n\t}\n\n\tvoid draw();\n\nprivate:\n\tint _radius;\n\tint _resolution;\n\n};\n\n#endif // PHGRAPHICDISC_H\n", "name": "libs/PhGraphic/PhGraphicDisc.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#include <QtGlobal>\n#include <QSize>\n#include <QFileInfo>\n\n#if defined(Q_OS_MAC)\n#include <SDL2_image/SDL_image.h>\n#else\n#include <SDL2/SDL_image.h>\n#endif\n\n#include \"PhTools/PhDebug.h\"\n#include \"PhGraphicImage.h\"\n\nPhGraphicImage::PhGraphicImage(QString filename, int x, int y, int w, int h)\n\t: PhGraphicTexturedRect(x, y, w, h), _filename(filename), _surface(NULL)\n{\n}\n\nbool PhGraphicImage::init()\n{\n\tQFileInfo info(_filename);\n\tPHDEBUG << info.fileName();\n\t_surface = IMG_Load(_filename.toStdString().c_str());\n\tif(_surface != NULL) {\n\t\tif(createTextureFromSurface(_surface)) {\n\t\t\t_originalSize.setHeight(_surface->h);\n\t\t\t_originalSize.setWidth(_surface->w);\n\t\t\tPHDEBUG << \"Loading image\";\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tPHDEBUG<<\"Error loading:\"<< _filename;\n\treturn false;\n\n}\n\nvoid PhGraphicImage::dispose()\n{\n\tSDL_FreeSurface(_surface);\n}\nQSize PhGraphicImage::originalSize() const\n{\n\treturn _originalSize;\n}\n\nvoid PhGraphicImage::draw()\n{\n\tglColor3f(1, 1, 1);\n\tPhGraphicTexturedRect::draw();\n}\n\nvoid PhGraphicImage::setFilename(QString filename) {\n\t_filename = filename;\n}\n\nQString PhGraphicImage::getFilename() {\n\treturn _filename;\n}\n", "name": "libs/PhGraphic/PhGraphicImage.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef PHGRAPHICIMAGE_H\n#define PHGRAPHICIMAGE_H\n\n#include \"PhGraphicTexturedRect.h\"\n\n/**\n * @brief Provide a way to display the images using OpenGL\n */\nclass PhGraphicImage : public PhGraphicTexturedRect\n{\npublic:\n\n\t/**\n\t * @brief PhGraphicImage constructor\n\t * @param filename the source image url\n\t * @param x Upper left corner coordinates of the display rect\n\t * @param y Upper left corner coordinates of the display rect\n\t * @param w Desired width\n\t * @param h Desired height\n\t */\n\tPhGraphicImage( QString filename = \"\", int x = 0, int y = 0, int w = 0, int h = 0);\n\n\t/**\n\t * @brief Set the file name\n\t * @param filename\n\t */\n\tvoid setFilename(QString filename);\n\t/**\n\t * @brief Get the file name\n\t * @return the file name\n\t */\n\tQString getFilename();\n\n\t/**\n\t * @brief draw\n\t * draw the PhGraphicImage using PhGraphicTexturedRect::draw()\n\t */\n\tvoid draw();\n\n\t/**\n\t * @brief init\n\t * Currently unused\n\t */\n\tbool init();\n\t/**\n\t * @brief dispose\n\t * Currently unused\n\t */\n\tvoid dispose();\n\n\t/**\n\t * @brief originalSize\n\t * @return the original image size\n\t */\n\tQSize originalSize() const;\n\nprivate:\n\n\tQString _filename;\n\n\tSDL_Surface * _surface;\n\tQSize _originalSize;\n};\n\n#endif // PHGRAPHICIMAGE_H\n", "name": "libs/PhGraphic/PhGraphicImage.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#include \"math.h\"\n#include \"PhGraphicLoop.h\"\n\nPhGraphicLoop::PhGraphicLoop(int x, int y, int w, int h, int crossHeight, int hThick, bool horizontal) :\n\tPhGraphicRect(x, y, w, h),\n\t_crossHeight(crossHeight),\n\t_hThick(hThick),\n\t_horizontal(horizontal)\n{\n}\nPhGraphicLoop::~PhGraphicLoop()\n{\n}\n\nvoid PhGraphicLoop::draw()\n{\n\t//draw rect\n\tint x = _x - _hThick / 2;\n\tint y = _y;\n\tint w = _hThick;\n\tint h = _h;\n\n\tglColor3f(_color.redF(), _color.greenF(), _color.blueF());\n\n\tif(_horizontal) {\n\t\tw = _w;\n\t\th = _hThick;\n\t}\n\n\tglBegin(GL_QUADS);  // draw the vertical line\n\t{\n\t\tglVertex3f(x,       y,  _z);\n\t\tglVertex3f(x + w,   y,  _z);\n\t\tglVertex3f(x + w,   y + h,  _z);\n\t\tglVertex3f(x,       y + h,  _z);\n\t}\n\n\n\t//draw cross\n\n\n\n\tif(_horizontal) {\n\t\tx = _x + _w / 2 - _crossHeight / 2;\n\t\ty = _y - _crossHeight / 2;\n\t\tw = _hThick;\n\t\th = _crossHeight;\n\t\t_w = _crossHeight;\n\n\t}\n\telse {\n\t\tx = _x - _w/2;\n\t\ty = _y + _h/2 - _crossHeight / 2;\n\t\tw = _hThick;\n\t\th = _crossHeight;\n\n\t}\n\tglBegin(GL_QUADS);  // draw the fist cross segment\n\t{\n\t\tglVertex3f(x,           y,      _z);\n\t\tglVertex3f(x + w,       y,      _z);\n\t\tglVertex3f(x + _w,      y + h,  _z);\n\t\tglVertex3f(x + _w - w,  y + h,  _z);\n\t}\n\n\tglEnd();\n\n\n\n\tif(_horizontal) {\n\t\ty = _y + _crossHeight / 2;\n\n\t}\n\telse {\n\t\ty = _y + _h/2 + _crossHeight/2;\n\t}\n\tglBegin(GL_QUADS);  // draw the second cross segment\n\t{\n\t\tglVertex3f(x,       y,  _z);\n\t\tglVertex3f(x + w,   y,  _z);\n\t\tglVertex3f(x + _w,  y - h,  _z);\n\t\tglVertex3f(x + _w -w,       y - h,  _z);\n\t}\n\n\tglEnd();\n\n\n\n}\n\nvoid PhGraphicLoop::setHThick(int hThick)\n{\n\t_hThick = hThick;\n}\n\nvoid PhGraphicLoop::setCrossHeight(int crossHeight)\n{\n\t_crossHeight = crossHeight;\n}\n\n", "name": "libs/PhGraphic/PhGraphicLoop.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef PHGRAPHICLOOP_H\n#define PHGRAPHICLOOP_H\n\n#include \"PhGraphicRect.h\"\n\n/**\n * @brief Draw the loop symbol (a cross)\n */\nclass PhGraphicLoop : public PhGraphicRect\n{\npublic:\n\n\t/**\n\t * @brief PhGraphicLoop constructor\n\t * @param x Upper left corner coordinate\n\t * @param y Upper left corner coordinate\n\t * @param w Desired width\n\t * @param h Desired height\n\t * @param crossHeight the height of the cross\n\t * @param hThick the cross thickness\n\t * @param horizontal if the graphicloop is horizontal or not\n\t */\n\tPhGraphicLoop(int x = 0, int y = 0, int w = 0, int h = 0, int crossHeight = 0, int hThick = 0, bool horizontal = false);\n\t~PhGraphicLoop();\n\n\t/**\n\t * @brief draw the PhGraphicLoop\n\t */\n\tvoid draw();\n\n\t/**\n\t * @brief Set the thickness\n\t * @param hThick desired thickness\n\t */\n\tvoid setHThick(int hThick);\n\t/**\n\t * @brief Get the thickness\n\t * @return\n\t */\n\tint getHThick() {\n\t\treturn _hThick;\n\t}\n\n\t/**\n\t * @brief Set the cross height\n\t * @param crossHeight\n\t */\n\tvoid setCrossHeight(int crossHeight);\n\n\t/**\n\t * @brief Set horizontal loop\n\t *\n\t * Set if the graphic loop is displayed horizontaly or not\n\t * @param isHorizontal\n\t */\n\tvoid setHorizontalLoop(bool isHorizontal) {\n\t\t_horizontal = isHorizontal;\n\t}\n\t/**\n\t * @brief Get the cross height\n\t * @return cross height in pixels\n\t */\n\tint getCrossHeight() {\n\t\treturn _crossHeight;\n\t}\nprivate:\n\tint _crossHeight;\n\tint _hThick;\n\tbool _horizontal;\n};\n#endif // PHGRAPHICLOOP_H\n", "name": "libs/PhGraphic/PhGraphicLoop.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#include \"PhGraphicObject.h\"\n\nPhGraphicObject::PhGraphicObject(int x, int y) : _x(x), _y(y), _z(0), _color(Qt::white)\n{\n}\n\nPhGraphicObject::~PhGraphicObject()\n{\n}\n\nvoid PhGraphicObject::dispose()\n{\n}\n\nbool PhGraphicObject::init()\n{\n\treturn true;\n}\n\nvoid PhGraphicObject::setPosition(int x, int y, int z)\n{\n\tthis->setX(x);\n\tthis->setY(y);\n\tthis->setZ(z);\n}\n\n\nvoid PhGraphicObject::setX(int x) {\n\t_x = x;\n}\n\nvoid PhGraphicObject::setY(int y) {\n\t_y = y;\n}\n\nvoid PhGraphicObject::setZ(int z)\n{\n\t_z = z;\n}\n\n\nint PhGraphicObject::getX() {\n\treturn _x;\n}\n\nint PhGraphicObject::getY() {\n\treturn _y;\n}\n\nint PhGraphicObject::getZ()\n{\n\treturn _z;\n}\n\n\nQColor PhGraphicObject::getColor() {\n\treturn _color;\n}\n\nvoid PhGraphicObject::setColor(QColor color) {\n\t_color = color;\n}\n\n", "name": "libs/PhGraphic/PhGraphicObject.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef PHGRAPHICOBJECT_H\n#define PHGRAPHICOBJECT_H\n\n#include <QColor>\n#include <SDL2/SDL.h>\n\n#if defined(Q_OS_WIN)\n#include <GL/glu.h>\n#else\n#include <glu.h>\n#endif\n\n#include \"PhTools/PhDebug.h\"\n\n/**\n * @brief A generic graphic object\n *\n * A PhGraphicObject is described by :\n * - its position (x, y, z)\n * - its color\n * Concrete PhGraphicObject must implement the draw() method.\n */\nclass PhGraphicObject\n{\npublic:\n\n\t/**\n\t * @brief PhGraphicObject constructor\n\t * @param x Upper left corner coordinates of the display object\n\t * @param y Upper left corner coordinates of the displayed object\n\t */\n\tPhGraphicObject(int x = 0, int y = 0);\n\tvirtual ~PhGraphicObject();\n\n\t/**\n\t * @brief init\n\t */\n\tvirtual bool init();\n\t/**\n\t * @brief dispose\n\t */\n\tvirtual void dispose();\n\n\t/**\n\t * @brief draw\n\t * virtual method called to draw objects\n\t */\n\tvirtual void draw() = 0;\n\n\t/**\n\t * @brief setPosition\n\t * @param x\n\t * @param y\n\t * @param z\n\t * set the position of the PhGraphicObject using setX() setY() setZ()\n\t */\n\tvoid setPosition(int x, int y, int z);\n\t/**\n\t * @brief setX\n\t * @param x\n\t */\n\tvoid setX(int x);\n\t/**\n\t * @brief getX\n\t * @return\n\t */\n\tint getX();\n\n\t/**\n\t * @brief setY\n\t * @param y\n\t */\n\tvoid setY(int y);\n\t/**\n\t * @brief getY\n\t * @return\n\t */\n\tint getY();\n\n\t/**\n\t * @brief setZ\n\t * @param z\n\t */\n\tvoid setZ(int z);\n\n\t/**\n\t * @brief getZ\n\t * @return\n\t */\n\tint getZ();\n\n\t/**\n\t * @brief Set the color of the object\n\t * @param color the desired color\n\t */\n\tvoid setColor(QColor color);\n\n\t/**\n\t * @brief Get the color of the object\n\t * @return the color\n\t */\n\tQColor getColor();\n\nprotected:\n\n\t/**\n\t * @brief _x\n\t * is the PhGraphicObject horizontal position\n\t */\n\tint _x;\n\t/**\n\t * @brief _y\n\t * is the PhGraphicObject vertical position\n\t */\n\tint _y;\n\t/**\n\t * @brief _z\n\t * is the PhGrapicObject depth\n\t */\n\tint _z;\n\n\t/**\n\t * @brief _color\n\t * The PhColor of the PhGraphicObject\n\t */\n\tQColor _color;\n};\n\n#endif // PHGRAPHICOBJECT_H\n", "name": "libs/PhGraphic/PhGraphicObject.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license: http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#include \"PhGraphicRect.h\"\n\nPhGraphicRect::PhGraphicRect(int x, int y, int w, int h)\n\t: PhGraphicObject(x, y), _w(w), _h(h)\n{\n}\n\nPhGraphicRect::~PhGraphicRect()\n{\n}\n\nvoid PhGraphicRect::setSize(QSize size)\n{\n\tthis->setWidth(size.width());\n\tthis->setHeight(size.height());\n}\n\nvoid PhGraphicRect::setSize(int w, int h)\n{\n\tthis->setWidth(w);\n\tthis->setHeight(h);\n}\n\nvoid PhGraphicRect::setRect(int x, int y, int w, int h)\n{\n\tthis->setSize(w, h);\n\tthis->setPosition(x, y, this->getZ());\n}\n\nvoid PhGraphicRect::setHeight(int h)\n{\n\t_h = h;\n}\n\nvoid PhGraphicRect::setWidth(int w)\n{\n\t_w = w;\n}\n\nint PhGraphicRect::getHeight()\n{\n\treturn _h;\n}\nint PhGraphicRect::getWidth()\n{\n\treturn _w;\n}\n", "name": "libs/PhGraphic/PhGraphicRect.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef PHGRAPHICSQUARE_H\n#define PHGRAPHICSQUARE_H\n\n#include <QSize>\n\n#include \"PhGraphicObject.h\"\n\n/**\n * @brief A generic rectangle object\n *\n * A PhGraphicRect is a PhGraphicObject with a size (height and width).\n */\nclass PhGraphicRect : public PhGraphicObject\n{\npublic:\n\n\t/**\n\t * @brief PhGraphicRect constructor\n\t * @param x The x coordinate\n\t * @param y The y coordinate\n\t * @param w The width\n\t * @param h The height\n\t */\n\tPhGraphicRect(int x = 0, int y = 0, int w = 0, int h = 0);\n\t~PhGraphicRect();\n\n\t/**\n\t * @brief Set the rectangle size\n\t * @param size The size\n\t */\n\tvoid setSize(QSize size);\n\n\t/**\n\t * @brief Set the rectangle size\n\t * @param w The width\n\t * @param h The height\n\t */\n\tvoid setSize(int w, int h);\n\n\t/**\n\t * @brief Set the rectangle position and size\n\t * @param x The x coordinate\n\t * @param y The y coordinate\n\t * @param w The width\n\t * @param h The height\n\t */\n\tvoid setRect(int x, int y, int w, int h);\n\t/**\n\t * @brief Set the rectangle height\n\t * @param h The height\n\t */\n\tvoid setHeight(int h);\n\t/**\n\t * @brief Set the rectangle width\n\t * @param w The width\n\t */\n\tvoid setWidth(int w);\n\n\t/**\n\t * @brief Get the rectangle height\n\t * @return The height\n\t */\n\tint getHeight();\n\t/**\n\t * @brief Get the rectangle width\n\t * @return The width\n\t */\n\tint getWidth();\n\n\nprotected:\n\t/** @brief The rectangle width */\n\tint _w;\n\t/** @brief The rectangle height */\n\tint _h;\n};\n\n#endif // PHGRAPHICSQUARE_H\n", "name": "libs/PhGraphic/PhGraphicRect.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef PHGRAPHICSETTINGS_H\n#define PHGRAPHICSETTINGS_H\n\n#include <QApplication>\n#include <QString>\n\n/**\n * @brief The settings for PhGraphic\n */\nclass PhGraphicSettings\n{\npublic:\n\t/**\n\t * @brief Display an overlay with some debug information\n\t * @return True if displayed\n\t */\n\tvirtual bool displayInfo() = 0;\n\n\t/**\n\t * @brief Reset the info like maximum value used in display info\n\t * @return True if need to be reset\n\t */\n\tvirtual bool resetInfo() = 0;\n\n\t/**\n\t * @brief The font used for displaying the information\n\t * @return A font file path\n\t */\n\tvirtual QString infoFontFile()\n\t{\n\t\treturn QApplication::applicationDirPath() + PATH_TO_RESSOURCES + \"/Arial.ttf\";\n\t}\n};\n\n#endif // PHGRAPHICSETTINGS\n", "name": "libs/PhGraphic/PhGraphicSettings.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#include \"PhGraphicSolidRect.h\"\n\nPhGraphicSolidRect::PhGraphicSolidRect(int x, int y, int w, int h) :\n\tPhGraphicRect(x, y, w, h)\n{\n}\n\nPhGraphicSolidRect::~PhGraphicSolidRect()\n{\n}\n\n\nvoid PhGraphicSolidRect::draw()\n{\n//\t\t/*\n//\t\t(0,0) ------ (1,0)\n//\t\t  |            |\n//\t\t  |            |\n//\t\t(0,1) ------ (1,1)\n//\t\t*/\n\n\tglColor3f(_color.redF(), _color.greenF(), _color.blueF());\n\n\tglBegin(GL_QUADS);  //Begining the cube's drawing\n\t{\n\t\tglVertex3i(_x,      _y, _z);\n\t\tglVertex3i(_x + _w, _y, _z);\n\t\tglVertex3i(_x + _w, _y + _h,  _z);\n\t\tglVertex3i(_x,      _y + _h,  _z);\n\t}\n\tglEnd();\n}\n", "name": "libs/PhGraphic/PhGraphicSolidRect.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef PHGRAPHICSOLIDSQUARE_H\n#define PHGRAPHICSOLIDSQUARE_H\n\n#include \"PhGraphicRect.h\"\n\n/**\n * @brief A graphic rect object\n *\n * This graphic rectangle is filled by an solid color and specified by\n * a color, position and size (inherited from PhGraphicRect)\n */\nclass PhGraphicSolidRect : public PhGraphicRect\n{\npublic:\n\t/**\n\t * @brief PhGraphicSolidRect constructor\n\t * @param x The x coordinate\n\t * @param y The y coordinate\n\t * @param w The width\n\t * @param h The height\n\t */\n\tPhGraphicSolidRect(int x = 0, int y = 0, int w = 0, int h = 0);\n\t~PhGraphicSolidRect();\n\n\t/**\n\t * @brief Draw a solid graphic rectangle\n\t */\n\tvoid draw();\n\n};\n\n#endif // PHGRAPHICSOLIDSQUARE_H\n", "name": "libs/PhGraphic/PhGraphicSolidRect.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#include \"PhGraphicText.h\"\n\nPhGraphicText::PhGraphicText(PhFont* font, QString content, int x, int y, int w, int h)\n\t: PhGraphicRect(x, y, w, h), _font(font), _content(content)\n{\n}\n\nPhGraphicText::~PhGraphicText()\n{\n\n}\n\n\nvoid PhGraphicText::setContent(QString content)\n{\n\t_content = content;\n}\nvoid PhGraphicText::setFont(PhFont * font)\n{\n\t_font = font;\n}\n\nQString PhGraphicText::getContent()\n{\n\treturn _content;\n}\nPhFont * PhGraphicText::getFont()\n{\n\treturn _font;\n}\n\nvoid PhGraphicText::draw()\n{\n\tglMatrixMode(GL_MODELVIEW);\n\tglLoadIdentity();\n\n\tglColor3f(_color.redF(), _color.greenF(), _color.blueF());\n\n\t_font->select();\n\n\tglEnable(GL_TEXTURE_2D);\n\n\tglEnable(GL_BLEND);\n\n\tglBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);\n\n\tint totalAdvance = 0;\n\t//Compute the natural width of the content to scale it later\n\tfor(int i = 0; i < _content.length(); i++) {\n\t\ttotalAdvance += _font->getAdvance(_content.at(i).toLatin1());\n\t}\n\n\t// Set the letter initial horizontal offset\n\tint advance = 0;\n\tfloat space = 0.0625f; // all glyph are in a 1/16 x 1/16 box\n\t// Display a string\n\tfor(int i = 0; i < _content.length(); i++) {\n\t\tunsigned char ch = (unsigned char)_content.at(i).toLatin1();\n\t\tif(_font->getAdvance(ch) > 0) {\n\t\t\t// computing texture coordinates\n\t\t\tfloat tu1 = (ch % 16) * space;\n\t\t\tfloat tv1 = (ch / 16) * space;\n\t\t\tfloat tu2 = tu1 + space;\n\t\t\tfloat tv2 = tv1 + space;\n\n\t\t\t// computing quads coordinate;\n\t\t\tint h = _h * 128 / _font->getHeight();\n\t\t\tint w = _w * 128 / totalAdvance;\n\n\t\t\t//        (tu1, tv1) --- (tu2, tv1)\n\t\t\t//            |              |\n\t\t\t//            |              |\n\t\t\t//        (tu1, tv2) --- (tu2, tv2)\n\n\t\t\tint offset = _x + advance * _w / totalAdvance;\n\t\t\tglBegin(GL_QUADS);  //Begining the cube's drawing\n\t\t\t{\n\t\t\t\tglTexCoord3f(tu1, tv1, 1);  glVertex3f(offset,      _y, _z);\n\t\t\t\tglTexCoord3f(tu2, tv1, 1);  glVertex3f(offset + w,  _y, _z);\n\t\t\t\tglTexCoord3f(tu2, tv2, 1);  glVertex3f(offset + w,  _y + h,  _z);\n\t\t\t\tglTexCoord3f(tu1, tv2, 1);  glVertex3f(offset,      _y + h,  _z);\n\t\t\t}\n\t\t\tglEnd();\n\n\t\t}\n\t\t// Inc the advance\n\t\tadvance += _font->getAdvance(ch);\n\t}\n\n\tglDisable(GL_BLEND);\n\n\tglDisable(GL_TEXTURE_2D);\n}\n\n", "name": "libs/PhGraphic/PhGraphicText.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef PHGRAPHICTEXT_H\n#define PHGRAPHICTEXT_H\n\n#include \"PhGraphicRect.h\"\n#include \"PhFont.h\"\n\n/**\n * @brief A graphic text object\n *\n * This graphic text object is specified with:\n * - a content\n * - a color, position and size (inherited from PhGraphicRect)\n * - a PhFont\n */\nclass PhGraphicText : public PhGraphicRect {\npublic:\n\t/**\n\t * @brief PhGraphicText constructor\n\t * @param font The font\n\t * @param content The content\n\t * @param x The x coordinate\n\t * @param y The y coordinate\n\t * @param w The width\n\t * @param h The height\n\t */\n\tPhGraphicText(PhFont* font, QString content = \"\", int x = 0, int y = 0, int w = 0, int h = 0);\n\t~PhGraphicText();\n\t/**\n\t * @brief Draw the text on screen\n\t *\n\t */\n\tvoid draw();\n\n\t/**\n\t * @brief setContent\n\t * @param content\n\t * Set the PhGraphicText content\n\t */\n\tvoid setContent(QString content);\n\t/**\n\t * @brief setFont\n\t * @param font\n\t * Set the PhGraphicText font\n\t */\n\tvoid setFont(PhFont * font);\n\n\t/**\n\t * @brief getContent\n\t * @return _content\n\t */\n\tQString getContent();\n\t/**\n\t * @brief getFont\n\t * @return _font\n\t */\n\tPhFont * getFont();\n\n\n\nprivate:\n\t/**\n\t * @brief _font\n\t */\n\tPhFont *_font;\n\n\t/**\n\t * @brief _content\n\t */\n\tQString _content;\n};\n\n#endif // PHGRAPHICTEXT_H\n", "name": "libs/PhGraphic/PhGraphicText.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#include \"PhTools/PhDebug.h\"\n#include \"PhGraphicTexturedRect.h\"\n\nPhGraphicTexturedRect::PhGraphicTexturedRect(int x, int y, int w, int h)\n\t: PhGraphicRect(x, y, w, h),\n\t_texture(0),\n\t_tu(1.0f),\n\t_tv(1.0f),\n\t_textureWidth(0),\n\t_textureHeight(0)\n{\n\n}\n\nPhGraphicTexturedRect::~PhGraphicTexturedRect()\n{\n}\n\n\nbool PhGraphicTexturedRect::createTextureFromSurface(SDL_Surface *surface)\n{\n\tGLenum textureFormat = 0;\n\n\tswitch (surface->format->BytesPerPixel) {\n\tcase 1:\n\t\ttextureFormat = GL_ALPHA;\n\t\tbreak;\n\tcase 3: // no alpha channel\n#if defined(Q_OS_MAC)\n\t\tif (surface->format->Rmask == 0x000000ff)\n\t\t\ttextureFormat = GL_RGB;\n\t\telse\n\t\t\ttextureFormat = GL_BGR;\n#else\n\t\ttextureFormat = GL_RGB;\n#endif\n\t\tbreak;\n\tcase 4: // contains an alpha channel\n#if defined(Q_OS_MAC)\n\t\tif (surface->format->Rmask == 0x000000ff)\n\t\t\ttextureFormat = GL_RGBA;\n\t\telse\n\t\t\ttextureFormat = GL_BGRA;\n#else\n\t\ttextureFormat = GL_RGBA;\n#endif\n\n\t\tbreak;\n\tdefault:\n\t\tPHDEBUG << \"Warning: the image is not truecolor...\";\n\t\treturn false;\n\t}\n\n\tglEnable( GL_TEXTURE_2D );\n\t// Have OpenGL generate a texture object handle for us\n\tglGenTextures( 1, &_texture );\n\n\t// Bind the texture object\n\tglBindTexture( GL_TEXTURE_2D, _texture );\n\n\n\t// Edit the texture object's image data using the information SDL_Surface gives us\n\tglTexImage2D( GL_TEXTURE_2D, 0, surface->format->BytesPerPixel, surface->w, surface->h, 0,\n\t              textureFormat, GL_UNSIGNED_BYTE, surface->pixels);\n\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n\n\treturn true;\n}\n\nbool PhGraphicTexturedRect::createTextureFromARGBBuffer(void *data, int width, int height)\n{\n\tglEnable( GL_TEXTURE_2D );\n\n\tif((width != _textureWidth) || (height != _textureHeight)) {\n\t\tif(_texture != 0)\n\t\t\tglDeleteTextures(1, &_texture);\n\t\t_textureWidth = width;\n\t\t_textureHeight = height;\n\t}\n\n\t// Have OpenGL generate a texture object handle for us\n\tif(_texture == 0)\n\t\tglGenTextures( 1, &_texture );\n\n\t// Bind the texture object\n\tglBindTexture( GL_TEXTURE_2D, _texture );\n\n\n\t// Edit the texture object's image data using the information SDL_Surface gives us\n\tglTexImage2D( GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0,\n\t              GL_RGBA, GL_UNSIGNED_BYTE, data);\n\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n\n\treturn true;\n}\n\nbool PhGraphicTexturedRect::createTextureFromRGBBuffer(void *data, int width, int height)\n{\n\tglEnable( GL_TEXTURE_2D );\n\n\tif((width != _textureWidth) || (height != _textureHeight)) {\n\t\tif(_texture != 0)\n\t\t\tglDeleteTextures(1, &_texture);\n\t\t_textureWidth = width;\n\t\t_textureHeight = height;\n\t}\n\n\t// Have OpenGL generate a texture object handle for us\n\tif(_texture == 0)\n\t\tglGenTextures( 1, &_texture );\n\n\t// Bind the texture object\n\tglBindTexture( GL_TEXTURE_2D, _texture );\n\n\n\t// Edit the texture object's image data using the information SDL_Surface gives us\n\tglTexImage2D( GL_TEXTURE_2D, 0, GL_RGB, width, height, 0,\n\t              GL_RGB, GL_UNSIGNED_BYTE, data);\n\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n\n\treturn true;\n}\n\n\nbool PhGraphicTexturedRect::createTextureFromYUVBuffer(void *data, int width, int height)\n{\n\tglEnable( GL_TEXTURE_2D );\n\t// Have OpenGL generate a texture object handle for us\n\tglGenTextures( 1, &_texture );\n\n\t// Bind the texture object\n\tglBindTexture( GL_TEXTURE_2D, _texture );\n\n\t// Edit the texture object's image data using the information SDL_Surface gives us\n#if defined(Q_OS_MAC)\n\tglTexImage2D( GL_TEXTURE_2D, 0, GL_RGBA8, width, height, 0,\n\t              GL_YCBCR_422_APPLE, GL_UNSIGNED_SHORT_8_8_APPLE, data);\n#else\n\tglTexImage2D( GL_TEXTURE_2D, 0, GL_RGBA8, width, height, 0,\n\t              0x85B9, 0x85BA, data);\n#endif\n\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n\n\treturn true;\n}\n\n\nvoid PhGraphicTexturedRect::draw() {\n\n\t//PHDEBUG << \"PhGraphicTexturedRect::draw()\";\n\n\tglColor3f(_color.redF(), _color.greenF(), _color.blueF());\n\n\tglMatrixMode(GL_MODELVIEW);\n\n\tglLoadIdentity();\n\n\tglBindTexture(GL_TEXTURE_2D, _texture);\n\n\tglEnable(GL_TEXTURE_2D);\n\n//        (0,0) ------ (1,0)\n//          |            |\n//          |            |\n//        (0,1) ------ (1,1)\n\n\tglBegin(GL_QUADS);  //Begining the cube's drawing\n\t{\n\t\tglTexCoord3f(0, 0, 1);      glVertex3f(_x,      _y, _z);\n\t\tglTexCoord3f(_tu, 0, 1);    glVertex3f(_x + _w, _y, _z);\n\t\tglTexCoord3f(_tu, _tv, 1);  glVertex3f(_x + _w, _y + _h,  _z);\n\t\tglTexCoord3f(0, _tv, 1);    glVertex3f(_x,      _y + _h,  _z);\n\t}\n\tglEnd();\n\n\n\tglDisable(GL_TEXTURE_2D);\n}\n\nvoid PhGraphicTexturedRect::setTextureCoordinate(float tu, float tv)\n{\n\t_tu = tu;\n\t_tv = tv;\n}\n\n", "name": "libs/PhGraphic/PhGraphicTexturedRect.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef PHGRAPHICTEXTUREDSQUARE_H\n#define PHGRAPHICTEXTUREDSQUARE_H\n\n#include \"PhGraphicRect.h\"\n\n/**\n * @brief Draw a tetragon filed with an OpenGL Texture\n */\nclass PhGraphicTexturedRect : public PhGraphicRect\n{\npublic:\n\t/**\n\t * @brief PhGraphicTexturedRect constructor\n\t * @param x Upper left corner coordinate\n\t * @param y Upper left corner coordinate\n\t * @param w Desired width\n\t * @param h Desired heigth\n\t */\n\tPhGraphicTexturedRect(int x = 0, int y = 0, int w = 0, int h = 0);\n\t~PhGraphicTexturedRect();\n\n\t/**\n\t * @brief draw\n\t * draw the textured rectangle\n\t */\n\tvoid draw();\n\n\t/**\n\t * @brief setTextureCoordinate\n\t * @param tu\n\t * @param tv\n\t */\n\tvoid setTextureCoordinate(float tu, float tv);\n\n\t/**\n\t * @brief Create a texture from a RGBA Buffer\n\t * @param data the source buffer\n\t * @param width the dimensions\n\t * @param height the dimensions\n\t * @return True if succeed, false otherwise\n\t */\n\tbool createTextureFromARGBBuffer(void *data, int width, int height);\n\n\t/**\n\t * @brief Create a texture from a RGB Buffer\n\t * @param data the source buffer\n\t * @param width the dimensions\n\t * @param height the dimensions\n\t * @return True if succeed, false otherwise\n\t */\n\tbool createTextureFromRGBBuffer(void *data, int width, int height);\n\n\t/**\n\t * @brief Create a texture from a YUV Buffer\n\t * @param data the source buffer\n\t * @param width the dimensions\n\t * @param height the dimensions\n\t * @return True if succeed, false otherwise\n\t */\n\tbool createTextureFromYUVBuffer(void *data, int width, int height);\nprotected:\n\n\t/**\n\t * @brief createTextureFromSurface\n\t * @param surface\n\t * create an OpenGL texture form a SDL Surface\n\t */\n\tbool createTextureFromSurface(SDL_Surface * surface);\n\nprivate:\n\n\t/**\n\t * @brief _texture\n\t * The texture address(?)\n\t */\n\tGLuint _texture;\n\n\t/**\n\t * @brief _tu\n\t * number of horizontal repetition\n\t */\n\tfloat _tu;\n\n\t/**\n\t * @brief _tv\n\t * number of vertical repetition\n\t */\n\tfloat _tv;\n\n\tint _textureWidth;\n\tint _textureHeight;\n};\n\n#endif // PHGRAPHICTEXTUREDSQUARE_H\n", "name": "libs/PhGraphic/PhGraphicTexturedRect.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#include <QtGlobal>\n#include <SDL2/SDL.h>\n#if defined(Q_OS_MAC)\n#include <SDL2_ttf/SDL_ttf.h>\n#else\n#include <SDL2/SDL_ttf.h>\n#endif\n#include <QtGui>\n#include \"PhGraphicText.h\"\n\n#include \"PhTools/PhDebug.h\"\n#include \"PhGraphicView.h\"\n\nPhGraphicView::PhGraphicView( QWidget *parent)\n\t: QGLWidget(parent),\n\t_initialized(false),\n\t_settings(NULL),\n\t_dropDetected(0),\n\t_maxRefreshRate(0),\n\t_maxPaintDuration(0),\n\t_lastUpdateDuration(0),\n\t_maxUpdateDuration(0)\n{\n\tif (SDL_Init(SDL_INIT_VIDEO) == 0)\n\t\tPHDEBUG << \"init SDL Ok.\";\n\telse\n\t\tPHDEBUG << \"SDL error:\" << SDL_GetError();\n\tif (TTF_Init() == 0)\n\t\tPHDEBUG << \"init TTF Ok.\";\n\telse\n\t\tPHDEBUG << \"TTF error:\" << TTF_GetError();\n\n\t_refreshTimer = new QTimer(this);\n\tconnect(_refreshTimer, SIGNAL(timeout()), this, SLOT(onRefresh()));\n\n\t//set the screen frequency to the most common value (60hz);\n\t_screenFrequency = 60;\n\tQScreen *screen = QGuiApplication::primaryScreen();\n\tif (screen)\n\t\t_screenFrequency = screen->refreshRate();\n\telse\n\t\tPHDEBUG << \"Unable to get the screen\";\n\n\tint timerInterval = 500 / _screenFrequency;\n\t_refreshTimer->start( timerInterval);\n\tPHDEBUG << \"Refresh rate set to \" << _screenFrequency << \"hz, timer restart every\" << timerInterval << \"ms\";\n\t_dropTimer.start();\n}\n\nPhGraphicView::~PhGraphicView()\n{\n\t_refreshTimer->stop();\n\tTTF_Quit();\n\tSDL_Quit();\n}\n\nvoid PhGraphicView::initializeGL()\n{\n\tPHDEBUG;\n\tif(_settings)\n\t\t_infoFont.setFontFile(_settings->infoFontFile());\n\tinit();\n\t_initialized = true;\n}\n\nvoid PhGraphicView::resizeGL(int width, int height)\n{\n\tint ratio = this->windowHandle()->devicePixelRatio();\n\tPHDEBUG << width << height << ratio;\n\n\tif(height == 0)\n\t\theight = 1;\n\tglViewport(0, 0, width / ratio, height / ratio);\n\tglMatrixMode(GL_PROJECTION);\n\tglLoadIdentity();\n\tglOrtho(0, width / ratio, height / ratio, 0, -10, 10);\n\tglMatrixMode(GL_MODELVIEW);\n\tglEnable(GL_DEPTH_TEST);\n\tglDepthFunc(GL_LEQUAL);\n\tglLoadIdentity();\n}\n\nvoid PhGraphicView::setGraphicSettings(PhGraphicSettings *settings)\n{\n\t_settings = settings;\n\tif(_initialized)\n\t\t_infoFont.setFontFile(_settings->infoFontFile());\n}\n\nvoid PhGraphicView::addInfo(QString info)\n{\n\t_infos.append(info);\n}\n\nbool PhGraphicView::init()\n{\n\treturn true;\n}\n\nvoid PhGraphicView::onRefresh()\n{\n\tif(this->refreshRate() > _maxRefreshRate)\n\t\t_maxRefreshRate = this->refreshRate();\n\taddInfo(QString(\"refresh: %1x%2, %3 / %4\")\n\t        .arg(this->width())\n\t        .arg(this->height())\n\t        .arg(_maxRefreshRate)\n\t        .arg(this->refreshRate()));\n\taddInfo(QString(\"Update : %1 %2\").arg(_maxUpdateDuration).arg(_lastUpdateDuration));\n\taddInfo(QString(\"drop: %1 %2\").arg(_dropDetected).arg(_dropTimer.elapsed() / 1000));\n\n\tQTime t;\n\tt.start();\n\tupdateGL();\n\t_lastUpdateDuration = t.elapsed();\n\tif(_lastUpdateDuration > _maxUpdateDuration)\n\t\t_maxUpdateDuration = _lastUpdateDuration;\n\tif(_lastUpdateDuration > 1500 / _screenFrequency) {\n\t\t_dropTimer.restart();\n\t\t_dropDetected++;\n\t}\n\n}\n\nvoid PhGraphicView::paintGL()\n{\n\t//PHDEBUG << \"PhGraphicView::paintGL\" ;\n\temit beforePaint(_screenFrequency);\n\n\tglClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\tglColor3f(1.0f, 1.0f, 1.0f);\n\n\tQTime timer;\n\ttimer.start();\n\n\tpaint();\n\n\tif(timer.elapsed() > _maxPaintDuration)\n\t\t_maxPaintDuration = timer.elapsed();\n\taddInfo(QString(\"draw: %1 %2\").arg(_maxPaintDuration).arg(timer.elapsed()));\n\tif(_settings) {\n\t\tif(_settings->resetInfo()) {\n\t\t\t_dropDetected = 0;\n\t\t\t_maxRefreshRate = 0;\n\t\t\t_maxPaintDuration = 0;\n\t\t\t_maxUpdateDuration = 0;\n\t\t}\n\t\tif(_settings->displayInfo()) {\n\t\t\tint y = 0;\n\t\t\tforeach(QString info, _infos) {\n\t\t\t\tPhGraphicText gInfo(&_infoFont, info, 0, y);\n\t\t\t\tgInfo.setSize(_infoFont.getNominalWidth(info) / 2, 50);\n\t\t\t\tgInfo.setZ(10);\n\t\t\t\tgInfo.setColor(Qt::red);\n\t\t\t\tgInfo.draw();\n\t\t\t\ty += gInfo.getHeight();\n\t\t\t}\n\t\t}\n\t}\n\t// Once the informations have been displayed\n\t// clear it\n\t_infos.clear();\n\n\t_frameTickCounter.tick();\n}\n", "name": "libs/PhGraphic/PhGraphicView.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef PHGRAPHICVIEW_H\n#define PHGRAPHICVIEW_H\n\n#include <QGLWidget>\n#include <QTimer>\n\n#include \"PhTools/PhTime.h\"\n#include \"PhTools/PhTickCounter.h\"\n\n#include \"PhGraphicSettings.h\"\n#include \"PhFont.h\"\n\n/**\n * @brief The PhGraphicView class is a canvas to create your custom graphic view.\n *\n * Create your PhGraphicView child, initialize your graphic object with init(),\n * paint them with paint(), and clear them with dispose().\n * These methods are called automatically after the view creation and during all\n * its lifetime.\n */\nclass PhGraphicView : public QGLWidget\n{\n\tQ_OBJECT\npublic:\n\t/**\n\t * PhGraphicView constructor.\n\t * @param parent Parent object.\n\t */\n\texplicit PhGraphicView(QWidget *parent = 0);\n\t~PhGraphicView();\n\n\t/**\n\t * Handle the resizing of the view.\n\t *\n\t * @param width\n\t * @param height\n\t */\n\tvoid resizeGL(int width, int height);\n\n\t/**\n\t * @brief Get the refresh rate of the view\n\t * @return The rate (in fps)\n\t */\n\tint refreshRate() {\n\t\treturn _frameTickCounter.frequency();\n\t}\n\n\t/**\n\t * @brief Pass the settings to the graphic view\n\t * @param settings The settings\n\t */\n\tvoid setGraphicSettings(PhGraphicSettings *settings);\n\t/**\n\t * @brief Add a line to the debug info\n\t * @param info A string\n\t */\n\tvoid addInfo(QString info);\n\nsignals:\n\t/**\n\t * @brief emit a signal just before the paint\n\t * @param frequency the effective frequency\n\t */\n\tvoid beforePaint(PhTimeScale frequency);\n\nprotected:\n\t/**\n\t * @brief Child-specific initialization.\n\t * @return true if everything went well, false otherwise.\n\t */\n\tvirtual bool init();\n\t/**\n\t * @brief paint event, every class have to re-implement it.\n\t * @return true if everything went well, false otherwise.\n\t */\n\tvirtual void paint() = 0;\n\n\t/**\n\t * @brief initializeGL\n\t * This virtual function is called once before the first call to paintGL() or resizeGL(),\n\t * and then once whenever the widget has been assigned a new QGLContext.\n\t * Reimplement it in a subclass.\n\t * This function should set up any required OpenGL context rendering flags,\n\t * defining display lists, etc.\n\t *\n\t * It calls init()\n\t */\n\tvoid initializeGL();\n\t/**\n\t * @brief paintGL\n\t * This virtual function is called whenever the widget needs to be painted.\n\t * Reimplement it in a subclass.\n\t */\n\tvoid paintGL();\n\n\t/**\n\t * @brief The screen frequency\n\t */\n\tint _screenFrequency;\n\nprivate slots:\n\tvoid onRefresh();\n\nprivate:\n\tbool _initialized;\n\tPhGraphicSettings *_settings;\n\t/**\n\t * @brief t_Timer\n\t * used to draw\n\t */\n\tQTimer *_refreshTimer;\n\tPhTickCounter _frameTickCounter;\n\tQStringList _infos;\n\tPhFont _infoFont;\n\tQTime _dropTimer;\n\tint _dropDetected, _maxRefreshRate, _maxPaintDuration, _lastUpdateDuration, _maxUpdateDuration;\n};\n\n#endif // PHGRAPHICVIEW\n", "name": "libs/PhGraphic/PhGraphicView.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#include <QFile>\n#include <QCoreApplication>\n#include <QDir>\n#include <QMessageBox>\n\n#include \"PhTools/PhDebug.h\"\n#include \"PhGraphic/PhGraphicDisc.h\"\n#include \"PhGraphic/PhGraphicDashedLine.h\"\n#include \"PhGraphic/PhGraphicArrow.h\"\n#include \"PhGraphicStrip.h\"\n\nPhGraphicStrip::PhGraphicStrip(QObject *parent) :\n\tQObject(parent),\n\t_doc(this),\n\t_clock(_doc.timeCodeType()),\n\t_trackNumber(4),\n\t_settings(NULL),\n\t_maxDrawElapsed(0)\n{\n\t// update the  content when the doc changes :\n\tthis->connect(&_doc, SIGNAL(changed()), this, SLOT(onDocChanged()));\n}\n\nPhStripDoc *PhGraphicStrip::doc()\n{\n\treturn &_doc;\n}\n\nPhClock *PhGraphicStrip::clock()\n{\n\treturn &_clock;\n}\n\nvoid PhGraphicStrip::setSettings(PhGraphicStripSettings *settings)\n{\n\tPHDEBUG;\n\t_settings = settings;\n}\n\nbool PhGraphicStrip::setFontFile(QString fontFile)\n{\n\tif(_textFont.setFontFile(fontFile)) {\n\t\tif(_settings)\n\t\t\t_settings->setTextFontFile(fontFile);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool PhGraphicStrip::init()\n{\n\tPHDEBUG << _settings;\n\n\tPHDEBUG << \"Load the strip background\";\n\t_stripBackgroundImage.setFilename(QCoreApplication::applicationDirPath() + PATH_TO_RESSOURCES + \"/motif-240.png\");\n\t_stripBackgroundImage.init();\n\n\t_stripBackgroundImageInverted.setFilename(QCoreApplication::applicationDirPath() + PATH_TO_RESSOURCES + \"/motif-240_black.png\");\n\t_stripBackgroundImageInverted.init();\n\n\tPHDEBUG << \"Init the sync bar\";\n\t_stripSyncBar.setColor(QColor(225, 86, 108));\n\n\tPHDEBUG << \"Load the font file\";\n\tQString fontFile = \"\";\n\tif(_settings != NULL)\n\t\tfontFile = _settings->textFontFile();\n\telse\n\t\tPHDEBUG << \"no settings...\";\n\n\tif(!QFile(fontFile).exists()) {\n\t\tPHDEBUG << \"File not found:\" << fontFile;\n\t\tfontFile = QCoreApplication::applicationDirPath() + PATH_TO_RESSOURCES + \"/\" + \"SWENSON.TTF\";\n\t\tif(_settings != NULL)\n\t\t\t_settings->textFontFile();\n\t\telse\n\t\t\tPHDEBUG << \"no settings...\";\n\t}\n\t_textFont.setFontFile(fontFile);\n\n\tif(_settings != NULL)\n\t\t_textFont.setBoldness(_settings->textBoldness());\n\n\t// Init the sync bar\n\t_stripSyncBar.setColor(QColor(225, 86, 108));\n\n\t_hudFont.setFontFile(QCoreApplication::applicationDirPath() + PATH_TO_RESSOURCES + \"/\" + \"HelveticaCYPlain.ttf\");\n\n\t// This is used to make some time-based test\n\t_testTimer.start();\n\n\treturn true;\n}\n\nvoid PhGraphicStrip::onDocChanged()\n{\n\t_trackNumber = 4;\n\tforeach(PhStripText *text, _doc.texts()) {\n\t\tif(text->track() >= _trackNumber)\n\t\t\t_trackNumber = text->track() + 1;\n\t}\n\n\tforeach(PhStripDetect *detect, _doc.detects()) {\n\t\tif(detect->track() >= _trackNumber)\n\t\t\t_trackNumber = detect->track() + 1;\n\t}\n}\n\nPhFont *PhGraphicStrip::getTextFont()\n{\n\treturn &_textFont;\n}\n\nPhFont *PhGraphicStrip::getHUDFont()\n{\n\treturn &_hudFont;\n}\n\nQColor PhGraphicStrip::computeColor(PhPeople * people, QList<PhPeople*> selectedPeoples, bool invertColor)\n{\n\tif(!invertColor) {\n\t\tif(people) {\n\t\t\tif(selectedPeoples.size() && !selectedPeoples.contains(people)) {\n\t\t\t\treturn QColor(100, 100, 100);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn people->color();\n\t\t\t}\n\t\t}\n\t\telse if(selectedPeoples.size())\n\t\t\treturn QColor(100, 100, 100);\n\t\telse\n\t\t\treturn Qt::black;\n\t}\n\telse {\n\t\tif(people) {\n\t\t\tif(selectedPeoples.size() && !selectedPeoples.contains(people)) {\n\t\t\t\treturn QColor(155, 155, 155);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tQColor color(people->color());\n\t\t\t\treturn QColor(255 - color.red(), 255 - color.green(), 255 - color.blue());\n\t\t\t}\n\t\t}\n\t\telse if(selectedPeoples.size())\n\t\t\treturn QColor(155, 155, 155);\n\t\telse\n\t\t\treturn Qt::white;\n\t}\n}\n\nvoid PhGraphicStrip::draw(int x, int y, int width, int height, int tcOffset, QList<PhPeople *> selectedPeoples)\n{\n\t_infos.clear();\n\n\tint counter = 0;\n\tbool invertedColor = _settings->invertColor();\n\tglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n\tint lastDrawElapsed = _testTimer.elapsed();\n\t//PHDEBUG << \"time \" << _clock.time() << \" \\trate \" << _clock.rate();\n\n\tif(height > 0) {\n\t\tint timePerPixel = _settings->horizontalTimePerPixel();\n\t\t_textFont.setBoldness(_settings->textBoldness());\n\t\t_textFont.setFontFile(_settings->textFontFile());\n\n\t\tint loopCounter = 0;\n\t\tint offCounter = 0;\n\t\tint cutCounter = 0;\n\n\t\tlong syncBar_X_FromLeft = width / 6;\n\t\tlong delay = (int)(24 * _settings->screenDelay() *  _clock.rate());\n\t\tPhTime clockTime = _clock.time() + delay;\n\t\tlong offset = clockTime / timePerPixel - syncBar_X_FromLeft;\n\n\t\t//Compute the visible duration of the strip\n\t\tPhTime stripDuration = width * timePerPixel;\n\n\n\t\tif(_settings->stripTestMode()) {\n\t\t\tforeach(PhStripCut * cut, _doc.cuts())\n\t\t\t{\n\t\t\t\tcounter++;\n\t\t\t\tif(cut->timeIn() == clockTime) {\n\t\t\t\t\tPhGraphicSolidRect white(x, y, width, height);\n\t\t\t\t\twhite.setColor(Qt::white);\n\t\t\t\t\twhite.draw();\n\n\t\t\t\t\t//This is useless to continue the foreach if the cut is displayed.\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tPhTime timeIn = clockTime - syncBar_X_FromLeft * timePerPixel;\n\t\tPhTime timeOut = timeIn + stripDuration;\n\n\t\t//Draw backgroung picture\n\t\tint n = width / height + 2; // compute how much background repetition do we need\n\t\tlong leftBG = 0;\n\t\tif(offset >= 0)\n\t\t\tleftBG -= offset % height;\n\t\telse\n\t\t\tleftBG -= height - ((-offset) % height);\n\n\t\tPhGraphicTexturedRect* backgroundImage = &_stripBackgroundImage;\n\t\tif(invertedColor)\n\t\t\tbackgroundImage = &_stripBackgroundImageInverted;\n\n\t\tbackgroundImage->setX(x + leftBG);\n\t\tbackgroundImage->setY(y);\n\t\tbackgroundImage->setSize(height * n, height);\n\t\tbackgroundImage->setZ(-2);\n\t\tbackgroundImage->setTextureCoordinate(n, 1);\n\t\tbackgroundImage->draw();\n\n\t\t_stripSyncBar.setSize(4, height);\n\t\t_stripSyncBar.setPosition(x + width/6, y, 0);\n\t\t_stripSyncBar.setColor(QColor(225, 86, 108));\n\n\t\t_stripSyncBar.draw();\n\n\t\tif(_settings->displayRuler()) {\n\t\t\tPhTime rulerTimeIn = _settings->rulerTimeIn();\n\t\t\tPhTime timeBetweenRuler = _settings->timeBetweenRuler();\n\t\t\tint rulerNumber = (timeIn - rulerTimeIn) / timeBetweenRuler;\n\t\t\tif (rulerNumber < 0)\n\t\t\t\trulerNumber = 0;\n\n\t\t\tPhTime rulerTime = rulerTimeIn + rulerNumber * timeBetweenRuler;\n\t\t\tPhGraphicSolidRect rulerRect;\n\t\t\tPhGraphicDisc rulerDisc;\n\t\t\tPhGraphicText rulerText(&_hudFont);\n\t\t\tQColor rulerColor(80, 80, 80);\n\t\t\tif(invertedColor)\n\t\t\t\trulerColor = Qt::white;\n\n\t\t\tint width = 1000 / timePerPixel;\n\n\t\t\trulerRect.setColor(rulerColor);\n\t\t\trulerRect.setWidth(width);\n\t\t\trulerRect.setHeight(height / 2);\n\t\t\trulerRect.setZ(0);\n\t\t\trulerRect.setY(y);\n\n\t\t\trulerDisc.setColor(rulerColor);\n\t\t\trulerDisc.setRadius(2 * width);\n\t\t\trulerDisc.setY(y + height / 2 + 3 * width);\n\t\t\trulerDisc.setZ(0);\n\n\t\t\trulerText.setColor(rulerColor);\n\t\t\trulerText.setY(y + height / 2);\n\t\t\trulerText.setHeight(height / 2);\n\t\t\trulerText.setZ(0);\n\n\n\t\t\twhile (rulerTime < timeOut + timeBetweenRuler) {\n\t\t\t\tcounter++;\n\t\t\t\tint x = rulerTime / timePerPixel - offset;\n\n\t\t\t\trulerRect.setX(x - rulerRect.getWidth() / 2);\n\t\t\t\trulerRect.draw();\n\n\t\t\t\tQString text = QString::number(rulerNumber);\n\t\t\t\trulerText.setContent(text);\n\t\t\t\tint textWidth = _hudFont.getNominalWidth(text);\n\t\t\t\trulerText.setWidth(textWidth);\n\t\t\t\trulerText.setX(x - textWidth / 2);\n\t\t\t\trulerText.draw();\n\n\t\t\t\tx += timeBetweenRuler / timePerPixel / 2;\n\n\t\t\t\trulerRect.setX(x - rulerRect.getWidth() / 2);\n\t\t\t\trulerRect.draw();\n\n\t\t\t\trulerDisc.setX(x);\n\t\t\t\trulerDisc.draw();\n\n\t\t\t\trulerNumber++;\n\t\t\t\trulerTime += timeBetweenRuler;\n\t\t\t}\n\t\t}\n\n\t\tint minTimeBetweenPeople = 48000;\n\t\tint timeBetweenPeopleAndText = 4000;\n\t\tPhStripText ** lastTextList = new PhStripText*[_trackNumber];\n\t\tfor(int i = 0; i < _trackNumber; i++)\n\t\t\tlastTextList[i] = NULL;\n\n\t\tint trackHeight = height / _trackNumber;\n\n\t\tint verticalTimePerPixel = _settings->verticalTimePerPixel();\n\t\tbool displayNextText = _settings->displayNextText();\n\t\tPhTime maxTimeIn = timeOut;\n\t\tif(displayNextText)\n\t\t\tmaxTimeIn += y * verticalTimePerPixel;\n\n\t\tforeach(PhStripText * text, _doc.texts())\n\t\t{\n\t\t\tint track = text->track();\n\n\t\t\tif( !((text->timeOut() < timeIn) || (text->timeIn() > timeOut)) ) {\n\t\t\t\tcounter++;\n\t\t\t\tPhGraphicText gText(&_textFont, text->content());\n\t\t\t\tgText.setZ(-1);\n\n\t\t\t\tgText.setX(x + text->timeIn() / timePerPixel - offset);\n\t\t\t\tgText.setWidth((text->timeOut() - text->timeIn()) / timePerPixel);\n\t\t\t\tgText.setY(y + track * trackHeight);\n\t\t\t\tgText.setHeight(trackHeight);\n\t\t\t\tgText.setZ(-1);\n\t\t\t\tgText.setColor(computeColor(text->people(), selectedPeoples, invertedColor));\n\n\t\t\t\tgText.draw();\n\t\t\t}\n\n\t\t\tPhPeople * people = text->people();\n\t\t\tQString name = people ? people->name() : \"???\";\n\t\t\tPhGraphicText gPeople(&_hudFont, name);\n\t\t\tgPeople.setWidth(name.length() * 12);\n\n\t\t\tPhStripText * lastText = lastTextList[track];\n\t\t\t// Display the people name only if one of the following condition is true:\n\t\t\t// - it is the first text\n\t\t\t// - it is a different people\n\t\t\t// - the distance between the latest text and the current is superior to a limit\n\t\t\tif((\n\t\t\t       (lastText == NULL)\n\t\t\t       || (lastText->people() != text->people())\n\t\t\t       || (text->timeIn() - lastText->timeOut() > minTimeBetweenPeople))\n\t\t\t   ) {\n\n\t\t\t\tgPeople.setX(x + (text->timeIn() - timeBetweenPeopleAndText) / timePerPixel - offset - gPeople.getWidth());\n\t\t\t\tgPeople.setY(y + track * trackHeight);\n\t\t\t\tgPeople.setZ(-1);\n\t\t\t\tgPeople.setHeight(trackHeight / 2);\n\n\t\t\t\tgPeople.setColor(computeColor(people, selectedPeoples, invertedColor));\n\n\t\t\t\tgPeople.draw();\n\t\t\t}\n\n\t\t\tPhTime timePerPeopleHeight = gPeople.getHeight() * verticalTimePerPixel;\n\n\t\t\tif(displayNextText && (timeIn < text->timeIn() + timePerPeopleHeight) && ((lastText == NULL) || (text->timeIn() - lastText->timeOut() > minTimeBetweenPeople))) {\n\t\t\t\tPhPeople * people = text->people();\n\n\t\t\t\tint howFarIsText = (text->timeIn() - clockTime) / verticalTimePerPixel;\n\t\t\t\t//This line is used to see which text's name will be displayed\n\t\t\t\tgPeople.setX(width - gPeople.getWidth());\n\t\t\t\tgPeople.setY(y - howFarIsText - gPeople.getHeight());\n\n\t\t\t\tgPeople.setZ(-3);\n\t\t\t\tgPeople.setHeight(trackHeight / 2);\n\n\t\t\t\tgPeople.setColor(computeColor(people, selectedPeoples, invertedColor));\n\n\t\t\t\tPhGraphicSolidRect background(gPeople.getX(), gPeople.getY(), gPeople.getWidth(), gPeople.getHeight() + 2);\n\t\t\t\tif(selectedPeoples.size() && !selectedPeoples.contains(people))\n\t\t\t\t\tbackground.setColor(QColor(90, 90, 90));\n\t\t\t\telse\n\t\t\t\t\tbackground.setColor(QColor(180, 180, 180));\n\n\t\t\t\tbackground.setZ(gPeople.getZ() - 1);\n\n\t\t\t\tif(gPeople.getY() > tcOffset) {\n\t\t\t\t\tif(!invertedColor)\n\t\t\t\t\t\tbackground.draw();\n\n\t\t\t\t\tgPeople.draw();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlastTextList[track] = text;\n\n\t\t\tif(text->timeIn() > maxTimeIn)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tdelete lastTextList;\n\n\t\tforeach(PhStripCut * cut, _doc.cuts())\n\t\t{\n\t\t\t//_counter++;\n\t\t\tif( (timeIn < cut->timeIn()) && (cut->timeIn() < timeOut)) {\n\t\t\t\tPhGraphicSolidRect gCut;\n\t\t\t\tgCut.setZ(-1);\n\t\t\t\tgCut.setWidth(2);\n\n\t\t\t\tif(invertedColor)\n\t\t\t\t\tgCut.setColor(QColor(255, 255, 255));\n\t\t\t\telse\n\t\t\t\t\tgCut.setColor(QColor(0, 0, 0));\n\t\t\t\tgCut.setHeight(height);\n\t\t\t\tgCut.setX(x + cut->timeIn() / timePerPixel - offset);\n\t\t\t\tgCut.setY(y);\n\n\t\t\t\tgCut.draw();\n\t\t\t\tcutCounter++;\n\t\t\t}\n\t\t\t//Doesn't need to process undisplayed content\n\t\t\tif(cut->timeIn() > timeOut)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tforeach(PhStripLoop * loop, _doc.loops())\n\t\t{\n\t\t\t//_counter++;\n\t\t\t// This calcul allow the cross to come smoothly on the screen (height * timePerPixel / 8)\n\t\t\tif( ((loop->timeIn() + height * timePerPixel / 8) > timeIn) && ((loop->timeIn() - height * timePerPixel / 8 ) < timeOut)) {\n\t\t\t\tPhGraphicLoop gLoop;\n\t\t\t\tif(!invertedColor)\n\t\t\t\t\tgLoop.setColor(Qt::black);\n\t\t\t\telse\n\t\t\t\t\tgLoop.setColor(Qt::white);\n\n\t\t\t\tgLoop.setX(x + loop->timeIn() / timePerPixel - offset);\n\t\t\t\tgLoop.setY(y);\n\t\t\t\tgLoop.setZ(-1);\n\t\t\t\tgLoop.setHThick(height / 40);\n\t\t\t\tgLoop.setHeight(height);\n\t\t\t\tgLoop.setCrossHeight(height / 4);\n\t\t\t\tgLoop.setWidth(height / 4);\n\n\t\t\t\tgLoop.draw();\n\t\t\t\tloopCounter++;\n\t\t\t}\n\n\t\t\tif(displayNextText && ((loop->timeIn() + height * timePerPixel / 8) > timeIn)) {\n\t\t\t\tPhGraphicLoop gLoopPred;\n\n\t\t\t\tint howFarIsLoop = (loop->timeIn() - clockTime) / verticalTimePerPixel;\n\t\t\t\tgLoopPred.setColor(Qt::white);\n\n\t\t\t\tgLoopPred.setHorizontalLoop(true);\n\t\t\t\tgLoopPred.setZ(-3);\n\n\t\t\t\tgLoopPred.setX(width - width / 10);\n\t\t\t\tgLoopPred.setY(y - howFarIsLoop);\n\t\t\t\tgLoopPred.setHeight(30);\n\n\t\t\t\tgLoopPred.setHThick(3);\n\t\t\t\tgLoopPred.setCrossHeight(20);\n\t\t\t\tgLoopPred.setWidth(width / 10);\n\n\t\t\t\tgLoopPred.draw();\n\t\t\t}\n\t\t\tif((loop->timeIn() - height * timePerPixel / 8) > timeOut + 25 * 30)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tforeach(PhStripDetect * detect, _doc.detects())\n\t\t{\n\t\t\t//_counter++;\n\n\t\t\tif((timeIn < detect->timeOut()) && (detect->timeIn() < timeOut) ) {\n\t\t\t\tPhGraphicRect *gDetect = NULL;\n\t\t\t\tswitch (detect->type()) {\n\t\t\t\tcase PhStripDetect::Off:\n\t\t\t\t\tgDetect = new PhGraphicSolidRect();\n\t\t\t\t\tgDetect->setY(y + detect->track() * trackHeight + trackHeight * 0.9);\n\t\t\t\t\tgDetect->setHeight(trackHeight / 10);\n\t\t\t\t\tbreak;\n\t\t\t\tcase PhStripDetect::SemiOff:\n\t\t\t\t\tgDetect = new PhGraphicDashedLine((detect->timeOut() - detect->timeIn()) / 1200);\n\t\t\t\t\tgDetect->setY(y + detect->track() * trackHeight + trackHeight * 0.9);\n\t\t\t\t\tgDetect->setHeight(trackHeight / 10);\n\t\t\t\t\tbreak;\n\t\t\t\tcase PhStripDetect::ArrowUp:\n\t\t\t\t\tgDetect = new PhGraphicArrow(PhGraphicArrow::DownLeftToUpRight);\n\t\t\t\t\tgDetect->setY(y + detect->track() * trackHeight);\n\t\t\t\t\tgDetect->setHeight(trackHeight);\n\t\t\t\t\tbreak;\n\t\t\t\tcase PhStripDetect::ArrowDown:\n\t\t\t\t\tgDetect = new PhGraphicArrow(PhGraphicArrow::UpLefToDownRight);\n\t\t\t\t\tgDetect->setY(y + detect->track() * trackHeight);\n\t\t\t\t\tgDetect->setHeight(trackHeight);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif(gDetect) {\n\t\t\t\t\tgDetect->setColor(computeColor(detect->people(), selectedPeoples, invertedColor));\n\n\t\t\t\t\tgDetect->setX(x + detect->timeIn() / timePerPixel - offset);\n\t\t\t\t\tgDetect->setZ(-1);\n\t\t\t\t\tgDetect->setWidth((detect->timeOut() - detect->timeIn()) / timePerPixel);\n\t\t\t\t\tgDetect->draw();\n\t\t\t\t\toffCounter++;\n\t\t\t\t\tdelete gDetect;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//Doesn't need to process undisplayed content\n\t\t\tif(detect->timeIn() > timeOut)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t//\tPHDEBUG << \"off counter : \" << offCounter << \"cut counter : \" << cutCounter << \"loop counter : \" << loopCounter;\n\n\tint currentDrawElapsed = _testTimer.elapsed() - lastDrawElapsed;\n\tif(currentDrawElapsed > _maxDrawElapsed)\n\t\t_maxDrawElapsed = currentDrawElapsed;\n\t_testTimer.restart();\n\n\t_infos.append(QString(\"Max strip draw: %1\").arg(_maxDrawElapsed));\n\t_infos.append(QString(\"Count: %1\").arg(counter));\n\n\tif(_settings->resetInfo())\n\t\t_maxDrawElapsed = 0;\n}\n", "name": "libs/PhGraphicStrip/PhGraphicStrip.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef PHGRAPHICSTRIP_H\n#define PHGRAPHICSTRIP_H\n\n#include <QObject>\n#include <QTime>\n\n#include \"PhGraphicStripSettings.h\"\n\n#include \"PhStrip/PhStripDoc.h\"\n\n#include \"PhGraphic/PhGraphicText.h\"\n#include \"PhGraphic/PhGraphicImage.h\"\n#include \"PhGraphic/PhGraphicSolidRect.h\"\n#include \"PhGraphic/PhGraphicLoop.h\"\n\n#include \"PhTools/PhClock.h\"\n\n/**\n * @brief This class draw a segment of strip band.\n *\n * The length of the strip band portion\n * is proportionnal to its width in pixel.\n *\n * The strip is divided in several horizontal track.\n *\n * Each track can contains text element.\n *\n * Each text element can be preceeded by a people name using the following rule:\n *\n * If the text element is affected to a people and there is no text affected to the same\n * people in the two second preceeding the start of the text, the people name is displayed.\n *\n * In all other case, no people name is displayed.\n *\n * The  display also the loop (vertical dash with cross) and the cut changes (vertical dash).\n *\n * The  display a portion of strip band according to the current time.\n *\n * The portion of strip band scroll smoothly according to the current rate.\n *\n * The font used by the text is customisable.\n */\nclass PhGraphicStrip : public QObject\n{\n\tQ_OBJECT\npublic:\n\t/**\n\t * PhGraphicStrip constructor\n\t * @param parent Parent object\n\t */\n\texplicit PhGraphicStrip(QObject * parent = 0);\n\n\t/**\n\t * Get the PhStripDoc attached to the .\n\t * @return A PhStripDoc instance.\n\t */\n\tPhStripDoc *doc();\n\n\t/**\n\t * Get the PhClock attached to the .\n\t * @return A PhClock instance.\n\t */\n\tPhClock * clock();\n\n\n\t/**\n\t * @brief Pass the settings to the graphic strip\n\t * @param settings The settings\n\t */\n\tvoid setSettings(PhGraphicStripSettings * settings);\n\n\t/**\n\t * Set the font used to render text on the strip.\n\t * @param fontFile Font file path\n\t * @return true if the operation succeeds, false otherwise.\n\t */\n\tbool setFontFile(QString fontFile);\n\t/**\n\t * @brief Initializisation of the PhGraphicStrip\n\t *\n\t * Call clearData() then :\n\t * - Load the strip background\n\t * - Set the synchronization bar\n\t * - Load the font file\n\t * @return True if succeed, false otherwise\n\t */\n\n\tbool init();\n\n\t/**\n\t * @brief draw the strip\n\t *\n\t * It compute all the necessary data for the current frame, skipped\n\t * if height = 0\n\t *\n\t * @param x upper left corner coordinates\n\t * @param y upper left corner coordinates\n\t * @param width width of the strip (usually the same as the parent window)\n\t * @param height height of the strip\n\t * @param tcOffset the upper Offset\n\t * @param selectedPeoples Selected people will be displayed on the upper left corner,\n\t * the others ones will be shaded.\n\t */\n\tvoid draw(int x, int y, int width, int height, int tcOffset = 0, QList<PhPeople*> selectedPeoples = QList<PhPeople*>());\n\n\t/**\n\t * @brief Get the font of the strip objects\n\t * @return the font\n\t */\n\tPhFont * getTextFont();\n\t/**\n\t * @brief Get the \"head up display\" Font\n\t *\n\t * The HUD font is used for all text printed on the screen which is not\n\t * a direct part of the strip :\n\t * - The current timecode\n\t * - The next element timecode\n\t * - The prediction\n\t * - The title of the document...\n\t * @return\n\t */\n\tPhFont * getHUDFont();\n\n\t/**\n\t * @brief List of info to be displayed on the screen debug overlay\n\t * @return A list of string\n\t */\n\tQStringList infos() {\n\t\treturn _infos;\n\t}\n\nprivate slots:\n\t/**\n\t * @brief Clear all the graphic strip object related to the PhStripDoc.\n\t */\n\tvoid onDocChanged();\n\nprivate:\n\n\t/**\n\t * @brief _doc\n\t * Reference to the current PhStripDoc\n\t */\n\tPhStripDoc _doc;\n\n\tPhClock _clock;\n\n\t/**\n\t * @brief The font used to draw text\n\t */\n\tPhFont _textFont;\n\n\t/**\n\t * @brief The font used to draw the rest of the HUD\n\t */\n\tPhFont _hudFont;\n\n\t/**\n\t * Background Image used for the strip band\n\t */\n\tPhGraphicImage _stripBackgroundImage;\n\tPhGraphicImage _stripBackgroundImageInverted;\n\n\n\tPhGraphicSolidRect _stripSyncBar;\n\n\t/**\n\t * @brief _test\n\t * QTime for testing performance\n\t */\n\tQTime _testTimer;\n\n\tint _trackNumber;\n\tPhGraphicStripSettings * _settings;\n\tint _maxDrawElapsed;\n\n\tQColor computeColor(PhPeople *people, QList<PhPeople *> selectedPeoples, bool invertColor);\n\n\tQStringList _infos;\n};\n\n#endif // PHGRAPHICSTRIP_H\n", "name": "libs/PhGraphicStrip/PhGraphicStrip.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef PHGRAPHICSTRIPSETTINGS_H\n#define PHGRAPHICSTRIPSETTINGS_H\n\n#include <QString>\n#include <QDir>\n\n#include \"PhGraphic/PhGraphicSettings.h\"\n\n/**\n * @brief The settings for PhGraphicStrip\n */\nclass PhGraphicStripSettings : public PhGraphicSettings\n{\npublic:\n\t/**\n\t * @brief Screen delay compensation\n\t * @return A value in millisecond\n\t */\n\tvirtual int screenDelay() = 0;\n\t/**\n\t * @brief The relative height of the strip in the view\n\t * @return A float value\n\t */\n\tvirtual float stripHeight() = 0;\n\t/**\n\t * @brief Duration of a pixel for horizontal scrolling\n\t * @return An integer value\n\t */\n\tvirtual int horizontalTimePerPixel() = 0;\n\t/**\n\t * @brief Duration of a pixel for vertical scrolling\n\t * @return An integer value\n\t */\n\tvirtual int verticalTimePerPixel() = 0;\n\t/**\n\t * @brief Set the strip text font file\n\t * @param value A font file path\n\t */\n\tvirtual void setTextFontFile(QString value) = 0;\n\t/**\n\t * @brief Get the strip text font file\n\t * @return A font file path\n\t */\n\tvirtual QString textFontFile() = 0;\n\t/**\n\t * @brief Get the strip text boldness\n\t * @return A integer value from 0 to 5\n\t */\n\tvirtual int textBoldness() = 0;\n\t/**\n\t * @brief Display the strip in test mode\n\t *\n\t * During the test mode, the whole strip is black except\n\t * if a cut is at the current time then the whole strip is white\n\t *\n\t * @return True if test mode, false otherwise\n\t */\n\tvirtual bool stripTestMode() = 0;\n\t/**\n\t * @brief Display the next people intervention\n\t *\n\t * The next people right after the rythmo range are scrolling\n\t * vertically on the left from the top of the view\n\t * to the top of the strip.\n\t *\n\t * @return True if displayed, false otherwise\n\t */\n\tvirtual bool displayNextText() = 0;\n\n\t/**\n\t * @brief Allow color invertion\n\t * @return True if the color is inverted, false otherwise\n\t */\n\tvirtual bool invertColor() = 0;\n\t/**\n\t * @brief Display the ruler on the strip\n\t * @return True if the ruler is displayed, false otherwise\n\t */\n\tvirtual bool displayRuler() = 0;\n\t/**\n\t * @brief The timestamp of the ruler\n\t * @return\n\t */\n\tvirtual int rulerTimeIn() = 0;\n\t/**\n\t * @brief The amount of time between each draw of the ruler\n\t * @return A time value\n\t */\n\tvirtual int timeBetweenRuler() = 0;\n\n};\n\n#endif // PHGRAPHICSTRIPSETTINGS_H\n", "name": "libs/PhGraphicStrip/PhGraphicStripSettings.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#include \"PhGraphicStripView.h\"\n\nPhGraphicStripView::PhGraphicStripView(QWidget *parent) :\n\tPhGraphicView(parent), _strip(parent), _settings(NULL)\n{\n}\n\nvoid PhGraphicStripView::setStripSettings(PhGraphicStripSettings *settings)\n{\n\t_settings = settings;\n\t_strip.setSettings(settings);\n\tthis->setGraphicSettings(settings);\n}\n\nbool PhGraphicStripView::init()\n{\n\tPhGraphicView::init();\n\tconnect(this, SIGNAL(beforePaint(PhTimeScale)), _strip.clock(), SLOT(tick(PhTimeScale)));\n\n\treturn _strip.init();\n}\n\nvoid PhGraphicStripView::paint()\n{\n\tint h = this->height();\n\tif(_settings)\n\t\th = this->height()* _settings->stripHeight();\n\t_strip.draw(0, this->height() - h, this->width(), h);\n\tforeach(QString info, _strip.infos()) {\n\t\tthis->addInfo(info);\n\t}\n}\n", "name": "libs/PhGraphicStrip/PhGraphicStripView.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef PHGRAPHICSTRIPVIEW_H\n#define PHGRAPHICSTRIPVIEW_H\n\n#include \"PhGraphic/PhGraphicView.h\"\n#include \"PhGraphicStrip/PhGraphicStrip.h\"\n#include \"PhGraphicStrip/PhGraphicStripSettings.h\"\n\n/**\n * @brief Provide a view of the PhGraphicStrip class\n */\nclass PhGraphicStripView : public PhGraphicView\n{\n\tQ_OBJECT\npublic:\n\t/**\n\t * @brief PhGraphicStripView constructor\n\t * @param parent The parent object\n\t */\n\texplicit PhGraphicStripView(QWidget *parent = 0);\n\n\t/**\n\t * @brief Get the PhGraphicStrip attached to the view\n\t * @return\n\t */\n\tPhGraphicStrip * strip() {\n\t\treturn &_strip;\n\t}\n\n\t/**\n\t * @brief Attach the given settings to the view\n\t *\n\t * @param settings The Settings\n\t */\n\tvoid setStripSettings(PhGraphicStripSettings *settings);\n\nprotected:\n\t/**\n\t * @brief Initializisation of the PhGraphicStrip\n\t * @return\n\t */\n\tbool init();\n\t/**\n\t * @brief call the PhGraphicView's method paint()\n\t */\n\tvoid paint();\n\nprivate:\n\tPhGraphicStrip _strip;\n\tPhGraphicStripSettings *_settings;\n};\n\n#endif // PHGRAPHICSTRIPVIEW_H\n", "name": "libs/PhGraphicStrip/PhGraphicStripView.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#include \"PhPeople.h\"\n\nPhPeople::PhPeople(QString name, QString color)\n{\n\t_name = name;\n\t_color = color;\n}\n\nQString PhPeople::name()\n{\n\treturn _name;\n}\n\n\nQString PhPeople::color()\n{\n\treturn _color;\n}\n", "name": "libs/PhStrip/PhPeople.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef PHPEOPLE_H\n#define PHPEOPLE_H\n\n#include <QString>\n\n/**\n * @brief Represents a character or a group of character from the video content.\n *\n * It can also be use to write notes or comments on the strip.\n * For example : NDA (note de l'adaptateur).\n */\nclass PhPeople {\n\npublic:\n\t/**\n\t * @brief PhPeople\n\t * @param name\n\t * @param color\n\t */\n\tPhPeople(QString name = \"???\", QString color = \"#000000\");\n\t/**\n\t * @brief Get the name\n\t * @return a string\n\t */\n\tQString name();\n\t/**\n\t * @brief Set the name\n\t * @param name a string\n\t */\n\tvoid setName(QString name);\n\t/**\n\t * @brief Get the color\n\t * @return a PhColor\n\t */\n\tQString color();\n\t/**\n\t * @brief Set the color\n\t * @param color a PhColor\n\t */\n\tvoid setColor(QString color);\n\nprivate:\n\t/**\n\t * Name of the people\n\t */\n\tQString _name;\n\t/**\n\t * Color of the people's text on the strip.\n\t */\n\tQString _color;\n\n};\n\n#endif // PHPEOPLE_H\n", "name": "libs/PhStrip/PhPeople.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#include \"PhStripCut.h\"\n\nPhStripCut::PhStripCut(PhStripCut::PhCutType type, PhFrame frame) : PhStripObject(frame)\n{\n\t_type = type;\n}\n", "name": "libs/PhStrip/PhStripCut.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef PHSTRIPCUT_H\n#define PHSTRIPCUT_H\n\n#include \"PhStrip/PhStripObject.h\"\n\n/**\n * @brief A cut is a change in the video from one shot to another.\n *\n * It can be simple (one frame change) or progressive (fade).\n */\nclass PhStripCut : public PhStripObject {\n\npublic:\n\t/**\n\t * Describes the type of the cut.\n\t */\n\tenum PhCutType {\n\t\tSimple, FadeIn, FadeOut, CrossFade\n\t};\n\n\t/**\n\t * @brief PhStripCut constructor\n\t * @param type The cut type\n\t * @param frame The cut frame\n\t */\n\tPhStripCut(PhStripCut::PhCutType type, PhFrame frame);\n\n\nprivate:\n\t/**\n\t * Type of cut.\n\t */\n\tPhCutType _type;\n\n};\n\n\n#endif // PHSTRIPCUT_H\n", "name": "libs/PhStrip/PhStripCut.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#include \"PhStripDetect.h\"\n\nPhStripDetect::PhStripDetect(PhDetectType type, PhTime timeIn, PhPeople *people, PhTime timeOut, int track)\n\t: PhStripPeopleObject(timeIn, people, timeOut, track),\n\t_type(type)\n{\n\n}\n", "name": "libs/PhStrip/PhStripDetect.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef PHSTRIPDETECT_H\n#define PHSTRIPDETECT_H\n\n#include \"PhStripPeopleObject.h\"\n\n/**\n * @brief Block of detection during which a PhPeople is speaking.\n *\n * The block can be off (out of the picture) or not.\n */\nclass PhStripDetect : public PhStripPeopleObject\n{\npublic:\n\t/**\n\t * @brief The various type of detect\n\t */\n\tenum PhDetectType {\n\t\tUnknown,\n\t\tOn,\n\t\tSemiOff,\n\t\tOff,\n\t\tMouthOpen,\n\t\tMouthClosed,\n\t\tAperture,\n\t\tAdvance,\n\t\tLabial,\n\t\tSemiLabial,\n\t\tBowl,\n\t\tDental,\n\t\tArrowUp,\n\t\tArrowDown,\n\t\tAmbianceStart,\n\t\tAmbianceEnd,\n\t};\n\n\t/**\n\t * @brief PhStripDetect constructor\n\t * @param type The type of detect\n\t * @param timeIn The starting time of the detect\n\t * @param people the corresponding PhPeople\n\t * @param timeOut The ending time of the detect\n\t * @param track The track of the detect\n\t */\n\tPhStripDetect( PhDetectType type, PhTime timeIn, PhPeople * people, PhTime timeOut, int track);\n\n\t/**\n\t * @brief If the people is out of the picture\n\t * @return True if out of the picture, false otherwise\n\t */\n\tPhDetectType type() {\n\t\treturn _type;\n\t}\n\nprivate:\n\tPhDetectType _type;\n};\n\n#endif // PHSTRIPDETECT_H\n", "name": "libs/PhStrip/PhStripDetect.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n\n#include <QFileInfo>\n#include <QDomDocument>\n#include <QDomNodeList>\n#include <QtXml>\n#include <QXmlStreamWriter>\n\n#include \"PhTools/PhFileTool.h\"\n#include \"PhStripDoc.h\"\n\nPhStripDoc::PhStripDoc(QObject *parent) :\n\tQObject(parent)\n{\n\treset();\n}\n\n\nbool PhStripDoc::importDetXFile(QString fileName)\n{\n\tPHDEBUG << fileName;\n\tif (!QFile(fileName).exists()) {\n\t\tPHDEBUG << \"The file doesn't exists\" << fileName;\n\t\treturn false;\n\t}\n\n\t_filePath = fileName;\n\n\t// Opening the XML file\n\tQFile xmlFile(fileName);\n\tif(!xmlFile.open(QIODevice::ReadOnly)) {\n\t\tPHDEBUG << \"Unable to open\" << fileName;\n\t\treturn false;\n\t}\n\n\t// Loading the DOM (document object model)\n\tQDomDocument *domDoc = new QDomDocument();\n\tif (!domDoc->setContent(&xmlFile)) {\n\t\txmlFile.close();\n\t\tPHDEBUG << \"The XML document seems to be bad formed \" << fileName;\n\t\treturn false;\n\t}\n\n\treset();\n\n\tQDomElement detX = domDoc->documentElement();\n\n\tif(detX.tagName() != \"detx\") {\n\t\txmlFile.close();\n\t\tPHDEBUG << \"Bad root element :\" << detX.tagName();\n\t\treturn false;\n\t}\n\n\t_generator = \"Cappella\";\n\t//With DetX files, fps is always 25 no drop\n\t_tcType = PhTimeCodeType25;\n\n\t// Reading the header\n\tif(detX.elementsByTagName(\"header\").count()) {\n\t\tQDomElement header = detX.elementsByTagName(\"header\").at(0).toElement();\n\n\t\t// Read the Cappella version\n\t\tif(header.elementsByTagName(\"cappella\").count())\n\t\t\t_generator += \" v\" + detX.elementsByTagName(\"cappella\").at(0).toElement().attribute(\"version\");\n\n\t\t// Reading the title\n\t\tif(header.elementsByTagName(\"title\").count())\n\t\t\t_title = header.elementsByTagName(\"title\").at(0).toElement().text();\n\t\telse\n\t\t\t_title = QFileInfo(fileName).baseName();\n\n\t\t// Reading the translated title\n\t\tif(header.elementsByTagName(\"title2\").count())\n\t\t\t_translatedTitle = header.elementsByTagName(\"title2\").at(0).toElement().text();\n\n\t\t// Reading the episode info\n\t\tif(header.elementsByTagName(\"episode\").count()) {\n\t\t\tQDomElement episodeElem = header.elementsByTagName(\"episode\").at(0).toElement();\n\t\t\t_episode = episodeElem.attribute(\"number\");\n\t\t\t_season = episodeElem.attribute(\"season\");\n\t\t}\n\n\t\t// Reading the video path\n\t\tif(header.elementsByTagName(\"videofile\").count()) {\n\t\t\tQDomElement videoFile = header.elementsByTagName(\"videofile\").at(0).toElement();\n\t\t\t_videoPath = videoFile.text();\n\t\t\t// Reading the video time in\n\t\t\t_videoTimeIn = PhTimeCode::timeFromString(videoFile.attribute(\"timestamp\"), _tcType);\n\t\t}\n\n\t\t// Reading the last position\n\t\tif(header.elementsByTagName(\"last_position\").count()) {\n\t\t\tQDomElement lastPosition = header.elementsByTagName(\"last_position\").at(0).toElement();\n\t\t\t_lastTime = PhTimeCode::timeFromString(lastPosition.attribute(\"timecode\"), _tcType);\n\t\t}\n\n\t\t// Reading the author name\n\t\tif(header.elementsByTagName(\"author\").count()) {\n\t\t\tQDomElement author = header.elementsByTagName(\"author\").at(0).toElement();\n\t\t\t_authorName = author.attribute(\"firstname\") + \" \" + author.attribute(\"name\");\n\t\t}\n\n\t\t// Reading other meta informations\n\t\tif(header.elementsByTagName(\"production\").count()) {\n\t\t\tQDomElement production = header.elementsByTagName(\"production\").at(0).toElement();\n\t\t\t_metaInformation[\"Producteur\"] = production.attribute(\"producer\");\n\t\t\t_metaInformation[\"Ann\u00e9e de production\"] = production.attribute(\"year\");\n\t\t\t_metaInformation[\"Distributeur\"] = production.attribute(\"distributor\");\n\t\t\t_metaInformation[\"R\u00e9alisateur\"] = production.attribute(\"director\");\n\t\t\t_metaInformation[\"Diffuseur\"] = production.attribute(\"diffuser\");\n\t\t\t_metaInformation[\"Pays d'origine\"] = production.attribute(\"country\");\n\t\t}\n\t}\n\n\tQMap<QString, PhPeople*> peopleMap;\n\n\t// Reading the \"role\" lists\n\tif(detX.elementsByTagName(\"roles\").count()) {\n\t\tQDomElement roles = detX.elementsByTagName(\"roles\").at(0).toElement();\n\t\tQDomNodeList roleList = roles.elementsByTagName(\"role\");\n\t\tfor (int i = 0; i < roleList.length(); i++) {\n\t\t\tQDomElement role = roleList.at(i).toElement();\n\t\t\tPhPeople *people = new PhPeople(role.attribute(\"name\"), role.attribute(\"color\"));\n\n\t\t\t//Currently using id as key instead of name\n\t\t\tpeopleMap[role.attribute(\"id\")] = people;\n\t\t\t_peoples.append(people);\n\t\t}\n\t}\n\n\tint loopNumber = 1;\n\n\t// Reading the strip body\n\tif(detX.elementsByTagName(\"body\").count()) {\n\t\tQDomElement body = detX.elementsByTagName(\"body\").at(0).toElement();\n\t\tfor(int i = 0; i < body.childNodes().length(); i++) {\n\t\t\tif(body.childNodes().at(i).isElement()) {\n\t\t\t\tQDomElement elem = body.childNodes().at(i).toElement();\n\n\t\t\t\t// Reading loops\n\t\t\t\tif(elem.tagName() == \"loop\")\n\t\t\t\t\t_loops.append(new PhStripLoop(loopNumber++,\n\t\t\t\t\t                              PhTimeCode::timeFromString(elem.attribute(\"timecode\"), _tcType)));\n\t\t\t\t// Reading cuts\n\t\t\t\telse if(elem.tagName() == \"shot\")\n\t\t\t\t\t_cuts.append(new PhStripCut(PhStripCut::Simple,\n\t\t\t\t\t                            PhTimeCode::timeFromString(elem.attribute(\"timecode\"), _tcType)));\n\t\t\t\telse if(elem.tagName() == \"line\") {\n\t\t\t\t\tPhTime timeIn = -1;\n\t\t\t\t\tPhTime lastTime = -1;\n\t\t\t\t\tPhTime lastLinkedTime = -1;\n\t\t\t\t\tPhPeople *people = peopleMap[elem.attribute(\"role\")];\n\t\t\t\t\tint track = elem.attribute(\"track\").toInt();\n\t\t\t\t\tQString currentText = \"\";\n\t\t\t\t\tfor(int j = 0; j < elem.childNodes().length(); j++) {\n\t\t\t\t\t\tif(elem.childNodes().at(j).isElement()) {\n\t\t\t\t\t\t\tQDomElement lineElem = elem.childNodes().at(j).toElement();\n\t\t\t\t\t\t\tif(lineElem.tagName() == \"lipsync\") {\n\t\t\t\t\t\t\t\tlastTime = PhTimeCode::timeFromString(lineElem.attribute(\"timecode\"), _tcType);\n\t\t\t\t\t\t\t\tif(timeIn < 0)\n\t\t\t\t\t\t\t\t\ttimeIn = lastTime;\n\t\t\t\t\t\t\t\tif(lineElem.attribute(\"link\") != \"off\") {\n\t\t\t\t\t\t\t\t\tif(currentText.length()) {\n\t\t\t\t\t\t\t\t\t\t_texts1.append(new PhStripText(lastLinkedTime, people, lastTime, track, currentText));\n\t\t\t\t\t\t\t\t\t\tcurrentText = \"\";\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tlastLinkedTime = lastTime;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(lineElem.tagName() == \"text\")\n\t\t\t\t\t\t\t\tcurrentText += lineElem.text();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Handling line with no lipsync out\n\t\t\t\t\tif(currentText.length()) {\n\t\t\t\t\t\tPhTime time = lastLinkedTime + currentText.length() * 1000;\n\t\t\t\t\t\tPHDEBUG << currentText;\n\t\t\t\t\t\t_texts1.append(new PhStripText(lastLinkedTime, people, time, track, currentText));\n\t\t\t\t\t\tlastTime = lastLinkedTime = time;\n\t\t\t\t\t}\n\t\t\t\t\tPhStripDetect::PhDetectType type = PhStripDetect::On;\n\t\t\t\t\tif(elem.attribute(\"voice\") == \"off\")\n\t\t\t\t\t\ttype = PhStripDetect::Off;\n\t\t\t\t\t_detects.append(new PhStripDetect(type, timeIn, people, lastTime, track));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\temit this->changed();\n\n\treturn true;\n}\n\nbool PhStripDoc::checkMosTag2(QFile &f, int level, QString expected)\n{\n\tQString name = PhFileTool::readString(f, level, expected);\n\tif(name != expected) {\n\t\tPHDEBUG << \"!!!!!!!!!!!!!!!\" << \"Error reading \" << expected << \"!!!!!!!!!!!!!!!\";\n\t\tf.close();\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool PhStripDoc::checkMosTag(QFile &f, int level, MosTag expectedTag)\n{\n\tMosTag tag = readMosTag(f, level, \"checkMosTag\");\n\n\tif(tag != expectedTag) {\n\t\tPHDEBUG << \"!!!!!!!!!!!!!!!\" << \"Error reading \" << tag << \"instead of\" << expectedTag << \"!!!!!!!!!!!!!!!\";\n\t\tf.close();\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nPhTime PhStripDoc::readMosTime(QFile &f, PhTimeCodeType tcType, int level)\n{\n\treturn PhFileTool::readInt(f, level, \"time\") * PhTimeCode::timePerFrame(tcType) / 12;\n}\n\nPhStripText* PhStripDoc::readMosText(QFile &f, int textLevel, int internLevel)\n{\n\tQString content = PhFileTool::readString(f, 2, \"content\");\n\n\tPhTime timeIn = _videoTimeIn + readMosTime(f, _tcType, internLevel);;\n\tPhTime timeOut = _videoTimeIn + readMosTime(f, _tcType, internLevel);;\n\n\tPhStripText* text = new PhStripText(timeIn, NULL, timeOut, 0, content);\n\n\tPhFileTool::readInt(f, internLevel, \"text\");\n\tPhFileTool::readInt(f, internLevel, \"text\");\n\tPhFileTool::readInt(f, internLevel, \"text\");\n\tPhFileTool::readInt(f, internLevel, \"text\");\n\tPhFileTool::readInt(f, internLevel, \"text\");\n\tPhFileTool::readInt(f, internLevel, \"text\");\n\n\tPHDBG(textLevel) << PHNQ(PhTimeCode::stringFromTime(timeIn, _tcType))\n\t                 << \"->\"\n\t                 << PHNQ(PhTimeCode::stringFromTime(timeOut, _tcType))\n\t                 << PHNQ(content);\n\treturn text;\n}\n\nPhStripDetect *PhStripDoc::readMosDetect(QFile &f, int detectLevel, int internLevel)\n{\n\tPhTime timeIn = _videoTimeIn + readMosTime(f, _tcType, internLevel);;\n\tPhTime timeOut = _videoTimeIn + readMosTime(f, _tcType, internLevel);;\n\tPhFileTool::readInt(f, internLevel, \"detect type 1\");\n\tint detectType2 = PhFileTool::readInt(f, internLevel, \"detect type 2\");\n\tint detectType3 = PhFileTool::readInt(f, internLevel, \"detect type 3\");\n\tPhStripDetect::PhDetectType type = PhStripDetect::Unknown;\n\tswitch(detectType3) {\n\tcase 9:\n\t\ttype = PhStripDetect::SemiOff;\n\t\tbreak;\n\tcase 10:\n\t\ttype = PhStripDetect::Off;\n\t\tbreak;\n\tdefault:\n\t\tswitch (detectType2) {\n\t\tcase 0:\n\t\t\ttype = PhStripDetect::On;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\ttype = PhStripDetect::MouthOpen;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\ttype = PhStripDetect::MouthClosed;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\ttype = PhStripDetect::Aperture;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\ttype = PhStripDetect::Advance;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\ttype = PhStripDetect::Labial;\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\ttype = PhStripDetect::SemiLabial;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\ttype = PhStripDetect::Bowl;\n\t\t\tbreak;\n\t\tcase 13:\n\t\tcase 14:\n\t\t\ttype = PhStripDetect::Dental;\n\t\t\tbreak;\n\t\tcase 15:\n\t\t\ttype = PhStripDetect::ArrowUp;\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\ttype = PhStripDetect::ArrowDown;\n\t\t\tbreak;\n\t\tcase 17:\n\t\t\ttype = PhStripDetect::AmbianceStart;\n\t\t\tbreak;\n\t\tcase 18:\n\t\t\ttype = PhStripDetect::AmbianceEnd;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor(int j = 0; j < 6; j++)\n\t\tPhFileTool::readShort(f, internLevel);\n\tPHDBG(detectLevel) << \"detect: \"\n\t                   << PhTimeCode::stringFromTime(timeIn, _tcType)\n\t                   << PhTimeCode::stringFromTime(timeOut, _tcType)\n\t                   << \"type2:\"\n\t                   << detectType2\n\t                   << \"type3:\"\n\t                   << detectType3\n\t                   << \"type:\"\n\t                   << type;\n\treturn new PhStripDetect(type, timeIn, NULL, timeOut, 0);\n}\n\nbool PhStripDoc::readMosProperties(QFile &f, int level)\n{\n\tQString originalTitle = PhFileTool::readString(f, level, \"Titre de la versio originale\");\n\n\tQString translatedTitle = PhFileTool::readString(f, level, \"Titre de la version adapt\u00e9e\");\n\n\t_metaInformation[\"Titre de la version originale\"] = originalTitle;\n\t_metaInformation[\"Titre de la version adapt\u00e9e\"] = translatedTitle;\n\n\tif(originalTitle.length())\n\t\t_title = originalTitle;\n\telse if(translatedTitle.length())\n\t\t_title = translatedTitle;\n\n\t_season = PhFileTool::readString(f, level, \"Saison\");\n\t_episode = PhFileTool::readString(f, level, \"Episode/bobine\");\n\tPhFileTool::readString(f, level, \"Titre vo episode\");\n\tPhFileTool::readString(f, level, \"Titre adapt\u00e9 de l'\u00e9pisode\");\n\tPhFileTool::readString(f, level, \"Dur\u00e9e\");\n\tPhFileTool::readString(f, level, \"Date\");\n\tPhFileTool::readString(f, level, \"Client\");\n\tPhFileTool::readString(f, level, \"Commentaires\");\n\tPhFileTool::readString(f, level, \"D\u00e9tecteur\");\n\t_authorName = PhFileTool::readString(f, level, \"Auteur\");\n\tPhFileTool::readString(f, level, \"Studio\");\n\tPhFileTool::readString(f, level, \"D.A.\");\n\tPhFileTool::readString(f, level, \"Ing\u00e9nieur du son\");\n\n\treturn true;\n}\n\nPhStripDoc::MosTag PhStripDoc::readMosTag(QFile &f, int level, QString name)\n{\n\tunsigned short tag = PhFileTool::readShort(f, level, name);\n\tif(tag != 0xffff)\n\t\treturn _mosTagMap[tag];\n\n\tPhFileTool::readShort(f, level, name);\n\tQString stringTag = PhFileTool::readString(f, level, name);\n\n\tif(stringTag == \"CDocDoublage\")\n\t\treturn _mosTagMap[_mosNextTag++] = MosDub;\n\telse if(stringTag == \"CDocPiste\")\n\t\treturn _mosTagMap[_mosNextTag++] = MosTrack;\n\telse if(stringTag == \"CDocBlocTexte\")\n\t\treturn _mosTagMap[_mosNextTag++] = MosText;\n\telse if(stringTag == \"CDocBlocDetection\")\n\t\treturn _mosTagMap[_mosNextTag++] = MosDetect;\n\telse if(stringTag == \"CDocLangue\")\n\t\treturn _mosTagMap[_mosNextTag++] = MosLang;\n\telse if(stringTag == \"CDocEtiquetteNom\")\n\t\treturn _mosTagMap[_mosNextTag++] = MosLabel;\n\telse if(stringTag == \"CDocBoucle\")\n\t\treturn _mosTagMap[_mosNextTag++] = MosLoop;\n\telse if(stringTag == \"CDocPlan\")\n\t\treturn _mosTagMap[_mosNextTag++] = MosCut;\n\telse if(stringTag == \"CMosaicDoc\")\n\t\treturn _mosTagMap[_mosNextTag++] = MosDoc;\n\telse if(stringTag == \"CDocProjet\")\n\t\treturn _mosTagMap[_mosNextTag++] = MosProject;\n\telse if(stringTag == \"CDocProprietes\")\n\t\treturn _mosTagMap[_mosNextTag++] = MosProperties;\n\telse if(stringTag == \"CDocOptionsProjet\")\n\t\treturn _mosTagMap[_mosNextTag++] = MosOptions;\n\telse if(stringTag == \"CDocFilm\")\n\t\treturn _mosTagMap[_mosNextTag++] = MosMovie;\n\telse if(stringTag == \"CDocPersonnage\")\n\t\treturn _mosTagMap[_mosNextTag++] = MosPeople;\n\telse if(stringTag == \"CDocChutier\")\n\t\treturn _mosTagMap[_mosNextTag++] = MosBin;\n\telse {\n\t\tPHDEBUG << \"!!!!!!!!!!!!!!! Unknown tag:\" << stringTag << \"!!!!!!!!!!!!!!!\";\n\t\tf.close();\n\t\treturn MosUnknown;\n\t}\n}\n\nbool PhStripDoc::readMosTrack(QFile &f, QMap<int, PhPeople *> peopleMap, QMap<int, int> peopleTrackMap, int blocLevel, int textLevel, int detectLevel, int labelLevel, int level, int internLevel)\n{\n\tQList<PhStripDetect*> detectList;\n\tQList<PhStripText*> textList1, textList2;\n\tint detectCount = PhFileTool::readInt(f, detectLevel, \"track CDocBlocDetection count\");\n\n\tif(detectCount) {\n\t\tif(!checkMosTag(f, blocLevel, MosDetect))\n\t\t\treturn false;\n\n\t\tfor(int i = 0; i < detectCount; i++) {\n\t\t\tif(i > 0)\n\t\t\t\tPhFileTool::readShort(f, level, \"detect tag\");\n\t\t\tdetectList.append(readMosDetect(f, detectLevel, internLevel));\n\t\t}\n\t}\n\n\tint langCount = PhFileTool::readInt(f, blocLevel, \"track CDocLangue count\");\n\tif(langCount) {\n\t\tif(!checkMosTag(f, blocLevel, MosLang))\n\t\t\treturn false;\n\t}\n\n\tint textCount = PhFileTool::readInt(f, blocLevel, \"track CDocBlocTexte count\");\n\tif(textCount) {\n\t\tif(!checkMosTag(f, blocLevel, MosText))\n\t\t\treturn false;\n\n\t\tfor(int i = 0; i < textCount; i++) {\n\t\t\tif(i > 0)\n\t\t\t\tPhFileTool::readShort(f, level, \"text tag\");\n\t\t\ttextList1.append(readMosText(f, textLevel, internLevel));\n\t\t}\n\t}\n\n\tint peopleId = PhFileTool::readInt(f, level, \"people id\");\n\n\tfor(int k = 0; k < 2; k++) {\n\t\tint count = PhFileTool::readInt(f, level, \"track other count\");\n\t\tif(count == 0)\n\t\t\tcontinue;\n\t\tMosTag tag = readMosTag(f, level, \"track other tag\");\n\t\tswitch(tag) {\n\t\tcase MosText:\n\t\t\tfor(int i = 0; i < count; i++) {\n\t\t\t\tif(i > 0)\n\t\t\t\t\tPhFileTool::readShort(f, level, \"text tag\");\n\t\t\t\ttextList2.append(readMosText(f, textLevel, internLevel));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MosLabel:\n\t\t\tfor(int i = 0; i < count; i++) {\n\t\t\t\tif(i > 0)\n\t\t\t\t\tPhFileTool::readShort(f, level, \"label tag\");\n\t\t\t\tPhTime labelTime = _videoTimeIn + readMosTime(f, _tcType, internLevel);\n\t\t\t\tfor(int j = 0; j < 6; j++)\n\t\t\t\t\tPhFileTool::readShort(f, internLevel);\n\t\t\t\tPHDBG(labelLevel) << \"label\" << PhTimeCode::stringFromTime(labelTime, _tcType);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPHDEBUG << \"!!!!!!!!!!!!!!! Unknown tag:\" << PHNQ(QString::number(tag, 16)) << \"!!!!!!!!!!!!!!!\";\n\t\t\tf.close();\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tPhPeople *people = peopleMap[peopleId];\n\tint track = peopleTrackMap[peopleId];\n\n\tPHDBG(textLevel) << \"Adding\" << textList1.count() << \"texts in list 1\";\n\tforeach(PhStripText* text, textList1) {\n\t\ttext->setPeople(people);\n\t\ttext->setTrack(track);\n\t\t_texts1.append(text);\n\t}\n\n\tPHDBG(textLevel) << \"Adding\" << textList2.count() << \"texts in  list 2\";\n\tforeach(PhStripText* text, textList2) {\n\t\ttext->setPeople(people);\n\t\ttext->setTrack(track);\n\t\t_texts2.append(text);\n\t}\n\n\tforeach(PhStripDetect* detect, detectList) {\n\t\tdetect->setPeople((people));\n\t\tdetect->setTrack(track);\n\t\t_detects.append(detect);\n\t}\n\n\treturn true;\n}\n\nbool PhStripDoc::importMosFile(const QString &fileName)\n{\n\tPHDEBUG << \"===============\" << fileName << \"===============\";\n\n\tQFile f(fileName);\n\tif(!f.exists()) {\n\t\tPHDEBUG << \"File doesn't exists : \" << fileName;\n\t\treturn false;\n\t}\n\n\tif(!f.open(QFile::ReadOnly)) {\n\t\tPHDEBUG << \"Unable to open : \" << fileName;\n\t\treturn false;\n\t}\n\n\tthis->reset();\n\n\t_filePath = fileName;\n\t_title = QFileInfo(fileName).baseName();\n\n\tint level = 1;\n\tint ok = 0;\n\tint propLevel = ok;\n\tint peopleLevel = level;\n\tint textLevel = level;\n\tint detectLevel = level;\n\tint blocLevel = level;\n\tint cutLevel = level;\n\tint loopLevel = level;\n\tint labelLevel = level;\n\tint internLevel = 2;\n\n\tif(!checkMosTag2(f, blocLevel, \"NOBLURMOSAIC\"))\n\t\treturn false;\n\n\t_generator = \"Mosaic\";\n\n\tPhFileTool::readShort(f, blocLevel, \"CMosaicDoc\");\n\tPhFileTool::readShort(f, blocLevel, \"CMosaicDoc\");\n\n\tif(!checkMosTag2(f, blocLevel, \"CMosaicDoc\"))\n\t\treturn false;\n\n\tPhFileTool::readShort(f, blocLevel, \"CDocProjet\");\n\tPhFileTool::readShort(f, blocLevel, \"CDocProjet\");\n\n\tif(!checkMosTag2(f, blocLevel, \"CDocProjet\"))\n\t\treturn false;\n\n\tPhFileTool::readShort(f, blocLevel, \"CDocProprietes\");\n\tPhFileTool::readShort(f, blocLevel, \"CDocProprietes\");\n\n\tif(!checkMosTag2(f, blocLevel, \"CDocProprietes\"))\n\t\treturn false;\n\n\treadMosProperties(f, propLevel);\n\n\tPhFileTool::readShort(f, blocLevel, \"CDocOptionsProjet\");\n\n\t// read a number that makes a difference wether it's 3 or 4 later\n\tunsigned short mosVersion = PhFileTool::readShort(f, blocLevel, \"CDocOptionsProjet mosVersion\");\n\n\n\tif(!checkMosTag2(f, blocLevel, \"CDocOptionsProjet\"))\n\t\treturn false;\n\n\tunsigned short type = PhFileTool::readInt(f, level, \"type\");\n\tbool drop = PhFileTool::readInt(f, level, \"drop\") != 0;\n\tswitch(type) {\n\tcase 0:\n\t\tif(drop)\n\t\t\t_tcType = PhTimeCodeType2398;\n\t\telse\n\t\t\t_tcType = PhTimeCodeType24;\n\t\tbreak;\n\tdefault:\n\t\t_tcType = PhTimeCodeType25;\n\t\tbreak;\n\t}\n\tPHDBG(ok) << \"TC Type:\" << _tcType;\n\n\n\tif(mosVersion == 4) {\n\t\t//\t\tqDebug() << \"reading extrasection ???\";\n\t\t//\t\tPhFileTool::readInt(f, logLevel, \"loop continuous numbering\");\n\t\tPhFileTool::readShort(f, level);\n\t\tPhFileTool::readShort(f, level);\n\t}\n\n\tfor(int j = 0; j < 8; j++)\n\t\tPhFileTool::readShort(f, level);\n\n\tPhFileTool::readInt(f, blocLevel, \"CDocFilm count\");\n\tPhFileTool::readShort(f, blocLevel, \"CDocFilm\");\n\tPhFileTool::readShort(f, blocLevel, \"CDocFilm\");\n\n\tif(!checkMosTag2(f, blocLevel, \"CDocFilm\"))\n\t\treturn false;\n\n\tunsigned short peopleCount = PhFileTool::readInt(f, blocLevel, \"CDocPersonnage count\");\n\n\tPhFileTool::readShort(f, blocLevel, \"CDocPersonnage\");\n\tint peopleType = PhFileTool::readShort(f, blocLevel, \"CDocPersonnage\");\n\n\tif(!checkMosTag2(f, blocLevel, \"CDocPersonnage\"))\n\t\treturn false;\n\n\tQMap<int, PhPeople*> peopleMap;\n\tQMap<int, int> peopleTrackMap;\n\tfor(int i = 0; i < peopleCount; i++) {\n\t\tif(i > 0)\n\t\t\tPhFileTool::readShort(f, level, \"people tag\");\n\n\t\tint peopleId = PhFileTool::readInt(f, peopleLevel, \"peopleId\");\n\n\t\tQString name = PhFileTool::readString(f, peopleLevel, \"people name\");\n\t\tPhPeople *people = new PhPeople(name, \"#000000\");\n\t\tpeopleMap[peopleId] = people;\n\t\t_peoples.append(people);\n\n\t\tpeopleTrackMap[peopleId] = PhFileTool::readInt(f, peopleLevel, \"people track\") - 1;\n\t\tfor(int j = 0; j < 6; j++)\n\t\t\tPhFileTool::readShort(f, level);\n\n\n\t\tif(peopleType == 2)\n\t\t\tPhFileTool::readString(f, peopleLevel, \"date 1\");\n\t}\n\n\tint peopleCount2 = PhFileTool::readInt(f, blocLevel, \"people count 2\");\n\tif(peopleCount2 != peopleCount) {\n\t\tPHDEBUG << \"people count not corresponding:\" << peopleCount << \"/\" << peopleCount2;\n\t\t//\t\treturn false;\n\t}\n\tPhFileTool::readShort(f, blocLevel, \"CDocVideo\");\n\tunsigned short videoType = PhFileTool::readShort(f, blocLevel, \"CDocVideo\");\n\n\tif(!checkMosTag2(f, blocLevel, \"CDocVideo\"))\n\t\treturn false;\n\n\tthis->setVideoFilePath(PhFileTool::readString(f, ok, \"Video path\"));\n\tthis->setVideoTimeIn(readMosTime(f, _tcType, internLevel));\n\tPHDBG(ok) << \"Timestamp:\" << PhTimeCode::stringFromTime(_videoTimeIn, _tcType);\n\n\tif(videoType == 3) {\n\t\tPhFileTool::readShort(f, level, \"videoType3\");\n\t\tPhFileTool::readShort(f, level, \"videoType3\");\n\t}\n\n\tPhFileTool::readShort(f, level);\n\tPhFileTool::readShort(f, level);\n\n\tunsigned short cutCount = PhFileTool::readInt(f, blocLevel, \"cut count\");\n\tif(cutCount) {\n\t\tif(!checkMosTag(f, blocLevel, MosCut))\n\t\t\treturn false;\n\n\t\tfor(int j = 0; j < cutCount; j++) {\n\t\t\tif((j > 0) && !checkMosTag(f, level, MosCut))\n\t\t\t\treturn false;\n\t\t\tPhTime cutTime = _videoTimeIn + readMosTime(f, _tcType, internLevel);\n\t\t\tPHDBG(cutLevel) << \"cut:\" << PhTimeCode::stringFromTime(cutTime, _tcType);\n\t\t\t_cuts.append(new PhStripCut(PhStripCut::Simple, cutTime));\n\t\t}\n\t}\n\n\tQString script = PhFileTool::readString(f, ok, \"script\");\n\n\tPhFileTool::readInt(f, blocLevel, \"dub count\");\n\tif(!checkMosTag(f, blocLevel, MosDub))\n\t\treturn false;\n\n\tfor(int j = 0; j < 8; j++)\n\t\tPhFileTool::readShort(f, level, \"CDocDoublage\");\n\n\tint trackCount = PhFileTool::readInt(f, blocLevel, \"track count\");\n\tif(!checkMosTag(f, blocLevel, MosTrack))\n\t\treturn false;\n\n\tfor(int track = 0; track < trackCount; track++) {\n\t\tPHDBG(level) << \"====== READING TRACK \" << track << \"======\";\n\t\tif((track > 0) && !checkMosTag(f, level, MosTrack))\n\t\t\treturn false;\n\t\tif(!readMosTrack(f, peopleMap, peopleTrackMap, blocLevel, textLevel, detectLevel, labelLevel, level, internLevel))\n\t\t\treturn false;\n\t}\n\n\tPHDBG(level) << \"====== END OF TRACK ======\";\n\n\tfor(int k = 0; k < 2; k++) {\n\t\tint loopCount = PhFileTool::readInt(f, loopLevel, \"loop count\");\n\t\tif(loopCount == 0)\n\t\t\tcontinue;\n\t\tif(!checkMosTag(f, blocLevel, MosLoop))\n\t\t\treturn false;\n\t\tfor(int i = 0; i < loopCount; i++) {\n\t\t\tif((i > 0) && !checkMosTag(f, level, MosLoop))\n\t\t\t\treturn false;\n\t\t\tint number = PhFileTool::readInt(f, loopLevel, \"loop number\");\n\n\t\t\tPhTime loopTime = _videoTimeIn + readMosTime(f, _tcType, internLevel);;\n\t\t\tPhFileTool::readString(f, loopLevel, \"loop name\");\n\t\t\t_loops.append(new PhStripLoop(number, loopTime));\n\t\t}\n\t}\n\n\tfor(int j = 0; j < 4; j++)\n\t\tPhFileTool::readShort(f, level, \"after loop1\");\n\n\t//\tif(strangeNumber2 == 1) {\n\t//\t\tfor(int j = 0; j < 9; j++)\n\t//\t\t\tPhFileTool::readShort(f, level, \"after loop2\");\n\t//\t}\n\n//\tif(!checkMosTag(f, blocLevel, MosBin))\n//\t\treturn false;\n\n//\tfor(int j = 0; j < 2; j++)\n//\t\tPhFileTool::readShort(f, level);\n\n\tPHDEBUG << \"_______________\" << \"reading ok\" << \"_______________\";\n\n\tf.close();\n\n\tif((_texts1.count() == 0) && (_texts2.count())) {\n\t\tPHDEBUG << \"Switching primary and secondary text lists\";\n\t\t_texts1.append(_texts2);\n\t\t_texts2.clear();\n\t}\n\n\tqSort(_texts1.begin(), _texts1.end(), PhStripObject::dtcomp);\n\tqSort(_texts2.begin(), _texts2.end(), PhStripObject::dtcomp);\n\tqSort(_detects.begin(), _detects.end(), PhStripObject::dtcomp);\n\tqSort(_cuts.begin(), _cuts.end(), PhStripObject::dtcomp);\n\tqSort(_loops.begin(), _loops.end(), PhStripObject::dtcomp);\n\n\temit this->changed();\n\n\treturn true;\n}\n\nbool PhStripDoc::openStripFile(const QString &fileName)\n{\n\tPHDEBUG << fileName;\n\tbool result = false;\n\n\tQString extension = QFileInfo(fileName).suffix();\n\t// Try to open the document\n\tif(extension == \"detx\") {\n\t\treturn importDetXFile(fileName);\n\t}\n\telse if(extension == \"mos\") {\n\t\treturn importMosFile(fileName);\n\t}\n\telse if(extension == \"strip\" or extension == \"joker\") {\n\t\tQFile xmlFile(fileName);\n\t\tif(!xmlFile.open(QIODevice::ReadOnly)) {\n\t\t\tPHDEBUG << \"Unable to open\" << fileName << xmlFile.errorString();\n\t\t\treturn false;\n\t\t}\n\n\t\t// Loading the DOM\n\t\tQDomDocument *domDoc = new QDomDocument();\n\t\tif (!domDoc->setContent(&xmlFile)) {\n\t\t\txmlFile.close();\n\t\t\tPHDEBUG << \"The XML document seems to be bad formed\" << fileName;\n\t\t\treturn false;\n\t\t}\n\t\txmlFile.close();\n\n\t\tPHDEBUG << (\"Start parsing \" + fileName);\n\t\tQDomElement stripDocument = domDoc->documentElement();\n\n\t\tif(stripDocument.tagName() != \"strip\" && stripDocument.tagName() != \"joker\") {\n\t\t\tPHDEBUG << \"Bad root element :\" << stripDocument.tagName();\n\t\t\treturn false;\n\t\t}\n\n\t\tresult = true;\n\n\t\t// Reading the media nodes\n\t\tQDomNodeList mediaList = stripDocument.elementsByTagName(\"media\");\n\t\tfor(int i = 0; i < mediaList.count(); i++) {\n\t\t\tQDomElement media = mediaList.at(i).toElement();\n\t\t\tQString type = media.attribute(\"type\");\n\t\t\tPHDEBUG << \"line\" << type;\n\t\t\tif(type == \"detx\")\n\t\t\t\tresult = importDetXFile(media.text());\n\t\t\telse if(type == \"mos\")\n\t\t\t\tresult = importMosFile(media.text());\n\t\t\telse if(type == \"video\") {\n\t\t\t\t_videoPath = media.text();\n\t\t\t\t_videoTimeIn = PhTimeCode::timeFromString(media.attribute(\"tcStamp\"), _tcType);\n\n\t\t\t\t_videoForceRatio169 = media.attribute(\"forceRatio\").toLower() == \"yes\";\n\t\t\t\t_videoDeinterlace = media.attribute(\"deinterlace\").toLower() == \"yes\";\n\t\t\t}\n\t\t}\n\n\t\tif(stripDocument.elementsByTagName(\"state\").count()) {\n\t\t\tQDomElement state = stripDocument.elementsByTagName(\"state\").at(0).toElement();\n\t\t\t_lastTime = PhTimeCode::timeFromString(state.attribute(\"lastTimeCode\"), _tcType);\n\t\t}\n\t}\n\treturn result;\n}\n\nbool PhStripDoc::saveStripFile(const QString &fileName, const QString &lastTC)\n{\n\tPHDEBUG << fileName;\n\tQFile file(fileName);\n\n\t// open a file\n\tif (!file.open(QIODevice::WriteOnly)) {\n\t\tPHDEBUG << \"an error occur while saving the strip document\";\n\t\treturn false;\n\t}\n\telse {\n\t\t//if file is successfully opened then create XML\n\t\tQXmlStreamWriter* xmlWriter = new QXmlStreamWriter();\n\t\t// set device (here file)to streamwriter\n\t\txmlWriter->setDevice(&file);\n\t\t// Writes a document start with the XML version number version.\n\n\t\t// Positive numbers indicate spaces, negative numbers tabs.\n\t\txmlWriter->setAutoFormattingIndent(-1);\n\t\txmlWriter->setAutoFormatting(true);\n\n\t\t// Indent is just for keeping in mind XML structure\n\t\txmlWriter->writeStartDocument();\n\t\txmlWriter->writeStartElement(\"joker\");\n\t\t{\n\t\t\txmlWriter->writeStartElement(\"meta\");\n\t\t\t{\n\t\t\t\txmlWriter->writeStartElement(\"generator\");\n\t\t\t\txmlWriter->writeAttribute(\"name\", \"Joker\");\n#ifdef APP_VERSION\n\t\t\t\txmlWriter->writeAttribute(\"version\", APP_VERSION);\n#endif\n\t\t\t\txmlWriter->writeEndElement();\n\n\t\t\t\tif(_filePath.length() > 0) {\n\t\t\t\t\tQFileInfo info(_filePath);\n\t\t\t\t\txmlWriter->writeStartElement(\"media\");\n\t\t\t\t\txmlWriter->writeAttribute(\"type\", info.suffix());\n\t\t\t\t\txmlWriter->writeCharacters(filePath());\n\t\t\t\t\txmlWriter->writeEndElement();\n\t\t\t\t}\n\n\t\t\t\txmlWriter->writeStartElement(\"media\");\n\t\t\t\txmlWriter->writeAttribute(\"type\", \"video\");\n\t\t\t\txmlWriter->writeAttribute(\"tcStamp\", PhTimeCode::stringFromTime(_videoTimeIn, _tcType));\n\t\t\t\tif(_videoForceRatio169)\n\t\t\t\t\txmlWriter->writeAttribute(\"forceRatio\", \"yes\");\n\t\t\t\tif(_videoDeinterlace)\n\t\t\t\t\txmlWriter->writeAttribute(\"deinterlace\", \"yes\");\n\t\t\t\txmlWriter->writeCharacters(_videoPath);\n\t\t\t\txmlWriter->writeEndElement();\n\n\t\t\t\txmlWriter->writeStartElement(\"state\");\n\t\t\t\txmlWriter->writeAttribute(\"lastTimeCode\", lastTC);\n\t\t\t\txmlWriter->writeEndElement();\n\t\t\t}\n\t\t\txmlWriter->writeEndElement();\n\t\t}\n\t\txmlWriter->writeEndElement();\n\n\t\txmlWriter->writeEndDocument();\n\t\tdelete xmlWriter;\n\t}\n\n\treturn true;\n}\n\nvoid PhStripDoc::generate(QString content, int loopCount, int peopleCount, PhTime spaceBetweenText, int textCount, int trackCount, PhTime videoTimeIn)\n{\n\tthis->reset();\n\t_title = \"Generate file\";\n\t_translatedTitle = \"Fichier g\u00e9n\u00e9r\u00e9\";\n\t_episode = \"1\";\n\t_season = \"1\";\n\t_tcType = PhTimeCodeType25;\n\t_videoTimeIn = videoTimeIn;\n\t_lastTime = _videoTimeIn;\n\n\tif (trackCount > 4 || trackCount < 1)\n\t\ttrackCount = 3;\n\n\tQStringList names;\n\tnames.append(\"Actor\");\n\tnames.append(\"Actress\");\n\tnames.append(\"Jack\");\n\tnames.append(\"Jane\");\n\n\tint nbNames = names.length();\n\t// Creation of the Peoples\n\tfor (int i = 1; i <= peopleCount; i++) {\n\t\tPhPeople *people = new PhPeople(names.at(i % nbNames) + \" \" + QString::number(i), \"black\");\n\t\t_peoples.append(people);\n\t}\n\n\tPhTime time = _videoTimeIn;\n\t// Creation of the text\n\tfor (int i = 0; i < textCount; i++) {\n\t\t//Make people \"talk\" alternaly\n\t\tPhPeople *people = _peoples[i % peopleCount];\n\n\t\tPhTime timeIn = time;\n\t\tPhTime timeOut = timeIn + content.length() * 1000;\n\n\t\t_texts1.append(new PhStripText(timeIn, people, timeOut, i % trackCount, content));\n\n\t\t// So the texts are all one after the other\n\t\ttime += spaceBetweenText;\n\t}\n\n\t// Add a loop per minute\n\tfor(int i = 0; i < loopCount; i++)\n\t\t_loops.append(new PhStripLoop(i, _videoTimeIn + i * 24000 * 60));\n\n\temit changed();\n}\n\nvoid PhStripDoc::reset()\n{\n\t_peoples.clear();\n\t_cuts.clear();\n\t_detects.clear();\n\t_tcType = PhTimeCodeType25;\n\t_lastTime = 0;\n\t_loops.clear();\n\t_texts1.clear();\n\t_texts2.clear();\n\t_title = \"\";\n\t_translatedTitle = \"\";\n\t_episode = \"\";\n\t_season = \"\";\n\t_videoPath = \"\";\n\t_videoTimeIn = 0;\n\t_videoDeinterlace = false;\n\t_authorName = \"\";\n\t_videoForceRatio169 = false;\n\t_generator = \"\";\n\t_mosNextTag = 0x8008;\n\n\temit this->changed();\n}\n\nvoid PhStripDoc::addObject(PhStripObject *object)\n{\n\tif(dynamic_cast<PhStripCut*>(object)) {\n\t\tthis->_cuts.append(dynamic_cast<PhStripCut*>(object));\n\t\tPHDEBUG << \"Added a cut\";\n\t}\n\telse if(dynamic_cast<PhStripLoop*>(object)) {\n\t\tthis->_loops.append(dynamic_cast<PhStripLoop*>(object));\n\t\tPHDEBUG << \"Added a loop\";\n\t}\n\telse if(dynamic_cast<PhStripDetect*>(object)) {\n\t\tthis->_detects.append(dynamic_cast<PhStripDetect*>(object));\n\t\tPHDEBUG << \"Added a detect!\";\n\t}\n\telse if(dynamic_cast<PhStripText*>(object)) {\n\t\tthis->_texts1.append(dynamic_cast<PhStripText*>(object));\n\t\tPHDEBUG << \"Added a text!\";\n\t}\n\telse {\n\t\tPHDEBUG << \"You try to add a weird object, which seems to be undefined...\";\n\t}\n\temit changed();\n\n}\n\nvoid PhStripDoc::addPeople(PhPeople *people)\n{\n\tthis->_peoples.append(people);\n\tPHDEBUG << \"Added a people\";\n\temit changed();\n\n}\n\nbool PhStripDoc::forceRatio169() const\n{\n\treturn _videoForceRatio169;\n}\n\nPhPeople *PhStripDoc::peopleByName(QString name)\n{\n\tforeach(PhPeople* people, _peoples)\n\t{\n\t\tif(people && people->name() == name)\n\t\t\treturn people;\n\t}\n\treturn NULL;\n}\n\nPhStripText *PhStripDoc::nextText(PhTime time)\n{\n\tPhStripText * result = NULL;\n\tforeach(PhStripText* text, this->texts())\n\t{\n\t\tif(text->timeIn() > time) {\n\t\t\tif(!result || (text->timeIn() < result->timeIn()) )\n\t\t\t\tresult = text;\n\t\t}\n\t}\n\treturn result;\n}\n\nPhStripText *PhStripDoc::nextText(PhPeople *people, PhTime time)\n{\n\tPhStripText * result = NULL;\n\tforeach(PhStripText* text, this->texts())\n\t{\n\t\tif((text->people() == people) && (text->timeIn() > time)) {\n\t\t\tif(!result || (text->timeIn() < result->timeIn()) )\n\t\t\t\tresult = text;\n\t\t}\n\t}\n\treturn result;\n}\n\nPhStripText *PhStripDoc::nextText(QList<PhPeople *> peopleList, PhTime time)\n{\n\tPhStripText * result = NULL;\n\tforeach(PhStripText* text, this->texts())\n\t{\n\t\tif(peopleList.contains(text->people()) && (text->timeIn() > time)) {\n\t\t\tif(!result || (text->timeIn() < result->timeIn()) )\n\t\t\t\tresult = text;\n\t\t}\n\t}\n\treturn result;\n}\n\nPhTime PhStripDoc::previousTextTime(PhTime time)\n{\n\tPhTime previousTextTime = PHTIMEMIN;\n\n\tforeach(PhStripText* text, this->texts())\n\t{\n\t\tif((text->timeIn() < time) && (text->timeIn() > previousTextTime) )\n\t\t\tpreviousTextTime = text->timeIn();\n\t}\n\n\treturn previousTextTime;\n}\n\nPhTime PhStripDoc::previousLoopTime(PhTime time)\n{\n\tPhTime previousLoopTime = PHTIMEMIN;\n\n\tforeach(PhStripLoop* loop, _loops)\n\t{\n\t\tif((loop->timeIn() < time) && (loop->timeIn() > previousLoopTime) )\n\t\t\tpreviousLoopTime = loop->timeIn();\n\t}\n\n\treturn previousLoopTime;\n}\n\nPhTime PhStripDoc::previousCutTime(PhTime time)\n{\n\tPhTime previousCutTime = PHTIMEMIN;\n\n\tforeach(PhStripCut* cut, _cuts)\n\t{\n\t\tif((cut->timeIn() < time) && (cut->timeIn() > previousCutTime) )\n\t\t\tpreviousCutTime = cut->timeIn();\n\t}\n\n\treturn previousCutTime;\n}\n\nPhTime PhStripDoc::previousElementTime(PhTime time)\n{\n\tPhTime previousElementTime = previousCutTime(time);\n\n\tif(previousLoopTime(time) > previousElementTime)\n\t\tpreviousElementTime = previousLoopTime(time);\n\n\tif(previousTextTime(time) > previousElementTime)\n\t\tpreviousElementTime = previousTextTime(time);\n\n\treturn previousElementTime;\n}\n\nPhTime PhStripDoc::nextTextTime(PhTime time)\n{\n\tPhTime nextTextTime = PHTIMEMAX;\n\n\tforeach(PhStripText* text, this->texts())\n\t{\n\t\tif((text->timeIn() > time) && (text->timeIn() < nextTextTime) )\n\t\t\tnextTextTime = text->timeIn();\n\t\telse if(text->timeIn() > nextTextTime)\n\t\t\treturn nextTextTime;\n\t}\n\n\treturn nextTextTime;\n}\n\nPhTime PhStripDoc::nextLoopTime(PhTime time)\n{\n\tPhTime nextLoopTime = PHTIMEMAX;\n\n\tforeach(PhStripLoop* loop, _loops)\n\t{\n\t\tif((loop->timeIn() > time) && (loop->timeIn() < nextLoopTime) )\n\t\t\tnextLoopTime = loop->timeIn();\n\t\telse if(loop->timeIn() > nextLoopTime)\n\t\t\treturn nextLoopTime;\n\t}\n\n\treturn nextLoopTime;\n}\n\nPhTime PhStripDoc::nextCutTime(PhTime time)\n{\n\tPhTime nextCutTime = PHTIMEMAX;\n\n\tforeach(PhStripCut* cut, _cuts)\n\t{\n\t\tif((cut->timeIn() > time) && (cut->timeIn() < nextCutTime) )\n\t\t\tnextCutTime = cut->timeIn();\n\t\telse if(cut->timeIn() > nextCutTime)\n\t\t\treturn nextCutTime;\n\t}\n\n\treturn nextCutTime;\n}\n\nPhTime PhStripDoc::nextElementTime(PhTime time)\n{\n\tPhTime nextElementTime = nextCutTime(time);\n\n\tif(nextLoopTime(time) < nextElementTime)\n\t\tnextElementTime = nextLoopTime(time);\n\n\tif(nextTextTime(time) < nextElementTime)\n\t\tnextElementTime = nextTextTime(time);\n\n\treturn nextElementTime;\n}\n\nPhTime PhStripDoc::timeIn()\n{\n\treturn nextElementTime(0);\n}\n\nPhTime PhStripDoc::timeOut()\n{\n\treturn previousElementTime(PHTIMEMAX);\n}\n\nPhStripLoop *PhStripDoc::nextLoop(PhTime time)\n{\n\tforeach(PhStripLoop* loop, _loops)\n\t{\n\t\tif(loop->timeIn() > time)\n\t\t\treturn loop;\n\t}\n\treturn NULL;\n}\n\nPhStripLoop *PhStripDoc::previousLoop(PhTime time)\n{\n\tint i = _loops.count() - 1;\n\twhile(i >= 0) {\n\t\tif(_loops.at(i)->timeIn() < time)\n\t\t\treturn _loops.at(i);\n\t\ti--;\n\t}\n\treturn NULL;\n}\n\nQString PhStripDoc::filePath()\n{\n\treturn _filePath;\n}\n\nQString PhStripDoc::videoFilePath()\n{\n\treturn _videoPath;\n}\n\nQList<QString> PhStripDoc::metaKeys()\n{\n\treturn _metaInformation.keys();\n}\n\nQString PhStripDoc::metaInformation(QString key)\n{\n\treturn _metaInformation[key];\n}\n\nPhTimeCodeType PhStripDoc::timeCodeType()\n{\n\treturn _tcType;\n}\n\nQList<PhPeople *> PhStripDoc::peoples()\n{\n\treturn _peoples;\n}\n\nQString PhStripDoc::title()\n{\n\treturn _title;\n}\n\nQString PhStripDoc::translatedTitle()\n{\n\treturn _translatedTitle;\n}\n\nQString PhStripDoc::episode()\n{\n\treturn _episode;\n}\n\nQString PhStripDoc::season()\n{\n\treturn _season;\n}\n\nPhTime PhStripDoc::videoTimeIn()\n{\n\treturn _videoTimeIn;\n}\n\nPhTime PhStripDoc::videoFrameIn()\n{\n\treturn _videoTimeIn / PhTimeCode::timePerFrame(_tcType);\n}\n\nPhTime PhStripDoc::lastTime()\n{\n\treturn _lastTime;\n}\n\nQList<PhStripText *> PhStripDoc::texts(bool alternate)\n{\n\tif(alternate)\n\t\treturn _texts2;\n\telse\n\t\treturn _texts1;\n}\n\nQList<PhStripText *> PhStripDoc::texts(PhPeople *people)\n{\n\tQList<PhStripText*> result;\n\tforeach(PhStripText *text, this->texts()) {\n\t\tif(text->people() == people)\n\t\t\tresult.append(text);\n\t}\n\treturn result;\n}\n\nQList<PhStripLoop *> PhStripDoc::loops()\n{\n\treturn _loops;\n}\n\nQList<PhStripDetect *> PhStripDoc::detects(PhTime timeIn, PhTime timeOut)\n{\n\tQList<PhStripDetect*> result;\n\tforeach(PhStripDetect *detect, this->_detects) {\n\t\tif((detect->timeIn() >= timeIn) && (detect->timeOut() < timeOut))\n\t\t\tresult.append(detect);\n\t}\n\n\treturn result;\n}\n\nQList<PhStripDetect *> PhStripDoc::peopleDetects(PhPeople *people, PhTime timeIn, PhTime timeOut)\n{\n\tQList<PhStripDetect *> result;\n\tforeach(PhStripDetect *detect, this->detects(timeIn, timeOut)) {\n\t\tif(detect->people() == people)\n\t\t\tresult.append(detect);\n\t}\n\treturn result;\n}\n\nvoid PhStripDoc::setTitle(QString title)\n{\n\t_title = title;\n}\n\nvoid PhStripDoc::setVideoTimeIn(PhTime time)\n{\n\t_videoTimeIn = time;\n}\n\nvoid PhStripDoc::setVideoFrameIn(PhFrame frame)\n{\n\t_videoTimeIn = frame * PhTimeCode::timePerFrame(_tcType);\n}\n\nvoid PhStripDoc::setVideoFilePath(QString videoFilePath)\n{\n\t_videoPath = videoFilePath;\n}\n\nQList<PhStripCut *> PhStripDoc::cuts()\n{\n\treturn _cuts;\n}\n\n", "name": "libs/PhStrip/PhStripDoc.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef PHSTRIPDOC_H\n#define PHSTRIPDOC_H\n\n#include <QList>\n#include <QMap>\n#include <QFile>\n\n#include \"PhTools/PhTimeCode.h\"\n\n#include \"PhPeople.h\"\n#include \"PhStripCut.h\"\n#include \"PhStripLoop.h\"\n#include \"PhStripObject.h\"\n#include \"PhStripText.h\"\n#include \"PhStripDetect.h\"\n\n/**\n * @brief The joker document class\n *\n * It contains the script file with all the informations\n * such as the title, the authors, the characters (PhPeople), the lines,\n * the attach video file...\n */\nclass PhStripDoc : public QObject\n{\n\tQ_OBJECT\n\npublic:\n\t/**\n\t * @brief PhStripDoc constructor\n\t */\n\texplicit PhStripDoc(QObject *parent = 0);\n\n\t/**\n\t * @brief The name of the application that generated the document\n\t * @return A string\n\t */\n\tQString generator() {\n\t\treturn _generator;\n\t}\n\t/**\n\t * @brief The title\n\t * @return A string\n\t */\n\tQString title();\n\n\t/**\n\t * @brief The translated title\n\t * @return A string\n\t */\n\tQString translatedTitle();\n\t/**\n\t * @brief Get the episode\n\t * @return A string\n\t */\n\tQString episode();\n\t/**\n\t * @brief Get the season\n\t * @return A string\n\t */\n\tQString season();\n\n\t/**\n\t * @brief The video starting time\n\t * @return A time value\n\t */\n\tPhTime videoTimeIn();\n\n\t/**\n\t * @brief The video starting frame\n\t * @return A frame value\n\t */\n\tPhTime videoFrameIn();\n\n\t/**\n\t * @brief getFilePath\n\t * @return _filePath\n\t */\n\tQString filePath();\n\n\t/**\n\t * @brief getVideoPath\n\t * @return _videoPath\n\t */\n\tQString videoFilePath();\n\n\t/**\n\t * @brief Check if video shall be deinterlace\n\t * @return True if deinterlace false otherwise\n\t */\n\tbool videoDeinterlace() {\n\t\treturn _videoDeinterlace;\n\t}\n\n\t/**\n\t * @brief Get the author name\n\t * @return\n\t */\n\tQString authorName() {\n\t\treturn _authorName;\n\t}\n\n\t/**\n\t * @brief Get the list of meta information key\n\t * @return A string list\n\t */\n\tQList<QString> metaKeys();\n\n\t/**\n\t * @brief Get the meta information of a given key\n\t * @param key The meta information key\n\t * @return The meta information value\n\t */\n\tQString metaInformation(QString key);\n\n\t/**\n\t * @brief The document ending time\n\t * @return A time value.\n\t */\n\tPhTime timeOut();\n\n\t/**\n\t * @brief getTimeScale\n\t * @return\n\t */\n\tint timeScale();\n\n\t/**\n\t * @brief The timecode type\n\t * @return A PhTimeCodeType value\n\t */\n\tPhTimeCodeType timeCodeType();\n\n\t/**\n\t * @brief The list of peoples\n\t * @return A list.\n\t */\n\tQList<PhPeople *> peoples();\n\t/**\n\t * @brief The whole text list\n\t * @return A list of texts\n\t */\n\tQList<PhStripText *> texts(bool alternate = false);\n\n\t/**\n\t * @brief The list of texts affected to a people\n\t * @param people A people\n\t * @return A list of texts\n\t */\n\tQList<PhStripText *> texts(PhPeople *people);\n\n\t/**\n\t * @brief The whole loop list\n\t * @return A list of loops\n\t */\n\tQList<PhStripLoop *> loops();\n\n\t/**\n\t * @brief The whole cut list\n\t * @return A list of cut\n\t */\n\tQList<PhStripCut *> cuts();\n\n\t/**\n\t * @brief The whole detect list\n\t * @todo Implement and test timeIn / timeOut\n\t * @return A list of detects\n\t */\n\tQList<PhStripDetect *> detects(PhTime timeIn = PHTIMEMIN, PhTime timeOut = PHTIMEMAX);\n\n\t/**\n\t * @brief Get the list of detect affected to a people in a defined range.\n\t * @param people The people\n\t * @param timeIn The range starting time\n\t * @param timeOut The range ending time\n\t * @return A list of detects\n\t */\n\tQList<PhStripDetect *> peopleDetects(PhPeople *people, PhTime timeIn = PHTIMEMIN, PhTime timeOut = PHTIMEMAX);\n\n\t/**\n\t * @brief Set the title property\n\t * @param title A string\n\t */\n\tvoid setTitle(QString title);\n\t/**\n\t * @brief Set the video starting time\n\t * @param time A time value\n\t */\n\tvoid setVideoTimeIn(PhTime time);\n\t/**\n\t * @brief Set the video starting frame\n\t * @param frame A frame value\n\t */\n\tvoid setVideoFrameIn(PhFrame frame);\n\t/**\n\t * @brief Set the video file path\n\t * @param videoFilePath A string\n\t */\n\tvoid setVideoFilePath(QString videoFilePath);\n\n\t/**\n\t * @brief Set the video deinterlace mode\n\t * @param deinterlace True if deinterlace false otherwise\n\t */\n\tvoid setVideoDeinterlace(bool deinterlace) {\n\t\t_videoDeinterlace = deinterlace;\n\t}\n\n\t/**\n\t * @brief setTimeScale\n\t * @param timeScale\n\t */\n\tvoid setTimeScale(int timeScale);\n\t/**\n\t * @brief Import a DetX file\n\t * @param fileName The path to the DetX file\n\t * @return True if the doc opened well, false otherwise\n\t */\n\tbool importDetXFile(QString fileName);\n\t/**\n\t * @brief Import a Mos file\n\t * @param fileName The path to the Mos file\n\t * @return True if the doc opened well, false otherwise\n\t */\n\tbool importMosFile(const QString &fileName);\n\t/**\n\t * @brief Open a strip file\n\t * @param fileName The path to the DetX file\n\t * @return True if the strip opened well, false otherwise\n\t */\n\tbool openStripFile(const QString &fileName);\n\t/**\n\t * @brief Save the PhStripDoc to a strip file\n\t * @param fileName Path to the stripfile\n\t * @param lastTC The last displayed timecode\n\t * @return True if the strip saved well, false otherwise\n\t */\n\tbool saveStripFile(const QString &fileName, const QString &lastTC);\n\t/**\n\t * @brief Generate a document from given value\n\t * @param text The desired text\n\t * @param loopCount The number of loops\n\t * @param peopleCount The desired number of actors\n\t * @param spaceBetweenText Time between two texts\n\t * @param textCount The desired number of sentences\n\t * @param trackCount The desired number of tracks\n\t * @param videoTimeIn The starting time of the document\n\t */\n\tvoid generate(QString text, int loopCount, int peopleCount, PhTime spaceBetweenText, int textCount, int trackCount, PhTime videoTimeIn);\n\n\t/**\n\t * @brief Get people by their name\n\t * @param name The desired people's name\n\t * @return The corresponding PhPeople\n\t */\n\tPhPeople * peopleByName(QString name);\n\n\t/**\n\t * @brief Get the next text after a time value\n\t * @param time A time value\n\t * @return The next text or NULL if no text after the time value\n\t */\n\tPhStripText * nextText(PhTime time);\n\n\t/**\n\t * @brief Get the next text affected to a people after a time value\n\t * @param people A people reference\n\t * @param time A time value\n\t * @return The next text or NULL if no text after the time value\n\t */\n\tPhStripText * nextText(PhPeople *people, PhTime time);\n\t/**\n\t * @brief Get the next text affected to one of a people list after a time value\n\t * @param peopleList A people list\n\t * @param time A time value\n\t * @return The first corresponding text. If two (or more) texts\n\t * have the same timeIn, the text attach to the first PhPeople of\n\t * the list will be returned\n\t */\n\tPhStripText * nextText(QList<PhPeople*> peopleList, PhTime time);\n\t/**\n\t * @brief Get the previous text before a time value\n\t * @param time A time value\n\t * @return A time value\n\t */\n\tPhTime previousTextTime(PhTime time);\n\t/**\n\t * @brief Get the previous loop time\n\t * @param time A time value\n\t * @return A time value\n\t */\n\tPhTime previousLoopTime(PhTime time);\n\t/**\n\t * @brief Get the previous cut time\n\t * @param time A time value\n\t * @return A time value\n\t */\n\tPhTime previousCutTime(PhTime time);\n\t/**\n\t * @brief Get previous element time\n\t * @param time A time value\n\t * @return A time value\n\t */\n\tPhTime previousElementTime(PhTime time);\n\t/**\n\t * @brief Get the next text time\n\t * @param time A time value\n\t * @return A time value\n\t */\n\tPhTime nextTextTime(PhTime time);\n\t/**\n\t * @brief Get the next loop time\n\t * @param time A time value\n\t * @return A time value\n\t */\n\tPhTime nextLoopTime(PhTime time);\n\t/**\n\t * @brief Get the next cut time\n\t * @param time A time value\n\t * @return A time value\n\t */\n\tPhTime nextCutTime(PhTime time);\n\t/**\n\t * @brief Get the next element time\n\t * @param time A time value\n\t * @return A time value\n\t */\n\tPhTime nextElementTime(PhTime time);\n\t/**\n\t * @brief Get the starting time of the document\n\t * @return time A time value\n\t */\n\tPhTime timeIn();\n\t/**\n\t * @brief Get the last position the document was edited.\n\t * @return time A time value\n\t */\n\tPhTime lastTime();\n\t/*!\n\t * \\brief Get the force ratio information\n\t * \\return if the ratio is forced or not\n\t */\n\tbool forceRatio169() const;\n\n\t/**\n\t * @brief Get the next loop\n\t * @param time A time value\n\t * @return the corresponding loop\n\t */\n\tPhStripLoop * nextLoop(PhTime time);\n\t/**\n\t * @brief Get the previous loop\n\t * @param time A time value\n\t * @return the corresponding loop\n\t */\n\tPhStripLoop * previousLoop(PhTime time);\n\n\t/**\n\t * @brief Reset the document\n\t */\n\tvoid reset();\n\n\t/**\n\t * @brief Add a PhGraphicObjet to the doc\n\t */\n\tvoid addObject(PhStripObject *object);\n\t/**\n\t * @brief Add a PhPeople to the doc\n\t * @param people the new poeple\n\t */\n\tvoid addPeople(PhPeople * people);\n\nsignals:\n\t/**\n\t * @brief Emit a signal when the PhStripDoc changed\n\t */\n\tvoid changed();\n\nprivate:\n\n\n\tQString _generator;\n\t/**\n\t * Title of the corresponding audiovisual content.\n\t */\n\tQString _title;\n\tQString _translatedTitle;\n\tQString _episode;\n\tQString _season;\n\tQMap<QString, QString> _metaInformation;\n\n\t/**\n\t * Starting time of the video content refered by the videoPath\n\t */\n\tPhTime _videoTimeIn;\n\t/**\n\t * @brief The last position the document was edited.\n\t */\n\tPhTime _lastTime;\n\n\t/**\n\t * Path to the file content.\n\t */\n\tQString _filePath;\n\n\t/**\n\t * Path to the video content.\n\t */\n\tQString _videoPath;\n\tbool _videoDeinterlace;\n\n\tPhTimeCodeType _tcType;\n\n\tQString _authorName;\n\n\t/**\n\t * List of PhPeople from the file\n\t */\n\tQList<PhPeople *> _peoples;\n\n\tQList<PhStripText *> _texts1, _texts2;\n\n\t/**\n\t * List of PhStripCut form the file\n\t */\n\tQList<PhStripCut *> _cuts;\n\n\t/**\n\t * List of PhStripLoop from the file\n\t */\n\tQList<PhStripLoop *> _loops;\n\n\t/**\n\t * List of PhStripOff from the file\n\t */\n\tQList<PhStripDetect *> _detects;\n\n\tenum MosTag {\n\t\tMosUnknown,\n\t\tMosDub,\n\t\tMosTrack,\n\t\tMosLang,\n\t\tMosPeople,\n\t\tMosText,\n\t\tMosDetect,\n\t\tMosLabel,\n\t\tMosLoop,\n\t\tMosCut,\n\t\tMosVideo,\n\t\tMosMovie,\n\t\tMosOptions,\n\t\tMosDoc,\n\t\tMosProject,\n\t\tMosProperties,\n\t\tMosBin,\n\t};\n\tunsigned short _mosNextTag;\n\tQMap<unsigned short, MosTag> _mosTagMap;\n\n\tbool checkMosTag2(QFile &f, int level, QString expected);\n\tbool checkMosTag(QFile &f, int level, MosTag expectedTag);\n\tPhTime readMosTime(QFile &f, PhTimeCodeType tcType, int level);\n\tPhStripText *readMosText(QFile &f, int textLevel, int internLevel);\n\tPhStripDetect *readMosDetect(QFile &f, int detectLevel, int internLevel);\n\tbool readMosProperties(QFile &f, int level);\n\tMosTag readMosTag(QFile &f, int level, QString name);\n\tbool readMosTrack(QFile &f, QMap<int, PhPeople*> peopleMap, QMap<int, int> peopleTrackMap, int blocLevel, int textLevel, int detectLevel, int labelLevel, int level, int internLevel);\n\tbool _videoForceRatio169;\n};\n\n#endif // PHSTRIPDOC_H\n", "name": "libs/PhStrip/PhStripDoc.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n\n#include \"PhStripLoop.h\"\n\nPhStripLoop::PhStripLoop(int number, PhFrame frameIn) : PhStripObject(frameIn)\n{\n\t_number = number;\n}\n", "name": "libs/PhStrip/PhStripLoop.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef PHSTRIPLOOP_H\n#define PHSTRIPLOOP_H\n\n#include \"PhStripObject.h\"\n\n/**\n * @brief Indicate the start of a new loop.\n *\n * A loop is in fact a section of the rythmo strip.\n * The detection process consists to cut the video content into loops to simplify\n * the convocation of the dubbing actors for recording.\n * It is generally between 30 seconds and 1 minute long: what the actor can record in one take.\n */\nclass PhStripLoop : public PhStripObject {\n\nprivate:\n/**\n * Number of the loop. The first loop can be 1 or another value.\n * The loop numbering is usually continuous but not always.\n */\n\tint _number;\n\npublic:\n\t/**\n\t * @brief PhStripLoop constructor\n\t * @param number The loop number\n\t * @param frameIn The loop frame\n\t */\n\tPhStripLoop(int number, PhFrame frameIn);\n\n\t/**\n\t * \\brief Get the loop number\n\t * \\return the loop number\n\t */\n\tint number() {\n\t\treturn _number;\n\t}\n};\n\n\n#endif // PHSTRIPLOOP_H\n", "name": "libs/PhStrip/PhStripLoop.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n\n#include \"PhStripObject.h\"\n\nPhStripObject::PhStripObject(PhTime timeIn) : _timeIn(timeIn)\n{\n}\n\nPhTime PhStripObject::timeIn() {\n\treturn _timeIn;\n}\n\nbool PhStripObject::dtcomp(PhStripObject *a, PhStripObject *b)\n{\n\treturn a->_timeIn < b->_timeIn;\n}\n", "name": "libs/PhStrip/PhStripObject.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef PHSTRIPOBJECT_H\n#define PHSTRIPOBJECT_H\n\n#include <PhTools/PhClock.h>\n\n/**\n * @brief Generic object of a rythmo strip (loop, cut, text, ...).\n *\n * Its only property is timeIn.\n */\nclass PhStripObject {\n\nprivate:\n\t/**\n\t * Starting time of the object.\n\t */\n\tPhTime _timeIn;\npublic:\n\t/**\n\t * @brief PhStripObject constructor\n\t * @param timeIn The time in\n\t */\n\tPhStripObject(PhTime timeIn);\n\t/**\n\t * @brief ~PhStripObject\n\t */\n\tvirtual ~PhStripObject() {\n\t}\n\t/**\n\t * @brief The time in\n\t * @return A PhTime\n\t */\n\tPhTime timeIn();\n\n\t/**\n\t * @brief Compare two strip object based on the time in\n\t *\n\t * @param a A strip object\n\t * @param b Another strip object\n\t * @return True if \"a\" has a stricly lower time in than \"b\", false otherwise.\n\t */\n\tstatic bool dtcomp(PhStripObject *a, PhStripObject *b);\n};\n\n#endif // PHSTRIPOBJECT_H\n", "name": "libs/PhStrip/PhStripObject.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#include \"PhStrip/PhStripPeopleObject.h\"\n\n\nPhStripPeopleObject::PhStripPeopleObject(PhTime timeIn, PhPeople *people, PhTime timeOut, int track) : PhStripObject(timeIn),\n\t_timeOut(timeOut), _people(people), _track(track)\n{\n}\n\n\n", "name": "libs/PhStrip/PhStripPeopleObject.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef PHSTRIPPEOPLEOBJECT_H\n#define PHSTRIPPEOPLEOBJECT_H\n\n#include \"PhPeople.h\"\n#include \"PhStrip/PhStripObject.h\"\n\n/**\n * @brief A strip object affected to a PhPeople\n *\n * Its properties are people, track and timeOut.\n */\nclass PhStripPeopleObject : public PhStripObject {\n\npublic:\n\n\t/**\n\t * @brief PhStripPeopleObject constructor\n\t * @param timeIn the beggining of the PhStripPeopleObject\n\t * @param people the corresponding PhPeople\n\t * @param timeOut the end of the PhStripPeopleObject\n\t * @param track the track of the PhStripPeopleObject\n\t */\n\tPhStripPeopleObject(PhTime timeIn, PhPeople * people = NULL, PhTime timeOut = 0, int track = 0);\n\t/**\n\t * @brief Get the PhPeople\n\t * @return _people the corresponding PhPeople\n\t */\n\tPhPeople * people() {\n\t\treturn _people;\n\t}\n\t/**\n\t * @brief The object track\n\t * @return _track An integer\n\t */\n\tint track() {\n\t\treturn _track;\n\t}\n\t/**\n\t * @brief The time out\n\t * @return A time value\n\t */\n\tPhTime timeOut() {\n\t\treturn _timeOut;\n\t}\n\t/**\n\t * @brief Affect a people\n\t * @param people\n\t */\n\tvoid setPeople(PhPeople * people) {\n\t\t_people = people;\n\t}\n\t/**\n\t * @brief Set the track\n\t * @param track An integer\n\t */\n\tvoid setTrack(int track) {\n\t\t_track = track;\n\t}\n\t/**\n\t * @brief Set the time out\n\t * @param timeOut A time\n\t */\n\tvoid setTimeOut(PhTime timeOut) {\n\t\t_timeOut = timeOut;\n\t}\n\nprivate:\n/**\n * Indicate the end of the PhText. The text content is stretch between timeIn and timeOut\n */\n\tPhTime _timeOut;\n\n\t/**\n\t * Reference to the PhPeople who is affected to the PhStripPeopleObject\n\t */\n\tPhPeople *_people;\n\n\t/**\n\t * @brief _track\n\t * Track of the text, 0 is on top of the strip\n\t */\n\tint _track;\n};\n\n#endif // PHSTRIPPEOPLEOBJECT_H\n", "name": "libs/PhStrip/PhStripPeopleObject.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#include \"PhStripText.h\"\n\n\n\nPhStripText::PhStripText(PhTime timeIn, PhPeople *people, PhTime timeOut, int track, QString content) :\n\tPhStripPeopleObject(timeIn, people, timeOut, track), _content(content)\n{\n}\n\nQString PhStripText::content()\n{\n\treturn _content;\n}\n\n", "name": "libs/PhStrip/PhStripText.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef PHSTRIPTEXT_H\n#define PHSTRIPTEXT_H\n\n#include \"PhPeople.h\"\n#include \"PhStrip/PhStripPeopleObject.h\"\n\n/**\n * @brief Sentence or part of a sentence of a PhPeople with synchronization information.\n *\n * Its property is content.\n */\nclass PhStripText : public PhStripPeopleObject {\n\npublic:\n\n\t/**\n\t * @brief PhStripText constructor\n\t * @param timeIn the beggining of the text\n\t * @param people the text's speaker\n\t * @param timeOut the end of the text\n\t * @param track the track of the text\n\t * @param content the content of the text\n\t */\n\tPhStripText( PhTime timeIn, PhPeople * people, PhTime timeOut, int track,  QString content);\n\t/**\n\t * @brief Get the text content\n\t * @return _content\n\t */\n\tQString content();\n\nprivate:\n\n/**\n * Text string of Sentence or part of a sentence.\n */\n\tQString _content;\n};\n\n#endif // PHSTRIPTEXT_H\n", "name": "libs/PhStrip/PhStripText.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#include \"PhLtcReader.h\"\n\nPhLtcReader::PhLtcReader(PhTimeCodeType tcType, QObject *parent) :\n\tPhAudioInput(parent),\n\t_clock(tcType),\n\t_position(0),\n\t_noFrameCounter(0)\n{\n\t_decoder = ltc_decoder_create(1920, 1920 * 2);\n\tPHDBG(21) << \"LTC Reader created\";\n}\n\nPhClock *PhLtcReader::clock()\n{\n\treturn &_clock;\n}\n\nint PhLtcReader::processAudio(const void *inputBuffer, void *, unsigned long framesPerBuffer)\n{\n\tltc_decoder_write(_decoder, (ltcsnd_sample_t*)inputBuffer, framesPerBuffer, _position);\n\tLTCFrameExt frame;\n\tunsigned int hhmmssff[4];\n\tPhFrame oldFrame = _clock.frame();\n\twhile(ltc_decoder_read(_decoder, &frame)) {\n\t\thhmmssff[0] = frame.ltc.hours_tens * 10 + frame.ltc.hours_units;\n\t\thhmmssff[1] = frame.ltc.mins_tens * 10 + frame.ltc.mins_units;\n\t\thhmmssff[2] = frame.ltc.secs_tens * 10 + frame.ltc.secs_units;\n\t\thhmmssff[3] = frame.ltc.frame_tens * 10 + frame.ltc.frame_units;\n\n\t\tPhFrame newFrame = PhTimeCode::frameFromHhMmSsFf(hhmmssff, PhTimeCodeType25);\n\t\tPHDBG(20) << hhmmssff[0] << hhmmssff[1] << hhmmssff[2] << hhmmssff[3];\n\n\t\tif(newFrame > oldFrame)\n\t\t\t_clock.setRate(1);\n\t\telse if(newFrame < oldFrame )\n\t\t\t_clock.setRate(-1);\n\t\telse\n\t\t\t_clock.setRate(0);\n\t\t_clock.setFrame(newFrame);\n\t\t_noFrameCounter = 0;\n\t}\n\n\t_position += framesPerBuffer;\n\n\t_noFrameCounter++;\n\tif(_noFrameCounter > 20)\n\t\t_clock.setRate(0);\n\n\treturn PhAudioInput::processAudio(inputBuffer, NULL, framesPerBuffer);\n}\n", "name": "libs/PhSync/PhLtcReader.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef PHLTCREADER_H\n#define PHLTCREADER_H\n\n#include <QString>\n#include <QObject>\n#include <QTime>\n\n#include <ltc.h>\n\n#include \"PhTools/PhClock.h\"\n#include \"PhTools/PhTimeCode.h\"\n\n#include \"PhAudio/PhAudioInput.h\"\n\n/**\n * @brief A synchronisation module via the LTC protocol\n */\nclass PhLtcReader : public PhAudioInput\n{\n\n\tQ_OBJECT\n\npublic:\n\t/**\n\t * @brief PhLtcReader constructor\n\t * @param tcType the timecode type\n\t * @param parent the reader's parent\n\t */\n\texplicit PhLtcReader(PhTimeCodeType tcType = PhTimeCodeType25, QObject *parent = 0);\n\n\t/**\n\t * @brief Get the reader clock\n\t * @return The reader clock\n\t */\n\tPhClock * clock();\n\nprotected:\n\tint processAudio(const void *inputBuffer, void *, unsigned long framesPerBuffer);\n\nprivate:\n\tPhClock _clock;\n\n\tltc_off_t _position;\n\tLTCDecoder * _decoder;\n\t/** @brief Used to detect pause in LTC signal */\n\tint _noFrameCounter;\n\n};\n\n#endif // PHLTCREADER_H\n", "name": "libs/PhSync/PhLtcReader.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#include \"PhLtcWriter.h\"\n\nPhLtcWriter::PhLtcWriter(PhTimeCodeType tcType, QObject *parent) :\n\tPhAudioOutput(parent),\n\t_clock(tcType),\n\t_encoder(NULL)\n{\n\t_encoder = ltc_encoder_create(1, 1, LTC_TV_625_50, LTC_USE_DATE);\n#warning /// @todo fix this in the settings or via autodetection\n\tswitch (tcType) {\n\tcase PhTimeCodeType25:\n\t\tltc_encoder_set_bufsize(_encoder, 48000, 25.0);\n\t\t//ltc_encoder_reinit(_encoder, 48000, tcType, fps==25?LTC_TV_625_50:LTC_TV_525_60, LTC_USE_DATE);\n\t\tltc_encoder_reinit(_encoder, 48000, 25.0, LTC_TV_625_50, LTC_USE_DATE);\n\t\tbreak;\n\tcase PhTimeCodeType24:\n\tcase PhTimeCodeType2398:\n\t\tltc_encoder_set_bufsize(_encoder, 48000, 24.0);\n\t\tltc_encoder_reinit(_encoder, 48000, tcType, LTC_TV_525_60, LTC_USE_DATE);\n\t\tbreak;\n\tcase PhTimeCodeType2997:\n\t\tltc_encoder_set_bufsize(_encoder, 48000, 29.97);\n\t\tltc_encoder_reinit(_encoder, 48000, tcType, LTC_TV_525_60, LTC_USE_DATE);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tltc_encoder_set_volume(_encoder, -18.0);\n\n}\n\nPhClock *PhLtcWriter::clock()\n{\n\treturn &_clock;\n}\n\nint PhLtcWriter::processAudio(const void *, void *outputBuffer, unsigned long)\n{\n\tunsigned int hhmmssff[4];\n\tPhTimeCode::ComputeHhMmSsFf(hhmmssff, _clock.frame(), _clock.timeCodeType());\n\t_st.hours = hhmmssff[0];\n\t_st.mins = hhmmssff[1];\n\t_st.secs = hhmmssff[2];\n\t_st.frame = hhmmssff[3];\n\tltc_encoder_set_timecode(_encoder, &_st);\n\n\tPHDBG(21) << _st.hours << _st.mins << _st.secs << _st.frame;\n\n\tint len;\n\tltcsnd_sample_t *buf;\n\n\tltc_encoder_encode_frame(_encoder);\n\n\tbuf = ltc_encoder_get_bufptr(_encoder, &len, 1);\n\tmemcpy(outputBuffer, buf, len);\n\t_clock.tick(PhTimeCode::getFps(_clock.timeCodeType()));\n\n\treturn len;\n}\n", "name": "libs/PhSync/PhLtcWriter.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef PHLTCWRITER_H\n#define PHLTCWRITER_H\n\n#include <ltc.h>\n\n#include \"PhTools/PhClock.h\"\n#include \"PhTools/PhTimeCode.h\"\n\n#include \"PhAudio/PhAudioOutput.h\"\n\n/**\n * @brief Send master LTC generator\n */\nclass PhLtcWriter : public PhAudioOutput\n{\n\tQ_OBJECT\npublic:\n\t/**\n\t * @brief PhLtcWriter constructor\n\t * @param tcType the timecode type\n\t * @param parent the reader's parent\n\t */\n\texplicit PhLtcWriter(PhTimeCodeType tcType, QObject *parent = 0);\n\t/**\n\t * @brief Get the writer clock\n\t * @return The writer clock\n\t */\n\tPhClock *clock();\n\nprivate:\n\n\tint processAudio(const void *, void *outputBuffer, unsigned long);\n\n\tPhClock _clock;\n\tLTCEncoder *_encoder;\n\tSMPTETimecode _st;\n\n};\n\n#endif // PHLTCWRITER_H\n", "name": "libs/PhSync/PhLtcWriter.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#include \"PhSonyController.h\"\n\n#include <QSerialPortInfo>\n#include <qmath.h>\n\n#include \"PhTools/PhDebug.h\"\n\nPhSonyController::PhSonyController(PhTimeCodeType tcType, PhSyncSettings *settings, QString comSuffix) :\n\t_clock(tcType),\n\t_settings(settings),\n\t_comSuffix(comSuffix),\n\t_dataRead(0),\n\t_lastCTS(false),\n\t_threadRunning(false)\n{\n//\tconnect(&_serial, SIGNAL(error(QSerialPort::SerialPortError)), this,\n//            SLOT(handleError(QSerialPort::SerialPortError)));\n}\n\nPhSonyController::~PhSonyController()\n{\n\tclose();\n}\n\nbool PhSonyController::open(bool inThread)\n{\n\tPHDEBUG << _comSuffix;\n\tforeach(QSerialPortInfo info, QSerialPortInfo::availablePorts())\n\t{\n\t\tQString name = info.portName();\n\t\tPHDEBUG << name;\n\n\t\tif(name.endsWith(_comSuffix)) {\n\t\t\t_serial.setPort(info);\n\n\t\t\tPHDEBUG << _comSuffix << \"Opening \" << name << _serial.parent();\n\t\t\tif( _serial.open(QSerialPort::ReadWrite)) {\n\t\t\t\t_serial.setBaudRate(QSerialPort::Baud38400);\n\t\t\t\t_serial.setDataBits(QSerialPort::Data8);\n\t\t\t\t_serial.setStopBits(QSerialPort::OneStop);\n\t\t\t\t_serial.setParity(QSerialPort::OddParity);\n\n\t\t\t\tif(inThread)\n\t\t\t\t\tthis->start(QThread::HighPriority);\n\t\t\t\telse\n\t\t\t\t\tconnect(&_serial, SIGNAL(readyRead()), this, SLOT(onData()));\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\tPHDEBUG << _comSuffix << \"Unable to find usbserial-XXX\" << _comSuffix;\n\treturn false;\n}\n\nvoid PhSonyController::close()\n{\n\tif(_threadRunning) {\n\t\t_threadRunning = false;\n\t\tPHDEBUG << this->wait(1000);\n\t}\n\tif(_serial.isOpen()) {\n\t\tPHDEBUG << _comSuffix;\n\t\t_serial.close();\n\t}\n}\n\nvoid PhSonyController::checkVideoSync(int)\n{\n\tif(_serial.isOpen()) {\n\t\tbool videoSyncUp = true;\n\t\tif(_settings)\n\t\t\tvideoSyncUp = _settings->videoSyncUp();\n\t\tbool cts = _serial.pinoutSignals() & QSerialPort::ClearToSendSignal;\n\t\tif(videoSyncUp) {\n\t\t\tif(!_lastCTS && cts) {\n\t\t\t\tonVideoSync();\n\t\t\t\temit videoSync();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif(_lastCTS && !cts) {\n\t\t\t\tonVideoSync();\n\t\t\t\temit videoSync();\n\t\t\t}\n\t\t}\n\t\t_lastCTS = cts;\n\t}\n}\n\nvoid PhSonyController::run()\n{\n\t_threadRunning = true;\n\twhile(_threadRunning) {\n\t\tthis->checkVideoSync(100);\n\t\tif(_serial.waitForReadyRead(10))\n\t\t\tonData();\n\t}\n}\n\nPhRate PhSonyController::computeRate(unsigned char data1)\n{\n\tif(data1 == 0)\n\t\treturn 0;\n\tPhRate n1 = data1;\n\treturn qPow(10, n1/32 - 2);\n}\n\nPhRate PhSonyController::computeRate(unsigned char data1, unsigned char data2)\n{\n\tPhRate n1 = data1;\n\tPhRate n2 = data2;\n\tPhRate rate = computeRate(data1);\n\treturn rate + n2/256 * qPow(10, (n1+1)/32 - 2 - rate);\n}\n\nunsigned char PhSonyController::computeData1FromRate(PhRate rate)\n{\n\tif(rate == 0)\n\t\treturn 0;\n\treturn (char)(32 * (2 + qLn(rate) / qLn(10)));\n}\n\nunsigned char PhSonyController::getDataSize(unsigned char cmd1)\n{\n\treturn cmd1 & 0x0f;\n}\n\nvoid PhSonyController::sendCommandWithData(unsigned char cmd1, unsigned char cmd2, const unsigned char *data)\n{\n//\tPHDEBUG << _comSuffix << stringFromCommand(cmd1, cmd2, data);\n\tunsigned char datacount = getDataSize(cmd1);\n\tunsigned char checksum = cmd1 + cmd2;\n\tfor (int i = 0; i < datacount; i++) {\n\t\t_dataOut[i + 2] = data[i];\n\t\tchecksum += data[i];\n\t}\n\t_dataOut[0] = cmd1;\n\t_dataOut[1] = cmd2;\n\t_dataOut[datacount+2] = checksum;\n\t_serial.write((const char*)_dataOut, datacount + 3);\n}\n\nvoid PhSonyController::sendCommand(unsigned char cmd1, unsigned char cmd2, ...)\n{\n\tunsigned char data[256];\n\tunsigned char datacount = getDataSize(cmd1);\n\tva_list argumentList;\n\tva_start(argumentList, cmd2);\n\tfor (int i = 0; i < datacount; i++)\n\t\tdata[i] = (char)va_arg(argumentList, int);\n\n\tva_end(argumentList);\n\n\tsendCommandWithData(cmd1, cmd2, data);\n}\n\nvoid PhSonyController::timeOut()\n{\n\tPHDEBUG << _comSuffix;\n}\n\nvoid PhSonyController::checkSumError()\n{\n\tPHDEBUG << _comSuffix;\n}\n\nQString PhSonyController::stringFromCommand(unsigned char cmd1, unsigned char cmd2, const unsigned char * data)\n{\n\tQString dataString = \"\";\n\tunsigned char dataCount = getDataSize(cmd1);\n\tif(dataCount > 0) {\n\t\tdataString = \" : \";\n\t\tfor(int i = 0; i < dataCount; i++)\n\t\t\tdataString += \" \" + QString::number(data[i], 16);\n\t}\n\treturn QString::number(cmd1, 16) + \" \" + QString::number(cmd2, 16) + dataString;\n}\n\nvoid PhSonyController::onData()\n{\n\twhile(_serial.bytesAvailable()) {\n\t\t//\tPHDEBUG << _comSuffix;\n\t\t// reading the cmd1 and cmd2\n\t\tif(_dataRead < 2) {\n\t\t\tQByteArray array = _serial.read(2 - _dataRead);\n\t\t\t//\t\tPHDEBUG << \"reading : \" << array.length();\n\t\t\tfor (int i = 0; i < array.length(); i++)\n\t\t\t\t_dataIn[i + _dataRead] = array[i];\n\t\t\t_dataRead += array.length();\n\t\t}\n\n\t\t// if cmd1 and cmd2 are read, go on with data\n\t\tif(_dataRead >= 2) {\n\t\t\tunsigned char cmd1 = _dataIn[0];\n\t\t\tunsigned char cmd2 = _dataIn[1];\n\t\t\tunsigned char datacount = getDataSize(cmd1);\n\n\t\t\t// Reading the data left\n\t\t\tQByteArray array = _serial.read(datacount + 3 - _dataRead);\n\t\t\t//\t\tPHDEBUG << \"reading : \" << array.length();\n\t\t\tfor (int i = 0; i < array.length(); i++)\n\t\t\t\t_dataIn[i + _dataRead] = array[i];\n\t\t\t_dataRead += array.length();\n\n\t\t\tif(_dataRead == datacount + 3) { // A whole command has been read\n\t\t\t\tQString cmdString = stringFromCommand(cmd1, cmd2, _dataIn + 2);\n\t\t\t\t//\t\t\tPHDEBUG << _comSuffix << \"reading : \" << cmdString;\n\n\t\t\t\t// Computing the checksum\n\t\t\t\tunsigned char checksum = 0;\n\t\t\t\tfor (int i = 0; i < datacount + 2; i++)\n\t\t\t\t\tchecksum += _dataIn[i];\n\n\t\t\t\tif (checksum != _dataIn[datacount+2]) {\n\t\t\t\t\tPHDEBUG << _comSuffix << \"Checksum error : \" << cmdString;\n\t\t\t\t\t_serial.flush();\n\t\t\t\t\tcheckSumError();\n\t\t\t\t}\n\t\t\t\telse // Process the data\n\t\t\t\t\tprocessCommand(cmd1, cmd2, _dataIn + 2);\n\n\t\t\t\t// Reset the data counter to read another command\n\t\t\t\t_dataRead = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid PhSonyController::handleError(QSerialPort::SerialPortError error)\n{\n\tPHDEBUG << _comSuffix << error;\n}\n", "name": "libs/PhSync/PhSonyController.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef PHSONYCONTROLLER_H\n#define PHSONYCONTROLLER_H\n\n#include <QObject>\n#include <QSerialPort>\n#include <QThread>\n\n#include \"PhTools/PhClock.h\"\n\n#include \"PhSyncSettings.h\"\n\n/**\n * @brief Sony abstract controller for  sony 9 pin communication through the serial port.\n *\n * It provide a generic implementation for handlind sony master\n * and slave communication.\n * It contains an internal clock which behave differently if it is a sony\n * master or slave.\n *\n * Sony 9 pin specification : http://www.belle-nuit.com/archives/9pin.html\n */\nclass PhSonyController : public QThread\n{\n\tQ_OBJECT\npublic:\n\n\t/**\n\t * @brief Various error code sent with the NAK command.\n\t *\n\t * See : http://www.belle-nuit.com/archives/9pin.html#nak\n\t */\n\tenum PhSonyError {\n\t\tUndefinedCommand,\n\t\tUnusedError1,\n\t\tChecksumError,\n\t\tUnusedError3,\n\t\tParityError,\n\t\tOverrunError,\n\t\tFramingError,\n\t\tTimeOut\n\t};\n\n\t/**\n\t * @brief PhSonyController constructor\n\t *\n\t * @param tcType The initial timecode type\n\t * @param settings The application settings\n\t * @param comSuffix Serial port name suffix\n\t */\n\texplicit PhSonyController(PhTimeCodeType tcType, PhSyncSettings *settings, QString comSuffix);\n\n\t/**\n\t * @brief PhSonyController destructor\n\t *\n\t * Closing the port if open.\n\t */\n\t~PhSonyController();\n\n\t/**\n\t * @brief Open the communication port.\n\t */\n\tbool open(bool inThread = true);\n\n\t/**\n\t * @brief Close the communication port.\n\t */\n\tvoid close();\n\n\t/**\n\t * @brief Get the sony controller internal clock.\n\t * @return A clock reference.\n\t */\n\tPhClock *clock() {\n\t\treturn &_clock;\n\t}\n\n\t/**\n\t * @brief Compute the rate from the jog, varispeed and shuttle sony protocole\n\t * order data.\n\t *\n\t * For more detail see http://www.belle-nuit.com/archives/9pin.html#jogFwd\n\t * @param data1 A one byte coded version of the rate.\n\t * @return The float value corresponding rate.\n\t */\n\tstatic PhRate computeRate(unsigned char data1);\n\n\t/**\n\t * Compute the rate from the jog, varispeed and shuttle sony protocole\n\t * order data.\n\t * For more detail see http://www.belle-nuit.com/archives/9pin.html#jogFwd\n\t * @param data1 The first byte of the two bytes coded version of the rate.\n\t * @param data2 The second byte of the two bytes coded version of the rate.\n\t * @return The float value corresponding rate.\n\t */\n\tstatic PhRate computeRate(unsigned char data1, unsigned char data2);\n\n\t/**\n\t * Compute the jog, varispeed and shuttle sony protocole\n\t * order data from a rate\n\t * For more detail see http://www.belle-nuit.com/archives/9pin.html#jogFwd\n\t * @param rate The float value rate.\n\t * @return A one byte coded version of the rate.\n\t */\n\tstatic unsigned char computeData1FromRate(PhRate rate);\n\nsignals:\n\t/**\n\t * @brief This signal is triggered when a video sync event occurs on the serial port.\n\t */\n\tvoid videoSync();\n\npublic slots:\n\t/**\n\t * @brief This slot trigger a check of the video sync check.\n\t *\n\t * If this slot is not trigger\n\t * regulary, no video sync event occurs.\n\t */\n\tvoid checkVideoSync(int frequency = 0);\n\n\t/**\n\t * @brief This slot handles the video sync signal.\n\t *\n\t * Its implementation differs between the master and the slave.\n\t */\n\tvirtual void onVideoSync() = 0;\n\nprotected:\n\t/**\n\t * @brief The thread starting point\n\t *\n\t * This method is called when the thread is created.\n\t * It constantly read the data on the serial port and pass\n\t * it to the child via the processCommand() virtual method.\n\t */\n\tvoid run();\n\n\t/**\n\t * @brief Process a single sony command.\n\t *\n\t * The clock and controller state are updated if needed.\n\t * This method shall be implemented differently by the slave and the master.\n\t *\n\t * @param cmd1 First command descriptor.\n\t * @param cmd2 Second command descriptor.\n\t * @param dataIn Command data.\n\t */\n\tvirtual void processCommand(unsigned char cmd1, unsigned char cmd2, const unsigned char* dataIn) = 0;\n\n\t/**\n\t * @brief Extract the data size from the first command descriptor.\n\t * @param cmd1 First command descriptor.\n\t * @return Data size in byte.\n\t */\n\tunsigned char getDataSize(unsigned char cmd1);\n\n\t/**\n\t * Send a sony protocol command.\n\t *\n\t * @param cmd1 First command descriptor.\n\t * @param cmd2 Second command descriptor.\n\t * @param data Data for the command.\n\t */\n\tvoid sendCommandWithData(unsigned char cmd1, unsigned char cmd2, const unsigned char *data);\n\n\t/**\n\t * @brief Send a sony protocol command with an argument list of unsigned char for the data.\n\t *\n\t * @param cmd1 First command descriptor.\n\t * @param cmd2 Second command descriptor.\n\t */\n\tvoid sendCommand(unsigned char cmd1, unsigned char cmd2, ...);\n\n\t/**\n\t * @brief This method is called whenever a timeout happens when reading the data.\n\t *\n\t * It allows distinct implementation for slave and master.\n\t */\n\tvirtual void timeOut();\n\n\t/**\n\t * @brief This method is called whenever a check sum error happens when reading the data.\n\t *\n\t * It allows distinct implementation for slave and master.\n\t */\n\tvirtual void checkSumError();\n\n\t/**\n\t * @brief Convert a sony command and data to a readable string.\n\t *\n\t * @param cmd1 First command descriptor.\n\t * @param cmd2 Second command descriptor.\n\t * @param data Command data.\n\t * @return The name of the command.\n\t */\n\tQString stringFromCommand(unsigned char cmd1, unsigned char cmd2, const unsigned char *data = 0);\n\n\t/** @brief The internal clock of the sony controller. */\n\tPhClock _clock;\n\n\t/** @brief The application settings */\n\tPhSyncSettings* _settings;\n\n\t/** @brief Serial port name suffix (A for slave and B for master). */\n\tQString _comSuffix;\n\nprivate:\n\t/** @brief Serial port connected to the controller. */\n\tQSerialPort _serial;\n\n\t/** @brief Buffer used for serial data reception. */\n\tunsigned char _dataIn[256];\n\n\t/** @brief Amount of serial data read for the current command/data */\n\tint _dataRead;\n\n\t/** @brief Buffer used for serial data emission. */\n\tunsigned char _dataOut[256];\n\n\t/** @brief Last value of the serial CTS state. */\n\tbool _lastCTS;\n\n\t/** @brief Indicate if the thread is currently running */\n\tbool _threadRunning;\n\nprivate slots:\n\t/** @brief Slot triggered when data are available on the serial port */\n\tvoid onData();\n\n\t/** @brief Slot triggered when a serial error occurs */\n\tvoid handleError(QSerialPort::SerialPortError error);\n};\n\n#endif // PHSONYCONTROLLER_H\n\n", "name": "libs/PhSync/PhSonyController.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#include \"PhSonyMasterController.h\"\n\n#include \"PhTools/PhDebug.h\"\n\nPhSonyMasterController::PhSonyMasterController(PhTimeCodeType tcType, PhSyncSettings *settings)\n\t: PhSonyController(tcType, settings, settings->sonyMasterPortSuffix())\n{\n}\n\nvoid PhSonyMasterController::onVideoSync()\n{\n\ttimeSense();\n\tspeedSense();\n\tstatusSense();\n}\n\nvoid PhSonyMasterController::deviceTypeRequest()\n{\n\tPHDEBUG << _comSuffix << \"Device type request\";\n\tsendCommand(0x00, 0x11);\n}\n\nvoid PhSonyMasterController::play()\n{\n\tPHDEBUG << _comSuffix << \"Play\";\n\tsendCommand(0x20, 0x01);\n}\n\nvoid PhSonyMasterController::stop()\n{\n\tPHDEBUG << _comSuffix << \"Stop\";\n\tsendCommand(0x20, 0x00);\n}\n\nvoid PhSonyMasterController::cue(PhFrame frame)\n{\n\tPhTimeCodeType tcType = _clock.timeCodeType();\n\tPHDEBUG << _comSuffix << \"Cue at \" << PhTimeCode::stringFromFrame(frame, tcType);\n\tunsigned int bcd = PhTimeCode::bcdFromFrame(frame, tcType);\n\tsendCommandWithData(0x24, 0x31, (const unsigned char *)&bcd);\n}\n\nvoid PhSonyMasterController::fastForward()\n{\n\tPHDEBUG << _comSuffix;\n\tsendCommand(0x20, 0x10);\n}\n\nvoid PhSonyMasterController::rewind()\n{\n\tPHDEBUG << _comSuffix;\n\tsendCommand(0x20, 0x20);\n}\n\nvoid PhSonyMasterController::jog(PhRate rate)\n{\n\tPHDEBUG << _comSuffix;\n\tchar data1;\n\tif (rate < 0) {\n\t\tdata1 = computeData1FromRate(-rate);\n\t\tsendCommand(0x21, 0x21, data1);\n\t}\n\telse {\n\t\tdata1 = computeData1FromRate(rate);\n\t\tsendCommand(0x21, 0x11, data1);\n\t}\n}\n\nvoid PhSonyMasterController::varispeed(PhRate rate)\n{\n\tPHDEBUG << _comSuffix << rate;\n\tchar data1;\n\tif (rate < 0) {\n\t\tdata1 = computeData1FromRate(-rate);\n\t\tsendCommand(0x21, 0x22, data1);\n\t}\n\telse {\n\t\tdata1 = computeData1FromRate(rate);\n\t\tsendCommand(0x21, 0x12, data1);\n\t}\n}\n\nvoid PhSonyMasterController::shuttle(PhRate rate)\n{\n\tPHDEBUG << _comSuffix << rate;\n\tchar data1;\n\tif (rate < 0) {\n\t\tdata1 = computeData1FromRate(-rate);\n\t\tsendCommand(0x21, 0x23, data1);\n\t}\n\telse {\n\t\tdata1 = computeData1FromRate(rate);\n\t\tsendCommand(0x21, 0x13, data1);\n\t}\n}\n\nvoid PhSonyMasterController::timeSense()\n{\n//\tPHDEBUG << _comSuffix;\n\tsendCommand(0x61, 0x0c, 1);\n}\n\nvoid PhSonyMasterController::statusSense()\n{\n//\tPHDEBUG << _comSuffix;\n\tsendCommand(0x61, 0x20, 4);\n}\n\nvoid PhSonyMasterController::speedSense()\n{\n//\tPHDEBUG << _comSuffix;\n\tsendCommand(0x60, 0x2E);\n}\n\nvoid PhSonyMasterController::processCommand(unsigned char cmd1, unsigned char cmd2, const unsigned char *dataIn)\n{\n//\tPHDEBUG << _comSuffix << \"PhSonyMasterController::processCommand : \" << stringFromCommand(cmd1, cmd2, dataIn);\n\tswitch (cmd1 >> 4) {\n\tcase 1:\n\t\tswitch (cmd2) {\n\t\tcase 0x01:\n\t\t\tPHDEBUG << _comSuffix << \" => ACK\";\n\t\t\tbreak;\n\t\tcase 0x11:\n\t\t\t{\n\t\t\t\tdeviceIdData(dataIn[0], dataIn[1]);\n\t\t\t\tQString id;\n\t\t\t\tid.sprintf(\"%02X %02X\", dataIn[0], dataIn[1]);\n\t\t\t\tPHDEBUG << _comSuffix << \" => Device ID answer : \" << id;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase 0x12:\n\t\t\tPHDEBUG << _comSuffix << \" => NAK :\" <<  QString::number(dataIn[0], 16);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPHDEBUG << _comSuffix << \" => Unknown answer : \" << QString(\"%x %x\").arg(cmd1, cmd2);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 7:\n\t\tswitch (cmd2) {\n\t\tcase 0x04:\n\t\t\t{\n\t\t\t\tPhFrame frame = PhTimeCode::frameFromBcd(*(unsigned int *)dataIn, _clock.timeCodeType());\n//\t\t\tPHDEBUG << _comSuffix << \" => LTC Time Data : \" << PhTimeCode::stringFromFrame(frame, _clock.getTCType());\n\t\t\t\t_clock.setFrame(frame);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase 0x20:\n\t\t\t{\n#warning /// @todo check more than 4 byte data.\n\t\t\t\tunsigned char status[4];\n\t\t\t\tQString statusStr = \"\";\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tstatus[i] = dataIn[i];\n\t\t\t\t\tstatusStr += QString::number(dataIn[i], 16) + \" \";\n\t\t\t\t}\n\t\t\t\tstatusData(status, 0, 4);\n//\t\t\tPHDEBUG << _comSuffix << \" => Status data : \" << statusStr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase 0x2e:\n\t\t\t{\n\t\t\t\tunsigned dataCount = getDataSize(cmd1);\n\t\t\t\tPhRate rate = 0;\n\t\t\t\tswitch(dataCount) {\n\t\t\t\tcase 1:\n\t\t\t\t\trate = computeRate(dataIn[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\trate = computeRate(dataIn[0], dataIn[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tPHDEBUG << _comSuffix << \" bad command\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n//\t\t\tPHDEBUG << _comSuffix << \" => Speed data : \" << rate;\n\t\t\t\t_clock.setRate(rate);\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\tdefault:\n\t\t\tPHDEBUG << _comSuffix << \" => Unknown answer : \" << QString::number(cmd1, 16) << \" \" << QString::number(cmd2, 16);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tPHDEBUG << _comSuffix << \" => Unknown answer : \" << QString::number(cmd1, 16) << \" \" << QString::number(cmd2, 16);\n\t\tbreak;\n\t}\n//\tPHDEBUG << _comSuffix << stringFromCommand(cmd1, cmd2, dataIn) << \" over\";\n\n}\n", "name": "libs/PhSync/PhSonyMasterController.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef PHSONYMASTERCONTROLLER_H\n#define PHSONYMASTERCONTROLLER_H\n\n#include \"PhSonyController.h\"\n\n/**\n * @brief Sony master controller for sony 9 pin communication through the serial port.\n *\n * Send command to a connected sony slave device\n * and update a clock component and the status accordingly.\n * The controller connect automatically with the first\n * usb serial connected port referenced as \"B\".\n *\n * Upon a video sync event, the master controller perform three actions:\n * - status sense\n * - time sense\n * - speed sense\n */\nclass PhSonyMasterController : public PhSonyController\n{\n\tQ_OBJECT\npublic:\n\t/**\n\t * @brief PhSonyMasterController constructor\n\t * @param tcType The initial timecode type.\n\t * @param settings The application settings\n\t */\n\tPhSonyMasterController(PhTimeCodeType tcType, PhSyncSettings *settings);\n\npublic slots:\n\t/**\n\t * @brief This slot performs a status, time and speed sense.\n\t */\n\tvoid onVideoSync();\n\n\t/** @brief Request the slave device id. */\n\tvoid deviceTypeRequest();\n\n\t/**\n\t * @brief Send a play command to the connected device.\n\t *\n\t * See : http://www.belle-nuit.com/archives/9pin.html#play\n\t */\n\tvoid play();\n\n\t/**\n\t * @brief Send a stop command to the connected device.\n\t *\n\t * See : http://www.belle-nuit.com/archives/9pin.html#stop\n\t */\n\tvoid stop();\n\n\t/**\n\t * @brief Send a cue command to the connected device.\n\t *\n\t * See : http://www.belle-nuit.com/archives/9pin.html#cueUpWithData\n\t *\n\t * @param frame frame number\n\t */\n\tvoid cue(PhFrame frame);\n\n\t/**\n\t * @brief Send a fast forward command to the connected device.\n\t *\n\t * See : http://www.belle-nuit.com/archives/9pin.html#fastFwd\n\t */\n\tvoid fastForward();\n\n\t/**\n\t * @brief Send a rewind command to the connected device.\n\t *\n\t * See : http://www.belle-nuit.com/archives/9pin.html#rewind\n\t */\n\tvoid rewind();\n\n\t/**\n\t * @brief Send a jog command to the connected device.\n\t *\n\t * See : http://www.belle-nuit.com/archives/9pin.html#jogFwd\n\t *\n\t * @param rate The jog rate\n\t */\n\tvoid jog(PhRate rate);\n\n\t/**\n\t * @brief Send a varispeed command to the connected device.\n\t *\n\t * See : http://www.belle-nuit.com/archives/9pin.html#varFwd\n\t *\n\t * @param rate The varispeed rate\n\t */\n\tvoid varispeed(PhRate rate);\n\n\t/**\n\t * @brief Send a shuttle command to the connected device.\n\t *\n\t * See : http://www.belle-nuit.com/archives/9pin.html#shuttleFwd\n\t *\n\t * @param rate The shuttle rate\n\t */\n\tvoid shuttle(PhRate rate);\n\n\t/** @brief Send a time sense command to the connected device.\n\t *\n\t * See http://www.belle-nuit.com/archives/9pin.html#currentTimeSense\n\t */\n\tvoid timeSense();\n\n\t/** @brief Send a status sense command to the connected device.\n\t *\n\t * See http://www.belle-nuit.com/archives/9pin.html#statusSense\n\t */\n\tvoid statusSense();\n\n\t/** @brief Send a speed sense command to the connected device.\n\t *\n\t * See http://www.belle-nuit.com/archives/9pin.html#cmdSpeedSense\n\t */\n\tvoid speedSense();\n\nsignals:\n\t/**\n\t * @brief Signal sent when a device id information is received by the sony master controller.\n\t *\n\t * See : http://www.belle-nuit.com/archives/9pin.html#deviceTypeRequest\n\t *\n\t * @param id1 Major device description byte.\n\t * @param id2 Minor device description byte.\n\t */\n\tvoid deviceIdData(unsigned char id1, unsigned char id2);\n\n\t/**\n\t * @brief Signal sent when status data ared received by the sony master controller.\n\t *\n\t * See : http://www.belle-nuit.com/archives/9pin.html#statusData\n\t *\n\t * @param statusData Partial status data buffer.\n\t * @param offset Offset of the partial status data buffer according to the full status info.\n\t * @param length Length of the partial status data buffer.\n\t */\n\tvoid statusData(unsigned char * statusData, int offset, int length);\n\nprotected:\n\t/**\n\t * @brief Process a single command from the sony slave.\n\t *\n\t * The clock and controller state are updated if needed.\n\t *\n\t * @param cmd1 First command descriptor.\n\t * @param cmd2 Second command descriptor.\n\t * @param dataIn Command data.\n\t */\n\tvoid processCommand(unsigned char cmd1, unsigned char cmd2, const unsigned char *dataIn);\n};\n\n#endif // PHSONYMASTERCONTROLLER_H\n\n\n\n\n\n", "name": "libs/PhSync/PhSonyMasterController.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#include \"PhSonySlaveController.h\"\n\n#include \"PhTools/PhDebug.h\"\n\nPhSonySlaveController::PhSonySlaveController(PhTimeCodeType tcType, PhSyncSettings *settings)\n\t: PhSonyController(tcType, settings, settings->sonySlavePortSuffix()),\n\t_autoMode(false), _state(Pause)\n{\n}\n\nvoid PhSonySlaveController::processCommand(unsigned char cmd1, unsigned char cmd2, const unsigned char *dataIn)\n{\n\tunsigned char dataOut[16];\n\tPHDBG(20) << _comSuffix << stringFromCommand(cmd1, cmd2, dataIn);\n\tswitch (cmd1 >> 4) {\n\tcase 0:\n\t\tswitch (cmd2) {\n\t\tcase 0x0c:\n\t\t\tPHDEBUG << _comSuffix << \"Local disable => ACK\";\n\t\t\tsendAck();\n\t\t\tbreak;\n\t\tcase 0x11:\n\t\t\t{\n//\t\t\tPHDEBUG << _comSuffix << \"Device Type Request => F1C0\";\n\t\t\t\tunsigned char deviceID1 = _settings->sonyDevice1();\n\t\t\t\tunsigned char deviceID2 = _settings->sonyDevice2();\n\t\t\t\tswitch (_clock.timeCodeType()) {\n\t\t\t\tcase PhTimeCodeType2398:\n\t\t\t\tcase PhTimeCodeType24:\n\t\t\t\t\tdeviceID1 += 2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase PhTimeCodeType25:\n\t\t\t\t\tdeviceID1 += 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase PhTimeCodeType2997:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsendCommand(0x12, 0x11, deviceID1, deviceID2);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase 0x1d:\n\t\t\tPHDEBUG << _comSuffix << \"Local enable => ACK\";\n\t\t\tsendAck();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPHDEBUG << _comSuffix << \" => Unknown subcommand \" << stringFromCommand(cmd1, cmd2, dataIn) << \" => NAK\";\n\t\t\tsendNak(UndefinedCommand);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tswitch (cmd2) {\n\t\tcase 0x00:\n\t\t\tPHDEBUG << _comSuffix << \"Stop => ACK\";\n\t\t\t_state = Pause;\n\t\t\t_clock.setRate(0);\n\t\t\tsendAck();\n\t\t\tbreak;\n\t\tcase 0x01:\n\t\t\tPHDEBUG << _comSuffix << \"Play => ACK\";\n\t\t\t_state = Play;\n\t\t\t_clock.setRate(1);\n\t\t\tsendAck();\n\t\t\tbreak;\n\t\tcase 0x10:\n\t\t\tPHDEBUG << _comSuffix << \"Fast forward => ACK\";\n\t\t\t_state = FastForward;\n\t\t\t_clock.setRate(_settings->sonyFastRate());\n\t\t\tsendAck();\n\t\t\tbreak;\n\t\tcase 0x20:\n\t\t\tPHDEBUG << _comSuffix << \"Rewing => ACK\";\n\t\t\t_state = Rewind;\n\t\t\t_clock.setRate(-_settings->sonyFastRate());\n\t\t\tsendAck();\n\t\t\tbreak;\n\t\tcase 0x11:\n\t\tcase 0x12:\n\t\tcase 0x13:\n\t\tcase 0x21:\n\t\tcase 0x22:\n\t\tcase 0x23:\n\t\t\t{\n\t\t\t\tPhRate rate = 0;\n\t\t\t\tswitch (cmd1 & 0xf) {\n\t\t\t\tcase 1:\n\t\t\t\t\trate = computeRate(dataIn[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\trate = computeRate(dataIn[0], dataIn[1]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tswitch (cmd1) {\n\t\t\t\tcase 0x11:\n\t\t\t\t\t_state = Jog;\n\t\t\t\t\tPHDEBUG << _comSuffix << \"Jog Forward : \"<< rate<<\"=> ACK\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x12:\n\t\t\t\t\t_state = Varispeed;\n\t\t\t\t\tPHDEBUG << _comSuffix << \"Var Forward : \"<< rate<<\"=> ACK\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x13:\n\t\t\t\t\t_state = Shuttle;\n\t\t\t\t\tPHDEBUG << _comSuffix << \"Shuttle Forward : \" << rate << \"=> ACK\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x21:\n\t\t\t\t\trate = -rate;\n\t\t\t\t\t_state = Jog;\n\t\t\t\t\tPHDEBUG << _comSuffix << \"Jog rev : \" << rate << \"=> ACK\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x22:\n\t\t\t\t\trate = -rate;\n\t\t\t\t\t_state = Varispeed;\n\t\t\t\t\tPHDEBUG << _comSuffix << \"Var rev : \" << rate << \"=> ACK\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x23:\n\t\t\t\t\trate = -rate;\n\t\t\t\t\t_state = Shuttle;\n\t\t\t\t\tPHDEBUG << _comSuffix << \"Shuttle rev : \" << rate << \"=> ACK\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t_clock.setRate(rate);\n\t\t\t\tsendAck();\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase 0x31:\n\t\t\t{\n\t\t\t\tPhFrame frame = PhTimeCode::frameFromBcd(*(unsigned int *)dataIn, _clock.timeCodeType());\n\t\t\t\t_clock.setFrame(frame);\n\t\t\t\tPHDEBUG << _comSuffix << \"Cue at \" << PhTimeCode::stringFromFrame(_clock.frame(), _clock.timeCodeType()) << \"=> ACK\";\n\t\t\t\tsendAck();\n\t\t\t\tbreak;\n\t\t\t}\n\t\tdefault:\n\t\t\tPHDEBUG << _comSuffix << \" => Unknown subcommand \" << stringFromCommand(cmd1, cmd2, dataIn) << \" => NAK\";\n\t\t\tsendNak(UndefinedCommand);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 4:\n\t\tswitch (cmd2) {\n\t\tcase 0x30:\n\t\t\tPHDEBUG << _comSuffix << \"Edit preset => ACK\";\n\t\t\tsendAck();\n\t\t\tbreak;\n\t\tcase 0x40:\n\t\t\tPHDEBUG << _comSuffix << \"Auto Mode Off => ACK\";\n\t\t\t_autoMode = false;\n\t\t\tsendAck();\n\t\t\tbreak;\n\t\tcase 0x41:\n\t\t\t_autoMode = true;\n\t\t\tPHDEBUG << _comSuffix << \"Auto Mode On => ACK\";\n\t\t\tsendAck();\n\t\t\tbreak;  case 6:\n\t\tdefault:\n\t\t\tPHDEBUG << _comSuffix << \" => Unknown subcommand \" << stringFromCommand(cmd1, cmd2, dataIn) << \" => NAK\";\n\t\t\tsendNak(UndefinedCommand);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 6:\n\t\tswitch (cmd2) {\n\t\tcase 0x0c:\n\t\t\t{\n\t\t\t\tcmd1 = 0x74;\n\t\t\t\tPHDBG(21) << _comSuffix << \"Current Time Sense => \" << _clock.timeCode();\n\t\t\t\tswitch (dataIn[0]) {\n\t\t\t\tcase 0x01:\n\t\t\t\t\tcmd2 = 0x04;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x02:\n\t\t\t\t\tcmd2 = 0x06;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x04:\n\t\t\t\t\tcmd2 = 0x00;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x08:\n\t\t\t\t\tcmd2 = 0x01;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x10:\n\t\t\t\t\tcmd2 = 0x05;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x20:\n\t\t\t\t\tcmd2 = 0x07;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tcmd2 = 0x04;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tunsigned int bcd = PhTimeCode::bcdFromFrame(_clock.frame(), _clock.timeCodeType());\n\t\t\t\tsendCommandWithData(0x74, cmd2, (unsigned char *)&bcd);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase 0x20:\n\t\t\t{\n\t\t\t\tunsigned char status[16];\n#warning /// @todo handle status sens properly\n\t\t\t\tPHDBG(22) << _comSuffix << \"Status Sense (%x) => Status Data\" << QString::number(dataIn[0], 16);\n\t\t\t\tmemset(status, 0, 16);\n\t\t\t\tswitch (_state) {\n\t\t\t\tcase Pause:\n\t\t\t\t\tstatus[1] = 0x80;\n\t\t\t\t\tstatus[2] = 0x03;\n\t\t\t\t\tbreak;\n\t\t\t\tcase Play:\n\t\t\t\t\tstatus[1] = 0x81;\n\t\t\t\t\tstatus[2] = 0xc0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FastForward:\n\t\t\t\t\tstatus[1] = 0x84;\n\t\t\t\t\tbreak;\n\t\t\t\tcase Rewind:\n\t\t\t\t\tstatus[1] = 0x88;\n\t\t\t\t\tstatus[2] = 0x04;\n\t\t\t\t\tbreak;\n\t\t\t\tcase Jog:\n\t\t\t\t\tstatus[1] = 0x80;\n\t\t\t\t\tif (_clock.rate() < 0)\n\t\t\t\t\t\tstatus[2] = 0x14;\n\t\t\t\t\telse\n\t\t\t\t\t\tstatus[2] = 0x10;\n\t\t\t\t\tbreak;\n\t\t\t\tcase Varispeed:\n\t\t\t\t\tstatus[1] = 0x80;\n\t\t\t\t\tif (_clock.rate() < 0)\n\t\t\t\t\t\tstatus[2] = 0xcc;\n\t\t\t\t\telse\n\t\t\t\t\t\tstatus[2] = 0xc8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase Shuttle:\n\t\t\t\t\tstatus[1] = 0x80;\n\t\t\t\t\tif (_clock.rate() < 0)\n\t\t\t\t\t\tstatus[2] = 0x20;\n\t\t\t\t\telse\n\t\t\t\t\t\tstatus[2] = 0xa4;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (_autoMode)\n\t\t\t\t\tstatus[3] = 0x80;\n\t\t\t\tunsigned char start = dataIn[0] >> 4;\n\t\t\t\tunsigned char count = dataIn[0] & 0xf;\n\t\t\t\tfor (int i = 0; i < count; i++)\n\t\t\t\t\tdataOut[i] = status[i+start];\n\t\t\t\tsendCommandWithData(0x70+count, 0x20, status);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase 0x2e:\n\t\t\t{\n\t\t\t\tunsigned data1 = computeData1FromRate(_clock.rate());\n//\t\t\tPHDEBUG << \"Speed sense\";\n\t\t\t\tsendCommand(0x71, 0x2e, data1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase 0x30:\n\t\t\t{\n#warning /// @todo handle edit preset sense properly\n//\t\t\tPHDEBUG << _comSuffix << \"Edit Preset Sense => Edit Preset Status\";\n\t\t\t\tunsigned char count = dataIn[0];\n\t\t\t\tfor (int i = 0; i < count; i++)\n\t\t\t\t\tdataOut[i] = 0;\n\t\t\t\tsendCommandWithData(0x70 + count, 0x30, dataOut);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tdefault:\n\t\t\tPHDEBUG << _comSuffix << \" => Unknown subcommand \" << stringFromCommand(cmd1, cmd2, dataIn) << \" => NAK\";\n\t\t\tsendNak(UndefinedCommand);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tPHDEBUG << _comSuffix << \" => Unknown command \" << stringFromCommand(cmd1, cmd2, dataIn) << \" => NAK\";\n\t\tsendNak(UndefinedCommand);\n\t\tbreak;\n\t}\n\n//\tPHDEBUG << _comSuffix << stringFromCommand(cmd1, cmd2, dataIn) << \" over\";\n}\n\nvoid PhSonySlaveController::onVideoSync()\n{\n\t_clock.tick(PhTimeCode::getFps(_clock.timeCodeType()));\n\tPHDBG(20) << _clock.timeCode();\n}\n\nvoid PhSonySlaveController::sendAck()\n{\n//\tPHDEBUG << _comSuffix;\n\tsendCommand(0x10, 0x01);\n}\n\nvoid PhSonySlaveController::sendNak(PhSonyController::PhSonyError error)\n{\n\tPHDEBUG << _comSuffix << error;\n\tsendCommand(0x11, 0x12, error);\n}\n\nvoid PhSonySlaveController::checkSumError()\n{\n\tPhSonyController::checkSumError();\n\tsendNak(ChecksumError);\n}\n\nvoid PhSonySlaveController::timeOut()\n{\n\tPhSonyController::timeOut();\n\tsendNak(TimeOut);\n}\n", "name": "libs/PhSync/PhSonySlaveController.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef PHSONYSLAVECONTROLLER_H\n#define PHSONYSLAVECONTROLLER_H\n\n#include \"PhSonyController.h\"\n\n/**\n * @brief Slave controller for sony 9 pin communication through the serial port.\n *\n * Send command to a connected sony slave device\n * and update a clock component and the status accordingly.\n * The controller connect automatically with the first\n * usb serial connected port referenced as \"B\".\n *\n * Upon a video sync event, the master controller perform three actions:\n * - status sense\n * - time sense\n * - speed sense\n *\n * The device ID and the speed are loaded from the settings. If no settings are available,\n * a default value is used. The default values are:\n * - speed = 3\n * - device ID1 = 0xf0\n * - device ID2 = 0xc0\n *\n */\nclass PhSonySlaveController : public PhSonyController\n{\npublic:\n\t/**\n\t * @brief PhSonySlaveController constructor.\n\t * @param tcType The initial timecode type.\n\t * @param settings The application settings\n\t */\n\tPhSonySlaveController(PhTimeCodeType tcType, PhSyncSettings *settings);\n\n\t/**\n\t * @brief Various state in which the controller can be.\n\t *\n\t * This state is used to answer to the master status command.\n\t */\n\tenum PhSonyState {\n\t\tPause,\n\t\tPlay,\n\t\tFastForward,\n\t\tRewind,\n\t\tJog,\n\t\tVarispeed,\n\t\tShuttle,\n\t};\n\npublic slots:\n\t/**\n\t * @brief This slot update the clock accordingly.\n\t */\n\tvoid onVideoSync();\n\nprotected:\n\t/**\n\t * @brief Process a single command from the sony master and respond to it.\n\t *\n\t * The clock and controller state are updated if needed.\n\t *\n\t * @param cmd1 First command descriptor.\n\t * @param cmd2 Second command descriptor.\n\t * @param dataIn Command data.\n\t */\n\tvoid processCommand(unsigned char cmd1, unsigned char cmd2, const unsigned char *dataIn);\n\nprivate:\n\t/**\n\t * @brief Send a command acknolegment.\n\t */\n\tvoid sendAck();\n\n\t/**\n\t * @brief Send an error to the command emiter.\n\t * @param error Error type.\n\t */\n\tvoid sendNak(PhSonyError error);\n\n\tvoid checkSumError();\n\n\tvoid timeOut();\nprivate:\n\tbool _autoMode;\n\tPhSonyState _state;\n\n};\n\n#endif // PHSONYSLAVECONTROLLER_H\n", "name": "libs/PhSync/PhSonySlaveController.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef PHSYNCSETTINGS_H\n#define PHSYNCSETTINGS_H\n\n#include <QString>\n\n/**\n * @brief The settings for a PhSonyController\n */\nclass PhSyncSettings {\npublic:\n\t/**\n\t * @brief Shall the PhSonyController sync on a CTS up front or down front\n\t * @return True for up front, false for down front\n\t */\n\tvirtual bool videoSyncUp() = 0;\n\t/**\n\t * @brief Sony device id most significant byte\n\t * @return A 8 bit value\n\t */\n\tvirtual unsigned char sonyDevice1() = 0;\n\t/**\n\t * @brief Sony device id less significant byte\n\t * @return A 8 bit value\n\t */\n\tvirtual unsigned char sonyDevice2() = 0;\n\n\t/**\n\t * @brief Sony device fast rate\n\t * @return A float value\n\t */\n\tvirtual float sonyFastRate() = 0;\n\n\t/**\n\t * @brief The slave port name suffix\n\t * @return A string\n\t */\n\tvirtual QString sonySlavePortSuffix() = 0;\n\n\t/**\n\t * @brief The master port name suffix\n\t * @return A string\n\t */\n\tvirtual QString sonyMasterPortSuffix() = 0;\n};\n\n#endif // PHSYNCSETTINGS_H\n", "name": "libs/PhSync/PhSyncSettings.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#include \"PhClock.h\"\n\nPhClock::PhClock(PhTimeCodeType tcType, QObject *parent) :\n\tQObject(parent), _tcType(tcType), _time(0), _rate(0.0)\n{\n\tqRegisterMetaType<PhTime>(\"PhTime\");\n\tqRegisterMetaType<PhFrame>(\"PhFrame\");\n\tqRegisterMetaType<PhRate>(\"PhRate\");\n\tqRegisterMetaType<PhTimeCodeType>(\"PhTimeCodeType\");\n}\n\nvoid PhClock::setTimeCodeType(PhTimeCodeType tcType)\n{\n\tPhFrame lastFrame = frame();\n\tif(_tcType != tcType) {\n\t\t_tcType = tcType;\n\t\temit tcTypeChanged(tcType);\n\t}\n\tPhFrame newFrame = frame();\n\tif(lastFrame != newFrame)\n\t\temit frameChanged(newFrame, _tcType);\n}\n\nvoid PhClock::setTime(qint64 time)\n{\n\tPhFrame lastFrame = frame();\n\tif (_time != time) {\n\t\t_time = time;\n\t\temit timeChanged(time);\n\t}\n\tPhFrame newFrame = frame();\n\tif(lastFrame != newFrame)\n\t\temit frameChanged(newFrame, _tcType);\n}\n\nvoid PhClock::setRate(PhRate rate)\n{\n\tif (_rate != rate) {\n\t\t_rate = rate;\n\t\temit rateChanged(rate);\n\t}\n}\n\nvoid PhClock::setMillisecond(PhTime ms)\n{\n\tthis->setTime(ms * 24);\n}\n\nPhTime PhClock::milliSecond()\n{\n\treturn _time / 24;\n}\n\nvoid PhClock::setFrame(PhFrame frame)\n{\n\tthis->setTime(frame * PhTimeCode::timePerFrame(_tcType));\n}\n\nPhFrame PhClock::frame() const\n{\n\treturn _time / PhTimeCode::timePerFrame(_tcType);\n}\n\nvoid PhClock::setTimeCode(QString tc)\n{\n\tsetFrame(PhTimeCode::frameFromString(tc, _tcType));\n}\n\nQString PhClock::timeCode()\n{\n\treturn PhTimeCode::stringFromFrame(frame(), _tcType);\n}\n\nvoid PhClock::tick(PhTimeScale frequence)\n{\n\tint elapsed = 24000 / frequence;\n\tthis->setTime(static_cast<int>(_time + elapsed * _rate));\n}\n\n", "name": "libs/PhTools/PhClock.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef PHCLOCK_H\n#define PHCLOCK_H\n\n#include <QObject>\n\n#include \"PhTimeCode.h\"\n#include \"PhDebug.h\"\n\n/**\n * @brief The PhClock class modelize a clock with its current time and rate value.\n *\n * It can be synchronized through an external signal.\n * It emit a signal when its time and rate value changes.\n */\nclass PhClock : public QObject\n{\n\tQ_OBJECT\npublic:\n\t/**\n\t * @brief PhClock constructor\n\t * @param tcType the desired PhTimeCodeType\n\t * @param parent the object parent\n\t */\n\texplicit PhClock(PhTimeCodeType tcType, QObject *parent = 0);\n\t/**\n\t * @brief Set the timecode type\n\t * @param tcType the desired PhTimeCodeType\n\t */\n\tvoid setTimeCodeType(PhTimeCodeType tcType);\n\t/**\n\t * @brief Set the clock time\n\t * @param time the desired PhTime\n\t */\n\tvoid setTime(PhTime time);\n\t/**\n\t * @brief Set the clock rate\n\t * @param rate the desired rate value.\n\t */\n\tvoid setRate(PhRate rate);\n\t/**\n\t * @brief Set millisecond\n\t * It sets the clock PhTime using the following convertion : \\f${\\large \\frac{timeScale * ms}{1000} }\\f$\n\t * @param ms the desired milliseconds value\n\t */\n\tvoid setMillisecond(PhTime ms);\n\t/**\n\t * @brief Set the clock frame\n\t * @param frame the desired PhFrame\n\t */\n\tvoid setFrame(PhFrame frame);\n\t/**\n\t * @brief Set the timecode\n\t * The conversion between the string and the time code is done undercover using PhTimeCode::frameFromString\n\t * @param tc the desired timecode\n\t */\n\tvoid setTimeCode(QString tc);\n\t/**\n\t * @brief Get the timecode type\n\t * @return The PhTimeCodeType of the clock\n\t */\n\tPhTimeCodeType timeCodeType() {\n\t\treturn _tcType;\n\t}\n\t/**\n\t * @brief Get the time\n\t * @return The PhTime of the clock\n\t */\n\tPhTime time() const {\n\t\treturn _time;\n\t}\n\t/**\n\t * @brief Get the clock rate\n\t * @return The clock PhRate\n\t */\n\tPhRate rate() const {\n\t\treturn _rate;\n\t}\n\t/**\n\t * @brief Get the milliseconds of the clock\n\t * @return \\f${\\large \\frac{time * 1000}{timeScale}}\\f$\n\t */\n\tPhTime milliSecond();\n\t/**\n\t * @brief Get the PhFrame of the clock\n\t * @return The PhFrame of the clock\n\t */\n\tPhFrame frame() const;\n\t/**\n\t * @brief Get the timecode of the clock\n\t * @return The timecode of the clock\n\t */\n\tQString timeCode();\n\n\nsignals:\n\t/**\n\t * @brief emit a signal when the time changed\n\t * @param time the new time\n\t */\n\tvoid timeChanged(PhTime time);\n\t/**\n\t * @brief emit a signal when the rate changed\n\t * @param rate the new rate\n\t */\n\tvoid rateChanged(PhRate rate);\n\t/**\n\t * @brief emit a signal when the frame changed\n\t * @param frame the new frame\n\t * @param tcType the corresponding PhTimeCodeType\n\t */\n\tvoid frameChanged(PhFrame frame, PhTimeCodeType tcType);\n\t/**\n\t * @brief emit a signal when the timecode type changed\n\t * @param tcType the new PhTimeCodeType\n\t */\n\tvoid tcTypeChanged(PhTimeCodeType tcType);\n\npublic slots:\n\t/**\n\t * Sync the clock to a signal at a given frequence.\n\t * The clock time value is then updated accordingly to the clock rate.\n\t * @param frequence Frequence of the signal\n\t */\n\tvoid tick(PhTimeScale frequence);\n\nprivate:\n\tPhTimeCodeType _tcType;\n\tPhTime _time;\n\n\tPhRate _rate;\n\n};\n\n#endif // PHCLOCK_H\n", "name": "libs/PhTools/PhClock.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#include <QtGlobal>\n#include <QDate>\n#include <QStringList>\n#include <iostream>\n#include <QDir>\n#include <QEvent>\n#include <QMetaEnum>\n\n#include \"PhDebug.h\"\n\nPhDebug* PhDebug::_d = NULL;\n\nvoid PhDebug::messageOutput(QtMsgType type, const QMessageLogContext &context, const QString &msg)\n{\n\tQ_UNUSED(type); Q_UNUSED(context);\n\tif(instance()->_logMask & (1 << instance()->_currentLogLevel)) {\n\t\tinstance()->_mutex.lock();\n\t\tQString logMessage = \"\";\n\n\t\t// Display the date\n\t\tif(instance()->_displayDate) {\n\t\t\tlogMessage += QDate::currentDate().toString(\"dd/MM/yyyy \");\n\t\t}\n\n\t\t// Display timestamp\n\t\tif (instance()->_displayTime) {\n\t\t\tlogMessage += QTime::currentTime().toString(\"hh:mm:ss.zzz \");\n\t\t}\n\n\t\t// Display filename\n\t\tif (instance()->_displayFileName) {\n\n\t\t\tlogMessage += QString(context.file).split(\"/\").last() + \"\\t\";\n\t\t}\n\n\t\t// Display function name\n\t\tif (instance()->_displayFunctionName) {\n\t\t\tlogMessage += QString(context.function) + \"\\t\";\n\t\t}\n\n\t\t// Display line number\n\t\tif (instance()->_displayLine) {\n\t\t\tlogMessage += QString(\"@\") + QString::number(context.line) + \"\\t\";\n\t\t}\n\n\t\tlogMessage += msg;\n\n\t\tif(instance()->_showConsole) {\n\t\t\tswitch(type) {\n\t\t\tcase QtDebugMsg:\n\t\t\t\tstd::cout << logMessage.toStdString() << std::endl;\n\t\t\t\tbreak;\n\t\t\tcase QtWarningMsg:\n\t\t\tcase QtCriticalMsg:\n\t\t\tcase QtFatalMsg:\n\t\t\t\tstd::cerr << logMessage.toStdString() << std::endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(instance()->_textLog)\n\t\t\t*instance()->_textLog << logMessage << endl;\n\n\t\tinstance()->_mutex.unlock();\n\t}\n}\n\nQString PhDebug::logLocation()\n{\n\treturn instance()->_logFileName;\n}\n\nvoid PhDebug::showConsole(bool show)\n{\n\tinstance()->_showConsole = show;\n}\n\nvoid PhDebug::setDisplay(bool date, bool time, bool fileName, bool functionName, bool line)\n{\n\tinstance()->_displayDate = date;\n\tinstance()->_displayTime = time;\n\tinstance()->_displayFileName = fileName;\n\tinstance()->_displayFunctionName = functionName;\n\tinstance()->_displayLine = line;\n}\n\n// Called if init() was forget\nPhDebug* PhDebug::instance()\n{\n\tif (!_d)   // Only allow one instance of class to be generated.\n\t\t_d = new PhDebug();\n\treturn _d;\n}\n\n/**\n * @brief Message handler that filter all output\n */\nvoid noMessageOutput(QtMsgType, const QMessageLogContext &, const QString &)\n{\n\n}\n\nvoid PhDebug::disable()\n{\n\tqInstallMessageHandler(noMessageOutput);\n}\n\nQDebug PhDebug::debug(const char *fileName, int lineNumber, const char *functionName, int messageLogLevel)\n{\n\tinstance()->_currentLogLevel = messageLogLevel;\n\treturn QMessageLogger(fileName, lineNumber, functionName).debug();\n}\n\nQDebug PhDebug::error(const char *fileName, int lineNumber, const char *functionName)\n{\n\tinstance()->_currentLogLevel = 0;\n\treturn QMessageLogger(fileName, lineNumber, functionName).critical();\n}\n\nPhDebug::PhDebug()\n{\n\tqInstallMessageHandler(this->messageOutput);\n\n\tQString logDirPath;\n\n#if defined(Q_OS_MAC)\n\tlogDirPath = QDir::homePath() + \"/Library/Logs/Phonations/\";\n#elif defined(Q_OS_WIN)\n\tlogDirPath = QString(qgetenv(\"APPDATA\")) + \"/Phonations\";\n#endif\n\n\tif(QFile(logDirPath).exists()) {\n\t\tQDir logDir(logDirPath);\n\t\tif(!logDir.exists()) {\n\t\t\tQDir().mkdir(logDirPath);\n\t\t}\n\t\t_logFileName = logDirPath + APP_NAME + \".log\";\n\t\tQFile * f = new QFile(_logFileName);\n\t\tf->open(QIODevice::WriteOnly | QIODevice::Text | QIODevice::Append);\n\t\tf->write(\"\\n\\n\");\n\t\t_textLog = new QTextStream(f);\n\t}\n\telse\n\t\t_textLog = NULL;\n\n\t_displayDate = false;\n\t_displayTime = true;\n\t_displayFunctionName = true;\n\t_displayFileName = true;\n\t_displayLine = true;\n\t_showConsole = true;\n\t_logMask = 1;\n}\n\nvoid PhDebug::setLogMask(int mask)\n{\n\tinstance()->_logMask = mask;\n}\n\nint PhDebug::getLogMask()\n{\n\treturn instance()->_logMask;\n}\n\nQDebug operator <<(QDebug stream, const QEvent * event) {\n\tstatic int eventEnumIndex = QEvent::staticMetaObject\n\t                            .indexOfEnumerator(\"Type\");\n\tstream << \"QEvent\";\n\tif (event) {\n\t\tQString name = QEvent::staticMetaObject\n\t\t               .enumerator(eventEnumIndex).valueToKey(event->type());\n\t\tif (!name.isEmpty()) stream << name; else stream << event->type();\n\t}\n\telse {\n\t\tstream << (void*)event;\n\t}\n\treturn stream.maybeSpace();\n}\n", "name": "libs/PhTools/PhDebug.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef PHDEBUG_H\n#define PHDEBUG_H\n\n#include <QDebug>\n#include <QMutex>\n\n/** PHERR allow to log error */\n#define PHERR PhDebug::error(__FILE__, __LINE__, __FUNCTION__)\n\n/** PHDBG allow to have a multi level log system */\n#define PHDBG(messageLogLevel) PhDebug::debug(__FILE__, __LINE__, __FUNCTION__, messageLogLevel)\n\n/** PHDEBUG is the default log system */\n#define PHDEBUG PHDBG(0)\n\n/** PHNQ remove the quote when outputing a QString */\n#define PHNQ(string) (string).toStdString().c_str()\n\n/**\n * @brief A custom log system\n *\n * It provides a powerful log tool, using mask to show/hide some (un)desired\n * log informations which can be saved - or not - to a local file.\n */\nclass PhDebug\n{\npublic:\n\t/**\n\t * @brief Disable the log output\n\t */\n\tstatic void disable();\n\t/**\n\t * @brief Setup the debug log stream state\n\t *\n\t * This log stream can filter some message when the message log level is not fitting the mask.\n\t *\n\t * @param fileName The file name where the log was triggered from\n\t * @param lineNumber The line number where the log was triggered from\n\t * @param functionName The function name where the log was triggered from\n\t * @param messageLogLevel The log level\n\t * @return A QDebug stream\n\t */\n\tstatic QDebug debug(const char *fileName, int lineNumber, const char *functionName, int messageLogLevel);\n\n\t/**\n\t * @brief Setup the error log stream state\n\t *\n\t * @param fileName The file name where the log was triggered from\n\t * @param lineNumber The line number where the log was triggered from\n\t * @param functionName The function name where the log was triggered from\n\t * @return A QCritical stream\n\t */\n\tstatic QDebug error(const char *fileName, int lineNumber, const char *functionName);\n\n\t/**\n\t * @brief Set the log mask\n\t *\n\t * Enable the message with the corresponding mak :\n\t *\n\t *\tAlways\t\t\t=>\t0\n\t *\tCustom\t\t\t=>\t1-7\n\t *\tGraphic\t\t\t=>\t8-11\n\t *\tGraphicStrip\t=>\t12-15\n\t *\tStrip\t\t\t=>\t16-19\n\t *  Sync\t\t\t=>\t20-23\n\t *  Video\t\t\t=>\t24-27\n\t *\tCommonUI\t\t=>\t28-31\n\t *\n\t * @param mask The desired mask\n\t *\n\t * For exemple if mask = 0b1110000001111111 (57471)\n\t *\n\t * It the debugger will show the Always, Customs and Strip messages\n\t */\n\tstatic void setLogMask(int mask);\n\t/**\n\t * @brief Get the current log mask\n\t * @return The log mask.\n\t */\n\tstatic int getLogMask();\n\t/**\n\t * @brief Get the log location\n\t * As the log file is with the others system & user logs, and this place\n\t * is plateform dependent, it's useful to be able to tell the users where\n\t * to find the log file.\n\t * @return The url of the log file\n\t */\n\tstatic QString logLocation();\n\n\t/**\n\t * @brief show log in console\n\t * @param show enable or disable the console log.\n\t */\n\tstatic void showConsole(bool show);\n\n\t/**\n\t * @brief Specify what a log message shall display\n\t * @param date Display the date\n\t * @param time Display the time\n\t * @param fileName Display the file name\n\t * @param functionName Display the function name\n\t * @param line Display the line number\n\t */\n\tstatic void setDisplay(bool date, bool time, bool fileName, bool functionName, bool line);\nprivate:\n\t/**\n\t * @brief PhDebug constructor\n\t */\n\tPhDebug();\n\n\t/**\n\t * @brief Get the singleton instance of PhDebug\n\t *\n\t * @return The debugger\n\t */\n\tstatic PhDebug* instance();\n\n\t/**\n\t * @brief Custom message output\n\t *\n\t * This function is called to create an instance of the class.\n\t * Calling the constructor publicly is not allowed. The constructor\n\t * is private and is only called by this Instance function.\n\t *\n\t * @param type The message type\n\t * @param context The message context\n\t * @param msg The message\n\t */\n\tstatic void messageOutput(QtMsgType type, const QMessageLogContext &context, const QString &msg);\n\n\tstatic PhDebug * _d;\n\tint _logMask;\n\tint _currentLogLevel;\n\tQTextStream *_textLog;\n\tQString _logFileName;\n\tbool _displayDate;\n\tbool _displayTime;\n\tbool _displayFileName;\n\tbool _displayFunctionName;\n\tbool _displayLine;\n\tbool _showConsole;\n\tQString total;\n\tQMutex _mutex;\n\n};\n\n/**\n * @brief Gives human-readable event type information\n * @param stream The debug stream\n * @param event The event\n * @return The new debug stream\n */\nQDebug operator <<(QDebug stream, const QEvent * event);\n\n#endif // PHDEBUG_H\n", "name": "libs/PhTools/PhDebug.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include <QStringList>\n\n#include \"PhDebug.h\"\n#include \"PhFileTool.h\"\n\nunsigned char PhFileTool::readChar(QFile &f, int level, QString name)\n{\n\tint offset = f.pos();\n\tunsigned char result = (unsigned char)f.read(1).data()[0];\n\tPHDBG(level) << PHNQ(QString::number(offset, 16)) << PHNQ(name) << PHNQ(QString::number(result, 16));\n\treturn result;\n}\n\nunsigned short PhFileTool::readShort(QFile &f, int level, QString name)\n{\n\tint offset = f.pos();\n\tunsigned short * p = (unsigned short*)f.read(2).data();\n\tunsigned short result = *p;\n\n\tPHDBG(level) << PHNQ(QString::number(offset, 16)) << PHNQ(name) << PHNQ(QString::number(result, 16));\n\n\treturn result;\n}\n\nint PhFileTool::readInt(QFile &f, int level, QString name)\n{\n\tint offset = f.pos();\n\tint * p = (int*)f.read(4).data();\n\tint result = *p;\n\n\tPHDBG(level) << PHNQ(QString::number(offset, 16)) << PHNQ(name) << result;\n\n\treturn result;\n}\n\nQString PhFileTool::readString(QFile &f, int level, QString name)\n{\n\tint internLevel = 4;\n\tint offset = f.pos();\n\tint size = readShort(f, internLevel);\n\n\tQString result = \"\";\n\tswitch(size) {\n\tcase 0xfeff:\n\t\treadChar(f, internLevel);\n\t\tsize = readChar(f, internLevel);\n\t\tif(size == 0xff) {\n\t\t\tsize = readShort(f, internLevel);\n\t\t\tif(size == 0xffff)\n\t\t\t\tsize = readInt(f, internLevel);\n\t\t}\n\t\tresult = QString::fromUtf16((ushort*)f.read(size * 2).data(), size);\n\t\tbreak;\n\tcase 0xffff:\n\t\tsize = readShort(f, 4);\n\t\tresult = QString::fromUtf16((ushort*)f.read(size * 2).data(), size);\n\t\tbreak;\n\tdefault:\n\t\t{\n\t\t\tQByteArray array = f.read(size);\n\t\t\tchar * tab = array.data();\n\t\t\tfor(int i = 0; i < size; i++)\n\t\t\t\tresult += tab[i];\n\t\t}\n\t}\n\n\tQString displayResult = result;\n\tQStringList resultSplit = result.split(\"\\r\\n\");\n\tif(resultSplit.count() > 3) {\n\t\tresult = resultSplit.first() + \"\\r\\n...\\r\\n\" + resultSplit.last();\n\t}\n\n\tPHDBG(level) << PHNQ(QString::number(offset, 16)) << PHNQ(name) << result << \"(\" << PHNQ(QString::number(size, 16)) << \")\";\n\n\treturn result;\n}\n", "name": "libs/PhTools/PhFileTool.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef PHFILETOOL_H\n#define PHFILETOOL_H\n\n#include <QFile>\n\n/**\n * @brief Provides tools for binary files reading\n */\nclass PhFileTool\n{\npublic:\n\t/**\n\t * @brief Read a single char\n\t * @param f The file\n\t * @param level The log level\n\t * @param name The name (for logging purpose)\n\t * @return A char\n\t */\n\tstatic unsigned char readChar(QFile &f, int level, QString name = \"???\");\n\n\t/**\n\t * @brief Read a two-bytes unsigned short\n\t * @param f The file\n\t * @param level The log level\n\t * @param name The name (for logging purpose)\n\t * @return An unsigned short\n\t */\n\tstatic unsigned short readShort(QFile &f, int level, QString name = \"???\");\n\n\t/**\n\t * @brief Read a four-bytes signed integer\n\t * @param f The file\n\t * @param level The log level\n\t * @param name The name (for logging purpose)\n\t * @return A signed int\n\t */\n\tstatic int readInt(QFile &f, int level, QString name = \"???\");\n\n\t/**\n\t * @brief Read a string\n\t *\n\t * The readString method assumes that the string starts with its size\n\t * and is followed by the character data.\n\t * If the first char is 0xFF, the next char will contain the string size\n\t * and a wide char string will be decoded.\n\t * @param f The file\n\t * @param level The log level\n\t * @param name The name (for logging purpose)\n\t * @return A string\n\t */\n\tstatic QString readString(QFile &f, int level, QString name = \"???\");\n};\n\n#endif // PHFILETOOL_H\n", "name": "libs/PhTools/PhFileTool.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include <QByteArray>\n\n#include \"PhGenericSettings.h\"\n#include \"PhDebug.h\"\n\nPhGenericSettings::PhGenericSettings(bool clear) : _settings(ORG_NAME, APP_NAME)\n{\n\tQSettings::setDefaultFormat(QSettings::NativeFormat);\n\tPHDEBUG << \"Settings file:\" << _settings.fileName();\n\tif(clear)\n\t\tthis->clear();\n}\n\nvoid PhGenericSettings::clear()\n{\n\t_settings.clear();\n}\n\nvoid PhGenericSettings::setIntValue(QString name, int value)\n{\n\t_settings.setValue(name, value);\n}\n\nint PhGenericSettings::intValue(QString name, int defaultValue)\n{\n\treturn _settings.value(name, defaultValue).toInt();\n}\n\nint PhGenericSettings::intValueWithAlias(QString name, QString alias)\n{\n\t/// If the regular value is 0, return the alias value\n\tint result = intValue(name);\n\tif(result == 0)\n\t\tresult = intValue(alias);\n\treturn result;\n}\n\nvoid PhGenericSettings::setBoolValue(QString name, bool value)\n{\n\t_settings.setValue(name, value);\n}\n\nbool PhGenericSettings::boolValue(QString name, bool defaultValue)\n{\n\treturn _settings.value(name, defaultValue).toBool();\n}\n\nvoid PhGenericSettings::setFloatValue(QString name, float value)\n{\n\t_settings.setValue(name, value);\n}\n\nfloat PhGenericSettings::floatValue(QString name, float defaultValue)\n{\n\treturn _settings.value(name, defaultValue).toFloat();\n}\n\nvoid PhGenericSettings::setStringValue(QString name, QString value)\n{\n\t_settings.setValue(name, value);\n}\n\nQString PhGenericSettings::stringValue(QString name, QString defaultValue)\n{\n\treturn _settings.value(name, defaultValue).toString();\n}\n\nvoid PhGenericSettings::setStringList(QString name, QStringList list)\n{\n\t_settings.remove(name);\n\t_settings.beginWriteArray(name);\n\tfor(int i = 0; i < list.size(); i++) {\n\t\t_settings.setArrayIndex(i);\n\t\t_settings.setValue(\"listItem\", list.at(i));\n\t}\n\t_settings.endArray();\n}\n\nQStringList PhGenericSettings::stringList(QString name)\n{\n\tQStringList list;\n\tint size = _settings.beginReadArray(name);\n\tfor(int i = 0; i < size; i++) {\n\t\t_settings.setArrayIndex(i);\n\t\tlist.append(_settings.value(\"listItem\").toString());\n\t}\n\t_settings.endArray();\n\n\treturn list;\n}\n\nvoid PhGenericSettings::setByteArray(QString name, QByteArray array)\n{\n\t_settings.setValue(name, array);\n}\n\nQByteArray PhGenericSettings::byteArray(QString name)\n{\n\treturn _settings.value(name).toByteArray();\n}\n", "name": "libs/PhTools/PhGenericSettings.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef PHGENERICSETTINGS_H\n#define PHGENERICSETTINGS_H\n\n#include <QSettings>\n#include <QStringList>\n#include <QByteArray>\n\n/** Implement the integer setter and getter for a PhGenericSettings */\n#define PH_SETTING_INT(setter, getter) \\\n\tvoid setter(int getter) { setIntValue(#getter, getter); } \\\n\tint getter() {return intValue(#getter); }\n\n/** Implement the integer setter, getter and default value for a PhGenericSettings */\n#define PH_SETTING_INT2(setter, getter, defaultValue) \\\n\tvoid setter(int getter) { setIntValue(#getter, getter); } \\\n\tint getter() {return intValue(#getter, defaultValue); }\n\n/** Implement the integer setter, getter and alias for a PhGenericSettings */\n#define PH_SETTING_INT3(setter, getter, alias) \\\n\tvoid setter(int getter) { setIntValue(#getter, getter); } \\\n\tint getter() {return intValueWithAlias(#getter, #alias); }\n\n/** Implement the unsigned char setter and getter for a PhGenericSettings */\n#define PH_SETTING_UCHAR(setter, getter) \\\n\tvoid setter(unsigned char getter) { setIntValue(#getter, getter); } \\\n\tunsigned char getter() {return intValue(#getter); }\n\n/** Implement the unsigned char setter, getter and default value for a PhGenericSettings */\n#define PH_SETTING_UCHAR2(setter, getter, defaultValue) \\\n\tvoid setter(unsigned char getter) { setIntValue(#getter, getter); } \\\n\tunsigned char getter() {return intValue(#getter, defaultValue); }\n\n/** Implement the bool setter and getter for a PhGenericSettings */\n#define PH_SETTING_BOOL(setter, getter) \\\n\tvoid setter(bool getter) { setBoolValue(#getter, getter); } \\\n\tbool getter() {return boolValue(#getter); }\n\n/** Implement the bool setter, getter and default value for a PhGenericSettings */\n#define PH_SETTING_BOOL2(setter, getter, defaultValue) \\\n\tvoid setter(bool getter) { setBoolValue(#getter, getter); } \\\n\tbool getter() {return boolValue(#getter, defaultValue); }\n\n/** Implement the float setter and getter for a PhGenericSettings */\n#define PH_SETTING_FLOAT(setter, getter) \\\n\tvoid setter(float getter) { setFloatValue(#getter, getter); } \\\n\tfloat getter() {return floatValue(#getter); }\n\n/** Implement the float setter, getter and default value for a PhGenericSettings */\n#define PH_SETTING_FLOAT2(setter, getter, defaultValue) \\\n\tvoid setter(float getter) { setFloatValue(#getter, getter); } \\\n\tfloat getter() {return floatValue(#getter, defaultValue); }\n\n/** Implement the string setter and getter for a PhGenericSettings */\n#define PH_SETTING_STRING(setter, getter) \\\n\tvoid setter(QString getter) { setStringValue(#getter, getter); } \\\n\tQString getter() {return stringValue(#getter); }\n\n/** Implement the string setter, getter and default value for a PhGenericSettings */\n#define PH_SETTING_STRING2(setter, getter, defaultValue) \\\n\tvoid setter(QString getter) { setStringValue(#getter, getter); } \\\n\tQString getter() {return stringValue(#getter, defaultValue); }\n\n/** Implement the string list setter and getter for a PhGenericSettings */\n#define PH_SETTING_STRINGLIST(setter, getter) \\\n\tvoid setter(QStringList list) { setStringList(#getter, list); } \\\n\tQStringList getter() {return stringList(#getter); }\n\n/** Implement the byte array setter and getter for a PhGenericSettings */\n#define PH_SETTING_BYTEARRAY(setter, getter) \\\n\tvoid setter(QByteArray array) { setByteArray(#getter, array); } \\\n\tQByteArray getter() {return byteArray(#getter); }\n\n/**\n * @brief A generic implementation of the module settings\n *\n * PhGenericSettings and its macro provide an easyier way to managed\n * the application settings by supplying an overlay of the QSettings\n * behaviour.\n * The main interest is to centralize the default value of each settings\n * and to insure settings name unicity and homogeneity.\n */\nclass PhGenericSettings\n{\npublic:\n\t/**\n\t * @brief PhGenericSettings constructor\n\t * @param clear True if the settings shall be reset\n\t */\n\tPhGenericSettings(bool clear = false);\n\n\t/**\n\t * @brief Reset the settings to its default value.\n\t */\n\tvoid clear();\n\nprotected:\n\t/**\n\t * @brief Set an integer value\n\t * @param name The settings name\n\t * @param value The integer value\n\t */\n\tvoid setIntValue(QString name, int value);\n\t/**\n\t * @brief Get an integer value\n\t * @param name The settings name\n\t * @param defaultValue The default value\n\t * @return The integer value\n\t */\n\tint intValue(QString name, int defaultValue = 0);\n\t/**\n\t * @brief Get an integer value with alias\n\t *\n\t * @param name The settings name\n\t * @param alias An alias\n\t * @return The integer value\n\t */\n\tint intValueWithAlias(QString name, QString alias);\n\n\t/**\n\t * @brief Set a bool value\n\t * @param name The settings name\n\t * @param value The bool value\n\t */\n\tvoid setBoolValue(QString name, bool value);\n\t/**\n\t * @brief Get a bool value\n\t * @param name The settings name\n\t * @param defaultValue The default value\n\t * @return The bool value\n\t */\n\tbool boolValue(QString name, bool defaultValue = false);\n\n\t/**\n\t * @brief Set a float value\n\t * @param name The settings name\n\t * @param value The float value\n\t */\n\tvoid setFloatValue(QString name, float value);\n\t/**\n\t * @brief Get a float value\n\t * @param name The settings name\n\t * @param defaultValue The default value\n\t * @return The float value\n\t */\n\tfloat floatValue(QString name, float defaultValue = 0);\n\t/**\n\t * @brief Set a string value\n\t * @param name The settings name\n\t * @param value The string value\n\t */\n\tvoid setStringValue(QString name, QString value);\n\t/**\n\t * @brief Get a string value\n\t * @param name The settings name\n\t * @param defaultValue The default value\n\t * @return The string value\n\t */\n\tQString stringValue(QString name, QString defaultValue = \"\");\n\t/**\n\t * @brief Set a string list\n\t * @param name The settings name\n\t * @param list The string list\n\t */\n\tvoid setStringList(QString name, QStringList list);\n\t/**\n\t * @brief Get a string list\n\t * @param name The settings name\n\t * @return The string list\n\t */\n\tQStringList stringList(QString name);\n\n\t/**\n\t * @brief Set a byte array\n\t * @param name The settings name\n\t * @param array The byte array\n\t */\n\tvoid setByteArray(QString name, QByteArray array);\n\t/**\n\t * @brief Get a byte array\n\t * @param name The settings name\n\t * @return The byte array\n\t */\n\tQByteArray byteArray(QString name);\n\nprotected:\n\t/**\n\t * @brief The QSettings object\n\t */\n\tQSettings _settings;\n};\n\n#endif // PHGENERICSETTINGS_H\n", "name": "libs/PhTools/PhGenericSettings.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#include \"PhPictureTools.h\"\n\nvoid PhPictureTools::RGBtoYUV(const unsigned char *rgb, int *yuv, int monochrome, int luminance)\n{\n\tif (monochrome) {\n#if 1                           /* these are the two formulas that I found on the FourCC site... */\n\t\tyuv[0] = (int)(0.299 * rgb[0] + 0.587 * rgb[1] + 0.114 * rgb[2]);\n\t\tyuv[1] = 128;\n\t\tyuv[2] = 128;\n#else\n\t\tyuv[0] = (int)(0.257 * rgb[0]) + (0.504 * rgb[1]) + (0.098 * rgb[2]) + 16;\n\t\tyuv[1] = 128;\n\t\tyuv[2] = 128;\n#endif\n\t}\n\telse {\n#if 1                           /* these are the two formulas that I found on the FourCC site... */\n\t\tyuv[0] = (int)(0.299 * rgb[0] + 0.587 * rgb[1] + 0.114 * rgb[2]);\n\t\tyuv[1] = (int)((rgb[2] - yuv[0]) * 0.565 + 128);\n\t\tyuv[2] = (int)((rgb[0] - yuv[0]) * 0.713 + 128);\n#else\n\t\tyuv[0] = (0.257 * rgb[0]) + (0.504 * rgb[1]) + (0.098 * rgb[2]) + 16;\n\t\tyuv[1] = 128 - (0.148 * rgb[0]) - (0.291 * rgb[1]) + (0.439 * rgb[2]);\n\t\tyuv[2] = 128 + (0.439 * rgb[0]) - (0.368 * rgb[1]) - (0.071 * rgb[2]);\n#endif\n\t}\n\n\tif (luminance != 100) {\n\t\tyuv[0] = yuv[0] * luminance / 100;\n\t\tif (yuv[0] > 255)\n\t\t\tyuv[0] = 255;\n\t}\n}\n\nvoid PhPictureTools::YUVtoRGB(const int *yuv, unsigned char *rgb)\n{\n\tint r = (yuv[0] + 701 * (yuv[2] - 128) / 500);\n\trgb[0] = (r > 255) ? 255 : (r < 0 ? 0 : (unsigned char)r);\n\tint g = (yuv[0] - (34414 * (yuv[1] - 128) + 71414 * (yuv[2] - 128)) / 100000);\n\trgb[1] = (g > 255) ? 255 : (g < 0 ? 0 : (unsigned char)g);\n\tint b = (yuv[0] + 1772 * (yuv[1] - 128) / 1000);\n\trgb[2] = (b > 255) ? 255 : (g < 0 ? 0 : (unsigned char)b);\n}\n\nvoid PhPictureTools::ConvertRGBtoYV12(const unsigned char *rgbIn, unsigned char *yuvOut, int w, int h, int monochrome, int luminance)\n{\n\tunsigned char rgb[3];\n\tint yuv[3];\n\tunsigned char *op[3];\n\n\top[0] = yuvOut;\n\top[1] = op[0] + w*h;\n\top[2] = op[1] + w*h/4;\n\tfor (int y = 0; y < h; ++y) {\n\t\tfor (int x = 0; x < w; ++x) {\n\t\t\t/* Swap R and B */\n\t\t\trgb[0] = rgbIn[2];\n\t\t\trgb[1] = rgbIn[1];\n\t\t\trgb[2] = rgbIn[0];\n\n\t\t\tRGBtoYUV(rgb, yuv, monochrome, luminance);\n\t\t\t*(op[0]++) = yuv[0];\n\t\t\tif (x % 2 == 0 && y % 2 == 0) {\n\t\t\t\t*(op[1]++) = yuv[2];\n\t\t\t\t*(op[2]++) = yuv[1];\n\t\t\t}\n\t\t\trgbIn += 3;\n\t\t}\n\t}\n}\n\nvoid PhPictureTools::ConvertYV12toRGB(const unsigned char *yuvIn, unsigned char *rgbOut, int w, int h)\n{\n\tint yuv[3];\n\tconst unsigned char *op[3];\n\n\top[0] = yuvIn;\n\top[1] = op[0] + w * h;\n\top[2] = op[1] + w * h /4;\n\tfor(int y = 0; y < h; ++y) {\n\t\tfor (int x = 0; x < w; ++x) {\n\t\t\tyuv[0] = *(op[0]++);\n\t\t\tif (x % 2 == 0 && y % 2 == 0) {\n\t\t\t\tyuv[2] = *(op[1]++);\n\t\t\t\tyuv[1] = *(op[2]++);\n\t\t\t}\n\t\t\tYUVtoRGB(yuv, rgbOut);\n\t\t\trgbOut += 3;\n\t\t}\n\t}\n}\n\nunsigned char *PhPictureTools::generateRGBPattern(int w, int h)\n{\n\tunsigned char * rgbOut = new unsigned char[w * h * 3];\n\n\tfor(int y = 0; y < h; ++y) {\n\t\tfor (int x = 0; x < w; ++x) {\n\t\t\trgbOut[3 * (y * w + x)] = 255;\n\t\t\trgbOut[3 * (y * w + x) + 1] = 0;\n\t\t\trgbOut[3 * (y * w + x) + 2] = 0;\n\t\t}\n\t}\n\treturn rgbOut;\n}\n\nunsigned char *PhPictureTools::generateYUVPattern(int w, int h)\n{\n\tunsigned char * yuvOut = new unsigned char[w * h * 3 / 2];\n\n\tunsigned char *op[3];\n\n\top[0] = yuvOut;\n\top[1] = op[0] + w*h;\n\top[2] = op[1] + w*h/4;\n\n\tfor (int y = 0; y < h; ++y) {\n\t\tfor (int x = 0; x < w; ++x) {\n\t\t\t*(op[0]++) = y * 256 / h;\n\t\t\tif (x % 2 == 0 && y % 2 == 0) {\n\t\t\t\t*(op[1]++) = 160;\n\t\t\t\t*(op[2]++) = 160;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn yuvOut;\n}\n", "name": "libs/PhTools/PhPictureTools.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef PHPICTURETOOLS_H\n#define PHPICTURETOOLS_H\n\n/**\n * @brief It provides a lot of useful picture tools\n *\n * It can do space color convertions and picture pattern generation.\n */\nclass PhPictureTools\n{\npublic:\n\t/**\n\t * @brief Convert from RGB to YUV\n\t * @param rgb pointer to the source frame\n\t * @param yuv pointer to the destination frame\n\t * @param monochrome desired monochrome value\n\t * @param luminance desired luminance value\n\t */\n\tstatic void RGBtoYUV(const unsigned char *rgb, int *yuv, int monochrome, int luminance);\n\t/**\n\t * @brief Convert from YUV to RGB\n\t * @param yuv pointer to the source frame\n\t * @param rgb pointer to the destination frame\n\t */\n\tstatic void YUVtoRGB(const int *yuv, unsigned char *rgb);\n\t/**\n\t * @brief Convert from RGB to YV12\n\t * @param rgbIn pointer to the source frame\n\t * @param yuvOut pointer to the destination frame\n\t * @param w source width\n\t * @param h source height\n\t * @param monochrome desired monochrome value\n\t * @param luminance desired luminance value\n\t */\n\tstatic void ConvertRGBtoYV12(const unsigned char *rgbIn, unsigned char *yuvOut, int w, int h, int monochrome, int luminance);\n\t/**\n\t * @brief Convert from YV12 to RGB\n\t * @param yuvIn pointer to the source frame\n\t * @param rgbOut pointer to the destination frame\n\t * @param w source width\n\t * @param h source height\n\t */\n\tstatic void ConvertYV12toRGB(const unsigned char *yuvIn, unsigned char *rgbOut, int w, int h);\n\t/**\n\t * @brief generate a RGB pattern\n\t *\n\t * The pattern correspon to a red frame.\n\t *\n\t * @param w desired width\n\t * @param h desired height\n\t * @return a pointer to the RGB frame\n\t */\n\tstatic unsigned char  * generateRGBPattern(int w, int h);\n\t/**\n\t * @brief generate a YUV pattern\n\t * @param w desired width\n\t * @param h desired height\n\t * @return a pointer to the RGB frame\n\t */\n\tstatic unsigned char * generateYUVPattern(int w, int h);\n};\n\n#endif // PHPICTURETOOLS_H\n", "name": "libs/PhTools/PhPictureTools.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#include \"PhTickCounter.h\"\n#include \"PhDebug.h\"\n\nPhTickCounter::PhTickCounter() : _frequency(0), _tickCount(0)\n{\n\t_timer.start();\n}\n\nvoid PhTickCounter::tick()\n{\n\t_tickCount++;\n\tint elapsed = _timer.elapsed();\n\tif(elapsed > 1000) {\n\t\t_frequency = _tickCount;\n\t\t_timer.restart();\n\t\t_tickCount = 0;\n\t}\n}\n", "name": "libs/PhTools/PhTickCounter.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef TICKCOUNTER_H\n#define TICKCOUNTER_H\n\n#include <QTime>\n\n/**\n * @brief Utility that allow to meter the frequency of a signal\n * connected to the tick slot\n *\n * It takes 1 second to be accurate.\n */\nclass PhTickCounter\n{\npublic:\n\tPhTickCounter();\n\n\t/**\n\t * @brief Get frequency\n\t * @return the measured frequency\n\t */\n\tint frequency() {\n\t\treturn _frequency;\n\t}\n\npublic slots:\n\t/**\n\t * @brief Handle the tick\n\t *\n\t * This slot must be called every time the measured action occurs\n\t */\n\tvoid tick();\n\nprivate:\n\tQTime _timer;\n\tint _frequency;\n\tint _tickCount;\n};\n\n#endif // TICKCOUNTER_H\n", "name": "libs/PhTools/PhTickCounter.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef PHTIME_H\n#define PHTIME_H\n\n#include <QtGlobal>\n#include <limits>\n\n/** @brief Time unit in ticks : 1 second = 24000 ticks */\ntypedef qint64 PhTime;\n\n/** @brief PhTimeScale is a type used for time scale value */\ntypedef int PhTimeScale;\n\n/** @brief PhRate is a type used for rate value */\ntypedef double PhRate;\n\n/** @brief Type for the timecode frame */\ntypedef long PhFrame;\n\n/** @brief The maximum PhTime value */\n#define PHTIMEMAX std::numeric_limits<PhTime>::max()\n\n/** @brief The minimum PhTime value */\n#define PHTIMEMIN std::numeric_limits<PhTime>::min()\n\n/** @brief The maximum PhFrame value */\n#define PHFRAMEMAX std::numeric_limits<PhFrame>::max()\n\n/** @brief The minimum PhFrame value */\n#define PHFRAMEMIN std::numeric_limits<PhFrame>::min()\n\n#endif // PHTIME_H\n", "name": "libs/PhTools/PhTime.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n\n#include <algorithm>\n#include <QStringList>\n\n#include \"PhTimeCode.h\"\n\n#include \"PhDebug.h\"\n\nQString PhTimeCode::stringFromFrame(PhFrame frame, PhTimeCodeType type) {\n\tunsigned int hhmmssff[4];\n\tComputeHhMmSsFf(hhmmssff, frame, type);\n\treturn QString(\"%1%2:%3:%4:%5\").arg((frame < 0) ? \"-\" : \"\",\n\t                                    QString::number(hhmmssff[0]).rightJustified(2, '0'),\n\t                                    QString::number(hhmmssff[1]).rightJustified(2, '0'),\n\t                                    QString::number(hhmmssff[2]).rightJustified(2, '0'),\n\t                                    QString::number(hhmmssff[3]).rightJustified(2, '0'));\n}\n\nPhFrame PhTimeCode::frameFromString(QString string, PhTimeCodeType type) {\n\tlong sign = 1;\n\tif ((string.length() > 0) && string.at(0) == '-') {\n\t\tsign = -1;\n\t\tstring = string.remove(0, 1);\n\t}\n\tQStringList list = string.split(':');\n\tunsigned int hhmmssff[4];\n\tmemset(hhmmssff, 0, 4 * sizeof(unsigned int));\n\n\tfor (int i = 0; i < std::min(4, list.count()); i++) {\n\t\tint k = i;\n\t\tif(list.count() < 4)\n\t\t\tk += 4 - list.count();\n\t\thhmmssff[k] = list.at(i).toInt();\n\t}\n\treturn sign * frameFromHhMmSsFf(hhmmssff, type);\n}\n\nunsigned int PhTimeCode::bcdFromFrame(PhFrame frame, PhTimeCodeType type) {\n\tunsigned int hhmmssff[4];\n\tunsigned int result;\n\tComputeHhMmSsFf(hhmmssff, frame, type);\n\n\tresult = hhmmssff[3] % 10;\n\tresult += (hhmmssff[3] / 10) << 4;\n\tresult += (hhmmssff[2] % 10) << 8;\n\tresult += (hhmmssff[2] / 10) << 12;\n\tresult += (hhmmssff[1] % 10) << 16;\n\tresult += (hhmmssff[1] / 10) << 20;\n\tresult += (hhmmssff[0] % 10) << 24;\n\tresult += (hhmmssff[0] / 10) << 28;\n\n\treturn result;\n}\n\nPhFrame PhTimeCode::frameFromBcd(unsigned int bcd, PhTimeCodeType type) {\n\tunsigned int hhmmssff[4];\n\n\thhmmssff[0] = (bcd >> 28) * 10;\n\thhmmssff[0] += (bcd >> 24) & 0x0f;\n\thhmmssff[1] = ((bcd >> 20) & 0x0f) * 10;\n\thhmmssff[1] += (bcd >> 16) & 0x0f;\n\thhmmssff[2] = ((bcd >> 12) & 0x0f) * 10;\n\thhmmssff[2] += (bcd >> 8) & 0x0f;\n\thhmmssff[3] = ((bcd >> 4) & 0x0f) * 10;\n\thhmmssff[3] += bcd & 0x0f;\n\n\treturn frameFromHhMmSsFf(hhmmssff, type);\n}\n\nbool PhTimeCode::isDrop(PhTimeCodeType type) {\n\treturn type == PhTimeCodeType2997;\n}\n\nPhFrame PhTimeCode::getFps(PhTimeCodeType type) {\n\tswitch (type) {\n\tcase PhTimeCodeType2398:\n\tcase PhTimeCodeType24:\n\t\treturn 24;\n\tcase PhTimeCodeType25:\n\t\treturn 25;\n\tcase PhTimeCodeType2997:\n\t\treturn 30;\n\t}\n}\n\nPhTime PhTimeCode::timePerFrame(PhTimeCodeType type)\n{\n\tswitch (type) {\n\tcase PhTimeCodeType2398:\n\t\treturn 1001;\n\tcase PhTimeCodeType24:\n\t\treturn 1000;\n\tcase PhTimeCodeType25:\n\t\treturn 960;\n\tcase PhTimeCodeType2997:\n\t\treturn 801;\n\t}\n}\n\nPhTime PhTimeCode::timeFromString(QString string, PhTimeCodeType type)\n{\n\treturn frameFromString(string, type) * timePerFrame(type);\n}\n\nQString PhTimeCode::stringFromTime(PhTime time, PhTimeCodeType type)\n{\n\treturn stringFromFrame(time / timePerFrame(type), type);\n}\n\nvoid PhTimeCode::ComputeHhMmSsFf(unsigned int *hhmmssff, PhFrame frame, PhTimeCodeType type) {\n\tPhFrame fps = getFps(type);\n\tbool drop = isDrop(type);\n\tPhFrame n = std::abs(frame);\n\n\t// computing hour\n\tPhFrame framePerHour = 3600 * fps;\n\tif(drop)\n\t\tframePerHour -= 108;\n\thhmmssff[0] = (unsigned int)(n / framePerHour);\n\tn = n % framePerHour;\n\n\t// computing tenth of minutes\n\tPhFrame framePerTenMinutes = 600 * fps;\n\tif(drop)\n\t\tframePerTenMinutes -= 18;\n\thhmmssff[1] = (unsigned int)(10 * (n / framePerTenMinutes));\n\tn = n % framePerTenMinutes;\n\n\t// computing minutes\n\tPhFrame framePerMinute = 60 * fps;\n\tif (n >= framePerMinute) {\n\t\thhmmssff[1] += 1;\n\t\tn -= framePerMinute;\n\n\t\tif (drop)\n\t\t\tframePerMinute -= 2;\n\n\t\thhmmssff[1] += n / framePerMinute;\n\t\tn = n % framePerMinute;\n\t}\n\n\t// computing seconds\n\tPhFrame framePerSecond = fps;\n\n\tif (drop && (hhmmssff[1] % 10 > 0)) {\n\t\tif (n < framePerSecond - 2) {\n\t\t\thhmmssff[2] = 0;\n\t\t\tn += 2;\n\t\t}\n\t\telse {\n\t\t\thhmmssff[2] = (unsigned int)(1 + (n - framePerSecond + 2) / framePerSecond);\n\t\t\tn = (n - framePerSecond + 2) % framePerSecond;\n\t\t}\n\t}\n\telse {\n\t\thhmmssff[2] = (unsigned int)(n / framePerSecond);\n\t\tn = n % framePerSecond;\n\t}\n\n\thhmmssff[3] = (unsigned int)n;\n}\n\nPhFrame PhTimeCode::frameFromHhMmSsFf(unsigned int *hhmmssff, PhTimeCodeType type) {\n\tPhFrame fps = getFps(type);\n\n\tif (hhmmssff[1] >= 60) {\n\t\tPHDEBUG << \"Bad minute value:\" << QString::number(hhmmssff[1]);\n\t\thhmmssff[1] = 0;\n\t}\n\tif (hhmmssff[2] >= 60) {\n\t\tPHDEBUG << \"Bad second value:\" << QString::number(hhmmssff[2]);\n\t\thhmmssff[2] = 0;\n\t}\n\tif (hhmmssff[3] >= fps) {\n\t\tPHDEBUG << \"Bad frame value:\" << QString::number(hhmmssff[3]);\n\t\thhmmssff[3] = 0;\n\t}\n\tPhFrame dropframe = 0;\n\tif (isDrop(type)) {\n\t\t// counting drop per hour\n\t\tdropframe += hhmmssff[0] * 108;\n\t\t// counting drop per tenth of minute\n\t\tdropframe += (hhmmssff[1] / 10) * 18;\n\t\t// counting drop per minute\n\t\tdropframe += (hhmmssff[1] % 10) * 2;\n\t}\n\treturn (((hhmmssff[0] * 60) + hhmmssff[1]) * 60 + hhmmssff[2]) * fps + hhmmssff[3] - dropframe;\n}\n", "name": "libs/PhTools/PhTimeCode.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef PHTIMECODE_H\n#define PHTIMECODE_H\n\n#include \"PhTime.h\"\n\n/**\n * @brief Different type of timecode.\n *\n * Enumerate the different type of timecode supported by the system.\n */\ntypedef enum {\n\tPhTimeCodeType2398,\n\tPhTimeCodeType24,\n\tPhTimeCodeType25,\n\tPhTimeCodeType2997\n} PhTimeCodeType;\n\n/** @brief Timecode representation utility.\n *\n * Provide tools for converting between frame, string representation and\n * BCD representation of a timecode value.\n */\nclass PhTimeCode\n{\npublic:\n\t/**\n\t * @brief Create a timecode string representation from a frame number and a type.\n\t *\n\t * @param frame A frame number.\n\t * @param type A PhTimeCodeType value.\n\t * @return An string* timecode representation.\n\t */\n\tstatic QString stringFromFrame(PhFrame frame, PhTimeCodeType type);\n\n\t/**\n\t * @brief Compute the frame number from a timecode string representation and a type.\n\t *\n\t * @param string A string.\n\t * @param type A PhTimeCodeType value.\n\t * @return The corresponding frame number.\n\t */\n\tstatic PhFrame frameFromString(QString string, PhTimeCodeType type);\n\n\t/**\n\t * @brief Compute the frame number from a timecode binary coded decimal (BCD) representation and a type.\n\t *\n\t * @param bcd A BCD value.\n\t * @param type A PhTimeCodeType value.\n\t * @return The corresponding frame number.\n\t */\n\tstatic PhFrame frameFromBcd(unsigned int bcd, PhTimeCodeType type);\n\n\t/**\n\t * @brief Get the time per frame according to a type of TC\n\t * @param type A timecode type\n\t * @return A time value\n\t */\n\tstatic PhTime timePerFrame(PhTimeCodeType type);\n\n\t/**\n\t * @brief Compute the time value from a timecode string representation and a type.\n\t * @param string A string\n\t * @param type A timecode type\n\t * @return A time value\n\t */\n\tstatic PhTime timeFromString(QString string, PhTimeCodeType type);\n\n\t/**\n\t * @brief Create a timecode string representation from a time value and a type.\n\t * @param time A time value\n\t * @param type A timecode type\n\t * @return A string\n\t */\n\tstatic QString stringFromTime(PhTime time, PhTimeCodeType type);\n\n\t/**\n\t * @brief Create a timecode BCD representation from a frame number and a type.\n\t *\n\t * @param frame A frame number.\n\t * @param type A PhTimeCodeType value.\n\t * @return A timecode BCD representation.\n\t */\n\tstatic unsigned int bcdFromFrame(PhFrame frame, PhTimeCodeType type);\n\n\t/**\n\t * @brief Compute the HH, MM, SS and FF timecode component from a frame number and a type.\n\t *\n\t * @param hhmmssff Array that will be filled with the corresponding HH, MM, SS, FF values.\n\t * @param frame Frame number.\n\t * @param type A timecode type.\n\t */\n\tstatic void ComputeHhMmSsFf(unsigned int *hhmmssff, PhFrame frame, PhTimeCodeType type);\n\n\t/**\n\t * @brief Compute frame number from the HH, MM, SS and FF timecode component and a type.\n\t *\n\t * @param hhmmssff Array containing the HH, MM, SS, FF values.\n\t * @param type A timecode type.\n\t * @return The corresponding frame number.\n\t */\n\tstatic PhFrame frameFromHhMmSsFf(unsigned int * hhmmssff, PhTimeCodeType type);\n\n\t/**\n\t * @brief Check if the timecode type is dropframe.\n\t *\n\t * @param type A timecode type.\n\t * @return true if the timecode type is dropframe.\n\t */\n\tstatic bool isDrop(PhTimeCodeType type);\n\n\t/**\n\t * @brief check if the timecode type frame per second.\n\t *\n\t * @param type A timecode type.\n\t * @return Amount of frame per second.\n\t */\n\tstatic PhFrame getFps(PhTimeCodeType type);\n};\n\n#endif // PHTIMECODE_H\n", "name": "libs/PhTools/PhTimeCode.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include <QCoreApplication>\n#include \"phdebug.h\"\n\n#include <QtCore/QCoreApplication>\n#include <QDir>\n#include <iostream>\n\n\nint main()\n{\n    // init the logging mechanism\n    QsLogging::Logger& logger = QsLogging::Logger::instance();\n    logger.setLoggingLevel(QsLogging::TraceLevel);\n    const QString sLogPath(QDir(\"../../../\").filePath(\"log.txt\"));\n    QsLogging::DestinationPtr fileDestination(\n                QsLogging::DestinationFactory::MakeFileDestination(sLogPath) );\n    QsLogging::DestinationPtr debugDestination(\n                QsLogging::DestinationFactory::MakeDebugOutputDestination() );\n    logger.addDestination(debugDestination.get());\n    logger.addDestination(fileDestination.get());\n    QLOG_INFO() << \"Program started\";\n    QLOG_INFO() << \"Built with Qt\" << QT_VERSION_STR << \"running on\" << qVersion();\n\n    QLOG_TRACE() << \"Here's a\" << QString(\"trace\") << \"message\";\n    QLOG_DEBUG() << \"Here's a\" << static_cast<int>(QsLogging::DebugLevel) << \"message\";\n    QLOG_WARN()  << \"Uh-oh!\";\n    qDebug() << \"This message won't be picked up by the logger\";\n    QLOG_ERROR() << \"An error has occurred\";\n    qWarning() << \"Neither will this one\";\n    QLOG_FATAL() << \"Fatal error!\";\n\n    const int ret = 0;\n    std::cout << std::endl << \"Press any key...\";\n    std::cin.get();\n    QLOG_INFO() << \"Program exited with return code\" << ret;\n\n    return 0;\n}\n", "name": "libs/PhTools/PhDebug/main.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include \"phdebug.h\"\n#include \"QDebug\"\n\nusing namespace test;\n\nvoid PhDebug(QString msg)\n{\n\n    PHDEBUG << test::Audio;\n    PHDEBUG <<  test::DoCommand;\n    PHDEBUG <<  test::LTC;\n    PHDEBUG <<  test::LTC;\n    PHDEBUG <<  test::Clock;\n    PHDEBUG <<  test::Sony;\n\n    PHDEBUG << \"@\" + QString::number(LTC) + \": \" + msg;\n    QtMsgType\n}\n\n", "name": "libs/PhTools/PhDebug/phdebug.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef PHDEBUG_H\n#define PHDEBUG_H\n#include <QString>\n#include <QObject>\n\nnamespace test\n{\nenum MethodLogLevel\n{\n    None = 0,\t// 0\n    Basic = 1,\t// 1\n    Action = 1 << 1,\t// 2\n    Extra = 1 << 2,\t// 4\n    Process = 1 << 3,\t// 8\n    Render = 1 << 4,\t// 16\n    Clock = 1 << 5,\t// 32\n    LockPainter = 1 << 6,\t// 64\n    PresentVideo = 1 << 7,\t// 128\n    Audio = 1 << 8,\t// 256\n    LockAudio = 1 << 9,\t// 512\n    OnChange = 1 << 10,\t// 1024\n    LTC = 1 << 11,\t// 2048\n    LockDoc = 1 << 12,\t// 4096\n    Time = 1 << 13,\t// 8192\n    DoCommand = 1 << 14,\t// 16384\n    Shape = 1 << 15,\t// 32768\n    WinForm = 1 << 16,\t// 65536\n    LockPlayer = 1 << 17,\n    RunEdit = 1 << 18,\n    Sony = 1 << 19\n};\nenum MethodLogType\n{\n    Empty = 0,\n    Debug = 1,\n    Console = 2,\n    File = 4,\n    Trace = 8\n};\n\n}\n\nvoid PhDebug(QString msg);\n\n\n#endif // PHDEBUG_H\n", "name": "libs/PhTools/PhDebug/phdebug.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#include \"PhVideoEngine.h\"\n\nPhVideoEngine::PhVideoEngine(bool useAudio, QObject *parent) :  QObject(parent),\n\t_settings(NULL),\n\t_fileName(\"\"),\n\t_clock(PhTimeCodeType25),\n\t_firstFrame(0),\n\t_pFormatContext(NULL),\n\t_videoStream(NULL),\n\t_videoFrame(NULL),\n\t_pSwsCtx(NULL),\n\t_rgb(NULL),\n\t_currentFrame(PHFRAMEMIN),\n\t_useAudio(useAudio),\n\t_audioStream(NULL),\n\t_audioFrame(NULL)\n{\n\tPHDEBUG << \"Using FFMpeg widget for video playback.\";\n\tav_register_all();\n\tavcodec_register_all();\n\n\t_testTimer.start();\n}\n\nbool PhVideoEngine::ready()\n{\n\treturn (_pFormatContext && _videoStream && _videoFrame);\n}\n\nvoid PhVideoEngine::setDeinterlace(bool deinterlace)\n{\n\t_deinterlace = deinterlace;\n\t_currentFrame = PHFRAMEMIN;\n}\n\nbool PhVideoEngine::open(QString fileName)\n{\n\tclose();\n\tPHDEBUG << fileName;\n\tif(avformat_open_input(&_pFormatContext, fileName.toStdString().c_str(), NULL, NULL) < 0)\n\t\treturn false;\n\n\t// Retrieve stream information\n\tif (avformat_find_stream_info(_pFormatContext, NULL) < 0)\n\t\treturn false; // Couldn't find stream information\n\n\tav_dump_format(_pFormatContext, 0, fileName.toStdString().c_str(), 0);\n\n\t_firstFrame = 0;\n\t_videoStream = NULL;\n\t_audioStream = NULL;\n\n\t// Find video stream :\n\tfor(int i = 0; i < (int)_pFormatContext->nb_streams; i++) {\n\t\tAVMediaType streamType = _pFormatContext->streams[i]->codec->codec_type;\n\t\tPHDEBUG << i << \":\" << streamType;\n\t\tswitch(streamType) {\n\t\tcase AVMEDIA_TYPE_VIDEO:\n\t\t\t_videoStream = _pFormatContext->streams[i];\n\t\t\tPHDEBUG << \"\\t=> video\";\n\t\t\tbreak;\n\t\tcase AVMEDIA_TYPE_AUDIO:\n\t\t\tif(_useAudio && (_audioStream == NULL))\n\t\t\t\t_audioStream = _pFormatContext->streams[i];\n\t\t\tPHDEBUG << \"\\t=> audio\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPHDEBUG << \"\\t=> unknown\";\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(_videoStream == NULL)\n\t\treturn false;\n\n\t// Reading timestamp :\n\tAVDictionaryEntry *tag = av_dict_get(_pFormatContext->metadata, \"timecode\", NULL, AV_DICT_IGNORE_SUFFIX);\n\tif(tag == NULL)\n\t\ttag = av_dict_get(_videoStream->metadata, \"timecode\", NULL, AV_DICT_IGNORE_SUFFIX);\n\n\tif(tag) {\n\t\tPHDEBUG << \"Found timestamp:\" << tag->value;\n\t\t_firstFrame = PhTimeCode::frameFromString(tag->value, _clock.timeCodeType());\n\t}\n\n\t// Looking for timecode type\n\tfloat fps = this->framePerSecond();\n\tif(fps == 0) {\n\t\tPHDEBUG << \"Bad fps detect => assuming 25\";\n\t\t_clock.setTimeCodeType(PhTimeCodeType25);\n\t}\n\telse if(fps < 24)\n\t\t_clock.setTimeCodeType(PhTimeCodeType2398);\n\telse if (fps < 24.5f)\n\t\t_clock.setTimeCodeType(PhTimeCodeType24);\n\telse if (fps < 26)\n\t\t_clock.setTimeCodeType(PhTimeCodeType25);\n\telse if (fps < 30)\n\t\t_clock.setTimeCodeType(PhTimeCodeType2997);\n\telse {\n#warning /// @todo patch for #107 => find better fps decoding\n\t\tPHDEBUG << \"Bad fps detect => assuming 25\";\n\t\t_clock.setTimeCodeType(PhTimeCodeType25);\n\t}\n\n\tPHDEBUG << \"size : \" << _videoStream->codec->width << \"x\" << _videoStream->codec->height;\n\tAVCodec * videoCodec = avcodec_find_decoder(_videoStream->codec->codec_id);\n\tif(videoCodec == NULL) {\n\t\tPHDEBUG << \"Unable to find the codec:\" << _videoStream->codec->codec_id;\n\t\treturn false;\n\t}\n\n\n\tif (avcodec_open2(_videoStream->codec, videoCodec, NULL) < 0) {\n\t\tPHDEBUG << \"Unable to open the codec:\" << _videoStream->codec;\n\t\treturn false;\n\t}\n\n\t_videoFrame = avcodec_alloc_frame();\n\n\tPHDEBUG << \"length:\" << this->length();\n\tPHDEBUG << \"fps:\" << this->framePerSecond();\n\t_currentFrame = PHFRAMEMIN;\n\t_clock.setFrame(0);\n\n\tif(_audioStream) {\n\t\tAVCodec* audioCodec = avcodec_find_decoder(_audioStream->codec->codec_id);\n\t\tif(audioCodec) {\n\t\t\tif(avcodec_open2(_audioStream->codec, audioCodec, NULL) < 0) {\n\t\t\t\tPHDEBUG << \"Unable to open audio codec.\";\n\t\t\t\t_audioStream = NULL;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_audioFrame = avcodec_alloc_frame();\n\t\t\t\tPHDEBUG << \"Audio OK.\";\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tPHDEBUG << \"Unable to find codec for audio.\";\n\t\t\t_audioStream = NULL;\n\t\t}\n\t}\n\n\tgoToFrame(0);\n\t_fileName = fileName;\n\n\treturn true;\n}\n\nvoid PhVideoEngine::close()\n{\n\tPHDEBUG;\n\tif(_rgb) {\n\t\tdelete _rgb;\n\t\t_rgb = NULL;\n\t}\n\n\tif(_pFormatContext) {\n\t\tavformat_close_input(&_pFormatContext);\n\t\t_pFormatContext = NULL;\n\t\t_videoStream = NULL;\n\t}\n\n\t_fileName = \"\";\n}\n\nvoid PhVideoEngine::setSettings(PhVideoSettings *settings)\n{\n\t_settings = settings;\n}\n\nvoid PhVideoEngine::drawVideo(int x, int y, int w, int h)\n{\n\t//\t_clock.tick(60);\n\tPhFrame delay = 0;\n\tif(_settings)\n\t\tdelay = _settings->screenDelay() * PhTimeCode::getFps(_clock.timeCodeType()) * _clock.rate() / 1000;\n\tgoToFrame(_clock.frame() + delay);\n\tvideoRect.setRect(x, y, w, h);\n\tvideoRect.setZ(-10);\n\tvideoRect.draw();\n}\n\nPhFrame PhVideoEngine::length()\n{\n\tif(_videoStream)\n\t\treturn time2frame(_videoStream->duration);\n\treturn 0;\n}\n\nvoid PhVideoEngine::setFirstFrame(PhFrame frame)\n{\n\t_firstFrame = frame;\n}\n\nPhVideoEngine::~PhVideoEngine()\n{\n\tclose();\n}\n\nint PhVideoEngine::width()\n{\n\tif(_videoStream)\n\t\treturn _videoStream->codec->width;\n\treturn 0;\n}\n\nint PhVideoEngine::height()\n{\n\tif(_videoStream)\n\t\treturn _videoStream->codec->height;\n\treturn 0;\n}\n\nfloat PhVideoEngine::framePerSecond()\n{\n\tfloat result = 0;\n\tif(_videoStream) {\n\t\tresult = _videoStream->avg_frame_rate.num;\n\t\tresult /= _videoStream->avg_frame_rate.den;\n\t\t// See http://stackoverflow.com/a/570694/2307070\n\t\t// for NaN handling\n\t\tif(result != result) {\n\t\t\tresult = _videoStream->time_base.den;\n\t\t\tresult /= _videoStream->time_base.num;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nQString PhVideoEngine::codecName()\n{\n\tif(_videoStream)\n\t\treturn _videoStream->codec->codec_name;\n\treturn \"\";\n}\n\nbool PhVideoEngine::goToFrame(PhFrame frame)\n{\n\t//\tint lastGotoElapsed = _testTimer.elapsed();\n\tint seekElapsed = -1;\n\tint readElapsed = -1;\n\tint decodeElapsed = -1;\n\tint scaleElapsed = -1;\n\tint textureElapsed = -1;\n\n\tif(!ready()) {\n\t\tPHDEBUG << \"not ready\";\n\t\treturn false;\n\t}\n\n\tif(frame < this->firstFrame())\n\t\tframe = this->firstFrame();\n\tif (frame >= this->lastFrame())\n\t\tframe = this->lastFrame();\n\n\tbool result = false;\n\t// Do not perform frame seek if the rate is 0 and the last frame is the same frame\n\tif (frame == _currentFrame)\n\t\tresult = true;\n\telse {\n\t\t// Do not perform frame seek if the rate is 1 and the last frame is the previous frame\n\t\tif(frame - _currentFrame != 1) {\n\t\t\tint flags = AVSEEK_FLAG_ANY;\n\t\t\tint64_t timestamp = frame2time(frame - _firstFrame);\n\t\t\tPHDEBUG << \"seek:\" << frame;\n\t\t\tav_seek_frame(_pFormatContext, _videoStream->index, timestamp, flags);\n\t\t}\n\n\t\tseekElapsed = _testTimer.elapsed();\n\n\t\tAVPacket packet;\n\n\t\tbool lookingForVideoFrame = true;\n\t\twhile(lookingForVideoFrame) {\n\t\t\tint error = av_read_frame(_pFormatContext, &packet);\n\t\t\tswitch(error) {\n\t\t\tcase 0:\n\t\t\t\tif(packet.stream_index == _videoStream->index) {\n\t\t\t\t\t_currentFrame = frame;\n\n\t\t\t\t\treadElapsed = _testTimer.elapsed();\n\t\t\t\t\tint frameFinished = 0;\n\t\t\t\t\tavcodec_decode_video2(_videoStream->codec, _videoFrame, &frameFinished, &packet);\n\t\t\t\t\tif(frameFinished) {\n\t\t\t\t\t\tdecodeElapsed = _testTimer.elapsed();\n\n\t\t\t\t\t\tint frameHeight = _videoFrame->height;\n\t\t\t\t\t\tif(_deinterlace)\n\t\t\t\t\t\t\tframeHeight = _videoFrame->height / 2;\n\n\t\t\t\t\t\t// As the following formats are deprecated (see https://libav.org/doxygen/master/pixfmt_8h.html#a9a8e335cf3be472042bc9f0cf80cd4c5)\n\t\t\t\t\t\t// we replace its with the new ones recommended by LibAv\n\t\t\t\t\t\t// in order to get ride of the warnings\n\t\t\t\t\t\tAVPixelFormat pixFormat;\n\t\t\t\t\t\tswitch (_videoStream->codec->pix_fmt) {\n\t\t\t\t\t\tcase AV_PIX_FMT_YUVJ420P:\n\t\t\t\t\t\t\tpixFormat = AV_PIX_FMT_YUV420P;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase AV_PIX_FMT_YUVJ422P:\n\t\t\t\t\t\t\tpixFormat = AV_PIX_FMT_YUV422P;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase AV_PIX_FMT_YUVJ444P:\n\t\t\t\t\t\t\tpixFormat = AV_PIX_FMT_YUV444P;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase AV_PIX_FMT_YUVJ440P:\n\t\t\t\t\t\t\tpixFormat = AV_PIX_FMT_YUV440P;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tpixFormat = _videoStream->codec->pix_fmt;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_pSwsCtx = sws_getCachedContext(_pSwsCtx, _videoFrame->width, _videoStream->codec->height,\n\t\t\t\t\t\t                                pixFormat, _videoStream->codec->width, frameHeight,\n\t\t\t\t\t\t                                AV_PIX_FMT_RGB24, SWS_POINT, NULL, NULL, NULL);\n\n\t\t\t\t\t\tif(_rgb == NULL)\n\t\t\t\t\t\t\t_rgb = new uint8_t[_videoFrame->width * frameHeight * 3];\n\t\t\t\t\t\tint linesize = _videoFrame->width *3;\n\t\t\t\t\t\tif (0 <= sws_scale(_pSwsCtx, (const uint8_t * const *) _videoFrame->data,\n\t\t\t\t\t\t                   _videoFrame->linesize, 0, _videoStream->codec->height, &_rgb,\n\t\t\t\t\t\t                   &linesize)) {\n\t\t\t\t\t\t\tscaleElapsed = _testTimer.elapsed();\n\n\t\t\t\t\t\t\tvideoRect.createTextureFromRGBBuffer(_rgb, _videoFrame->width, frameHeight);\n\n\t\t\t\t\t\t\ttextureElapsed = _testTimer.elapsed();\n\n\t\t\t\t\t\t\t_videoFrameTickCounter.tick();\n\t\t\t\t\t\t\tresult = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlookingForVideoFrame = false;\n\t\t\t\t\t} // if frame decode is not finished, let's read another packet.\n\t\t\t\t}\n\t\t\t\telse if(_audioStream && (packet.stream_index == _audioStream->index)) {\n\t\t\t\t\tint ok = 0;\n\t\t\t\t\tavcodec_decode_audio4(_audioStream->codec, _audioFrame, &ok, &packet);\n\t\t\t\t\tif(ok) {\n\t\t\t\t\t\tPHDEBUG << \"audio:\" << _audioFrame->nb_samples;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase AVERROR_INVALIDDATA:\n\t\t\tcase AVERROR_EOF:\n\t\t\tdefault:\n\t\t\t\t{\n\t\t\t\t\tchar errorStr[256];\n\t\t\t\t\tav_strerror(error, errorStr, 256);\n\t\t\t\t\tPHDEBUG << frame << \"error:\" << errorStr;\n\t\t\t\t\tlookingForVideoFrame = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//Avoid memory leak\n\t\t\tav_free_packet(&packet);\n\t\t}\n\t}\n\n\t//\tint currentGotoElapsed = _testTimer.elapsed();\n\t//\tif(_testTimer.elapsed() > 25)\n\t//\t\tPHDEBUG << frame << lastGotoElapsed << seekElapsed - lastGotoElapsed << readElapsed - seekElapsed\n\t//\t\t\t\t<< decodeElapsed - readElapsed << scaleElapsed - decodeElapsed << textureElapsed - scaleElapsed << currentGotoElapsed - lastGotoElapsed << _testTimer.elapsed();\n\t_testTimer.restart();\n\n\treturn result;\n}\n\nint64_t PhVideoEngine::frame2time(PhFrame f)\n{\n\tint64_t t = 0;\n\tif(_videoStream) {\n\t\tPhFrame fps = PhTimeCode::getFps(_clock.timeCodeType());\n\t\tt = f * _videoStream->time_base.den / _videoStream->time_base.num / fps;\n\t}\n\treturn t;\n}\n\nPhFrame PhVideoEngine::time2frame(int64_t t)\n{\n\tPhFrame f = 0;\n\tif(_videoStream) {\n\t\tPhFrame fps = PhTimeCode::getFps(_clock.timeCodeType());\n\t\tf = t * _videoStream->time_base.num * fps / _videoStream->time_base.den;\n\t}\n\treturn f;\n}\n", "name": "libs/PhVideo/PhVideoEngine.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef PHVIDEOENGINE_H\n#define PHVIDEOENGINE_H\n\nextern \"C\" {\n#ifndef INT64_C\n/** see http://code.google.com/p/ffmpegsource/issues/detail?id=11#c13 */\n#define INT64_C(c) (c ## LL)\n/** and http://code.google.com/p/ffmpegsource/issues/detail?id=11#c23 */\n#define UINT64_C(c) (c ## ULL)\n#endif\n\n#include <libavformat/avformat.h>\n#include <libavutil/avutil.h>\n#include <libavcodec/avcodec.h>\n#include <libswscale/swscale.h>\n}\n\n#include <QObject>\n#include <QElapsedTimer>\n\n#include \"PhTools/PhClock.h\"\n#include \"PhTools/PhTickCounter.h\"\n#include \"PhGraphic/PhGraphicTexturedRect.h\"\n\n#include \"PhVideoSettings.h\"\n\n/**\n * @brief The video engine\n *\n * It provide engine which compute the video from a file to an openGL texture.\n */\nclass PhVideoEngine : public QObject\n{\n\tQ_OBJECT\npublic:\n\t/**\n\t * @brief PhVideoEngine constructor\n\t * @param useAudio Shall decode audio frame?\n\t * @param parent The parent object\n\t */\n\texplicit PhVideoEngine(bool useAudio = false, QObject *parent = 0);\n\t~PhVideoEngine();\n\n\t// Properties\n\t/**\n\t * @brief Get the video file name\n\t * @return the video file name\n\t */\n\tQString fileName() {\n\t\treturn _fileName;\n\t}\n\t/**\n\t * @brief Get the clock\n\t * @return the clock\n\t */\n\tPhClock* clock() {\n\t\treturn &_clock;\n\t}\n\t/**\n\t * @brief Get first frame\n\t * @return the first frame of the video file\n\t */\n\tPhFrame firstFrame() {\n\t\treturn _firstFrame;\n\t}\n\t/**\n\t * @brief Get last frame\n\t * @return the last frame of the video file\n\t */\n\tPhFrame lastFrame() {\n\t\treturn _firstFrame + length() - 1;\n\t}\n\t/**\n\t * @brief Get the length\n\t * @return the length of the video\n\t */\n\tPhFrame length();\n\t/**\n\t * @brief Get the codec name\n\t * @return the codec name\n\t */\n\tQString codecName();\n\t/**\n\t * @brief Get the width\n\t * @return the PhVideoEngine width (not necessary the video width)\n\t */\n\tint width();\n\t/**\n\t * @brief Get the height\n\t * @return the PhVideoEngine height (not necessary the video height)\n\t */\n\tint height();\n\t/**\n\t * @brief get frame per second\n\t * @return the FPS of the video file\n\t */\n\tfloat framePerSecond();\n\t/**\n\t * @brief Get refreshRate\n\t * @return Return the refresh rate of the PhVideoEngine\n\t */\n\tint refreshRate() {\n\t\treturn _videoFrameTickCounter.frequency();\n\t}\n\n\t/**\n\t * @brief Pass the settings to the engine\n\t * @param settings The settings\n\t */\n\tvoid setSettings(PhVideoSettings *settings);\n\t/**\n\t * @brief Set first frame\n\t * @param frame the new first frame\n\t */\n\tvoid setFirstFrame(PhFrame frame);\n\n\t// Methods\n\t/**\n\t * @brief Open a video file\n\t * @param fileName A video file path\n\t * @return True if the file was opened successfully, false otherwise\n\t */\n\tbool open(QString fileName);\n\t/**\n\t * @brief Close\n\t *\n\t * Close the PhVideoEngine, freeing all objects\n\t */\n\tvoid close();\n\t/**\n\t * @brief Prompt if the PhVideoEngine is ready\n\t * @return True if the PhVideoEngine is ready, false otherwise\n\t */\n\tbool ready();\n\n\t/**\n\t * @brief Check if video shall be deinterlace\n\t * @return True if deinterlace false otherwise\n\t */\n\tbool deinterlace() {\n\t\treturn _deinterlace;\n\t}\n\n\t/**\n\t * @brief Set the video deinterlace mode\n\t * @param deinterlace True if deinterlace false otherwise\n\t */\n\tvoid setDeinterlace(bool deinterlace);\n\n\t/**\n\t * @brief draw the video depending on the parameters\n\t * @param x coordinates of the upperleft corner\n\t * @param y coordinates of the upperleft corner\n\t * @param w width\n\t * @param h height\n\t */\n\tvoid drawVideo(int x, int y, int w, int h);\n\nprivate:\n\tbool goToFrame(PhFrame frame);\n\tint64_t frame2time(PhFrame f);\n\tPhFrame time2frame(int64_t t);\n\n\tPhVideoSettings *_settings;\n\tQString _fileName;\n\tPhClock _clock;\n\tPhFrame _firstFrame;\n\n\tAVFormatContext * _pFormatContext;\n\tAVStream *_videoStream;\n\tAVFrame * _videoFrame;\n\tstruct SwsContext * _pSwsCtx;\n\tPhGraphicTexturedRect videoRect;\n\tuint8_t * _rgb;\n\tPhFrame _currentFrame;\n\n\tQElapsedTimer _testTimer;\n\tPhTickCounter _videoFrameTickCounter;\n\n\tbool _useAudio;\n\tAVStream *_audioStream;\n\tAVFrame * _audioFrame;\n\n\tbool _deinterlace;\n};\n\n#endif // PHVIDEOENGINE_H\n", "name": "libs/PhVideo/PhVideoEngine.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef PHVIDEOSETTINGS_H\n#define PHVIDEOSETTINGS_H\n\n/**\n * @brief The settings for the PhVideoEngine\n */\nclass PhVideoSettings\n{\npublic:\n\t/**\n\t * @brief Screen delay compensation\n\t * @return A value in millisecond\n\t */\n\tvirtual int screenDelay() = 0;\n};\n\n#endif // PHVIDEOSETTINGS_H\n", "name": "libs/PhVideo/PhVideoSettings.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#include \"PhGraphic/PhGraphicText.h\"\n\n#include \"PhVideoView.h\"\n\nPhVideoView::PhVideoView(QWidget *parent) :\n\tPhGraphicView(parent),\n\t_videoEngine(NULL),\n\t_maxVideoRate(0)\n{\n}\n\nvoid PhVideoView::setEngine(PhVideoEngine *videoEngine)\n{\n\t_videoEngine = videoEngine;\n}\n\nvoid PhVideoView::paint()\n{\n\tif(_videoEngine) {\n\t\tint videoRate = _videoEngine->refreshRate();\n\t\tif(videoRate > _maxVideoRate)\n\t\t\t_maxVideoRate = videoRate;\n\t\tQString info = QString(\"%1 / %2\").arg(videoRate).arg(_maxVideoRate);\n\t\taddInfo(info);\n\t\t_videoEngine->drawVideo(0, 0, this->width(), this->height());\n\t\t_videoEngine->clock()->tick(_screenFrequency);\n\t}\n}\n", "name": "libs/PhVideo/PhVideoView.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef PHVIDEOVIEW_H\n#define PHVIDEOVIEW_H\n\n#include \"PhGraphic/PhGraphicView.h\"\n#include \"PhGraphic/PhFont.h\"\n\n#include \"PhVideoEngine.h\"\n\n/**\n * @brief Provide a view for a PhVideoEngine\n */\nclass PhVideoView : public PhGraphicView\n{\n\tQ_OBJECT\npublic:\n\t/**\n\t * @brief PhVideoView constructor\n\t * @param parent The parent object\n\t */\n\texplicit PhVideoView(QWidget *parent = 0);\n\t/**\n\t * @brief Set the PhVideoEngine\n\t * @param videoEngine The given videoEngine\n\t */\n\tvoid setEngine(PhVideoEngine * videoEngine);\n\nprotected:\n\t/**\n\t * @brief Paint the video on the screen\n\t */\n\tvoid paint();\n\nprivate:\n\tPhVideoEngine *_videoEngine;\n\tint _maxVideoRate;\n};\n\n#endif // PHVIDEOVIEW_H\n", "name": "libs/PhVideo/PhVideoView.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#include \"AudioTestWindow.h\"\n#include \"ui_AudioTestWindow.h\"\n#include \"PreferencesDialog.h\"\n\nAudioTestWindow::AudioTestWindow(QSettings *settings, QWidget *parent) :\n\tQMainWindow(parent),\n\t_settings(settings),\n\tui(new Ui::AudioTestWindow)\n{\n\tui->setupUi(this);\n\n\ton_generateCheckBox_clicked(_settings->value(\"generate\", true).toBool());\n\ton_readCheckBox_clicked(_settings->value(\"read\", true).toBool());\n\n\tconnect(&_audioReader, SIGNAL(audioProcessed(int, int)), this, SLOT(onAudioProcessed(int, int)));\n}\n\nAudioTestWindow::~AudioTestWindow()\n{\n\tdelete ui;\n}\n\nvoid AudioTestWindow::on_actionPreferences_triggered()\n{\n\tPreferencesDialog dlg(_settings->value(\"audioOutput\").toString(), _settings->value(\"audioInput\").toString());\n\tif(dlg.exec()) {\n\t\tPHDEBUG << dlg.selectedAudioOutput();\n\t\t_settings->setValue(\"audioOutput\", dlg.selectedAudioOutput());\n\t\t_settings->setValue(\"audioInput\", dlg.selectedAudioInput());\n\n\t\tif(_settings->value(\"generate\", true).toBool())\n\t\t\tsetupOutput();\n\t\tif(_settings->value(\"read\", true).toBool())\n\t\t\tsetupInput();\n\t}\n}\n\nvoid AudioTestWindow::setupOutput()\n{\n\t_audioWriter.close();\n\tif(!_audioWriter.init(_settings->value(\"audioOutput\", \"\").toString())) {\n\t\tQMessageBox::warning(this, tr(\"Error\"),\n\t\t                     tr(\"Error while loading the output device.\\n\"\n\t\t                        \"See log for more informations\"),\n\t\t                     QMessageBox::Ok);\n\t\ton_generateCheckBox_clicked(false);\n\t}\n}\n\nvoid AudioTestWindow::setupInput()\n{\n\t_audioReader.close();\n\tif(!_audioReader.init(_settings->value(\"audioInput\", \"\").toString())) {\n\t\tQMessageBox::warning(this, tr(\"Error\"),\n\t\t                     tr(\"Error while loading the input device.\\n\"\n\t\t                        \"See log for more informations\"),\n\t\t                     QMessageBox::Ok);\n\t\ton_readCheckBox_clicked(false);\n\t}\n}\n\nvoid AudioTestWindow::on_generateCheckBox_clicked(bool checked)\n{\n\tui->generatorGroupBox->setEnabled(checked);\n\tui->generateCheckBox->setChecked(checked);\n\t_settings->setValue(\"generate\", checked);\n\tif(checked)\n\t\tsetupOutput();\n\telse\n\t\t_audioWriter.close();\n}\n\nvoid AudioTestWindow::on_readCheckBox_clicked(bool checked)\n{\n\tui->readerGroupBox->setEnabled(checked);\n\tui->readCheckBox->setChecked(checked);\n\t_settings->setValue(\"read\", checked);\n\tif(checked)\n\t\tsetupInput();\n\telse\n\t\t_audioReader.close();\n}\n\nvoid AudioTestWindow::onAudioProcessed(int minLevel, int maxLevel)\n{\n\tui->inputLevelLabel->setText(QString(\"Input level : %1 / %2\").arg(minLevel).arg(maxLevel));\n}\n", "name": "tests/AudioTest/AudioTestWindow.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef AUDIOTESTWINDOW_H\n#define AUDIOTESTWINDOW_H\n\n#include <QMainWindow>\n#include <QTimer>\n#include <QMessageBox>\n#include <QSettings>\n\n#include \"PhTools/PhClock.h\"\n\n#include \"PhAudio/PhAudioInput.h\"\n#include \"AudioTestWriter.h\"\n\nnamespace Ui {\nclass AudioTestWindow;\n}\n/*!\n * \\brief AudioTest main application window\n *\n * The AudioTestWindow class implements the main screen user interface behaviour:\n * - Generate sound\n * - Read sound\n */\nclass AudioTestWindow : public QMainWindow\n{\n\tQ_OBJECT\n\npublic:\n\t/*!\n\t * \\brief The AudioTestWindow constructor\n\t * \\param settings The application settings\n\t * \\param parent\n\t */\n\texplicit AudioTestWindow(QSettings *settings, QWidget *parent = 0);\n\t~AudioTestWindow();\n\nprivate slots:\n\t/* QT auto slots */\n\tvoid on_actionPreferences_triggered();\n\n\tvoid on_generateCheckBox_clicked(bool checked);\n\n\tvoid on_readCheckBox_clicked(bool checked);\n\n\tvoid onAudioProcessed(int minLevel, int maxLevel);\nprivate:\n\tvoid setupOutput();\n\tvoid setupInput();\n\n\tUi::AudioTestWindow *ui;\n\tQSettings *_settings;\n\tAudioTestWriter _audioWriter;\n\tPhAudioInput _audioReader;\n\n\tPhFrame _lastFrame;\n\tPhFrame _frameDelta;\n\n};\n\n#endif // AUDIOTESTWINDOW_H\n", "name": "tests/AudioTest/AudioTestWindow.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include \"PhTools/PhDebug.h\"\n#include \"AudioTestWriter.h\"\n\nAudioTestWriter::AudioTestWriter(QObject *parent) :\n\tPhAudioOutput(parent)\n{\n}\n\nint AudioTestWriter::processAudio(const void *, void *outputBuffer, unsigned long framesPerBuffer)\n{\n\tchar *buffer = (char*)outputBuffer;\n\tint i = 0;\n\tint period = framesPerBuffer / 8;\n\twhile (i < framesPerBuffer) {\n\t\tif((i % period) < (period / 2))\n\t\t\tbuffer[i] = -10;\n\t\telse\n\t\t\tbuffer[i] = 10;\n\t\ti++;\n\t}\n\n\treturn paContinue;\n}\n", "name": "tests/AudioTest/AudioTestWriter.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef AUDIOTESTWRITER_H\n#define AUDIOTESTWRITER_H\n\n#include \"PhAudio/PhAudioOutput.h\"\n\nclass AudioTestWriter : public PhAudioOutput\n{\n\tQ_OBJECT\npublic:\n\texplicit AudioTestWriter(QObject *parent = 0);\n\nsignals:\n\npublic slots:\n\nprotected:\n\tint processAudio(const void *, void *outputBuffer, unsigned long framesPerBuffer);\n};\n\n#endif // AUDIOTESTWRITER_H\n", "name": "tests/AudioTest/AudioTestWriter.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#include \"AudioTestWindow.h\"\n#include <QApplication>\n\n#include <QSettings>\n\n/**\n * @brief The application main entry point\n * @param argc Command line argument count\n * @param argv Command line argument list\n * @return 0 if the application works well.\n */\nint main(int argc, char *argv[])\n{\n\tQSettings settings(\"Phonations\", APP_NAME);\n\tQSettings::setDefaultFormat(QSettings::NativeFormat);\n\n\tQApplication a(argc, argv);\n\tAudioTestWindow w(&settings);\n\tw.show();\n\n\treturn a.exec();\n}\n", "name": "tests/AudioTest/main.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#include \"PreferencesDialog.h\"\n#include \"ui_PreferencesDialog.h\"\n\n#include \"PhAudio/PhAudioOutput.h\"\n#include \"PhAudio/PhAudioInput.h\"\n\nPreferencesDialog::PreferencesDialog(QString audioOutput, QString audioInput, QWidget *parent) :\n\tQDialog(parent),\n\tui(new Ui::PreferencesDialog)\n{\n\tui->setupUi(this);\n\tQList<QString> outputList = PhAudioOutput::outputList();\n\tui->comboBoxOutput->addItems(outputList);\n\tif(outputList.contains(audioOutput))\n\t\tui->comboBoxOutput->setCurrentText(audioOutput);\n\n\tQList<QString> inputList = PhAudioInput::inputList();\n\tui->comboBoxInput->addItems(inputList);\n\tif(inputList.contains(audioInput))\n\t\tui->comboBoxInput->setCurrentText(audioInput);\n}\n\nPreferencesDialog::~PreferencesDialog()\n{\n\tdelete ui;\n}\n\nQString PreferencesDialog::selectedAudioOutput()\n{\n\treturn ui->comboBoxOutput->currentText();\n}\n\nQString PreferencesDialog::selectedAudioInput()\n{\n\treturn ui->comboBoxInput->currentText();\n}\n\n", "name": "tests/AudioTest/PreferencesDialog.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef PREFERENCESDIALOG_H\n#define PREFERENCESDIALOG_H\n\n#include <QDialog>\n\nnamespace Ui {\nclass PreferencesDialog;\n}\n\n/*!\n * \\brief AudioTest preferences dialog\n *\n * It allow the user to select the desired input and output.\n */\nclass PreferencesDialog : public QDialog\n{\n\tQ_OBJECT\n\npublic:\n\t/*!\n\t * \\brief Preferences Panel\n\t *\n\t * Create a modal QDialog which prompt the user for devices.\n\t *\n\t * \\param audioOutput\tThe current output device.\n\t * \\param audioInput\tThe current input device.\n\t * \\param parent\t\tThe parent.\n\t */\n\texplicit PreferencesDialog(QString audioOutput, QString audioInput, QWidget *parent = 0);\n\t~PreferencesDialog();\n\t/*!\n\t * \\brief selectedAudioOutput\n\t * \\return The selected output device\n\t */\n\tQString selectedAudioOutput();\n\t/*!\n\t * \\brief selectedAudioInput\n\t * \\return The selected input device\n\t */\n\tQString selectedAudioInput();\n\nprivate:\n\tUi::PreferencesDialog *ui;\n};\n\n#endif // PREFERENCESDIALOG_H\n", "name": "tests/AudioTest/PreferencesDialog.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef AUTOTESTSETTINGS_H\n#define AUTOTESTSETTINGS_H\n\n#include <QDir>\n\n#include \"PhTools/PhGenericSettings.h\"\n#include \"PhCommonUI/PhDocumentWindowSettings.h\"\n\nclass AutoTestSettings : public PhGenericSettings, public PhDocumentWindowSettings\n{\npublic:\n\tAutoTestSettings(bool clear = false) : PhGenericSettings(clear) {\n\t}\n\n\t// PhWindowSettings\n\tPH_SETTING_BOOL(setFullScreen, fullScreen)\n\tPH_SETTING_BYTEARRAY(setWindowGeometry, windowGeometry)\n\n\t// PhDocumentWindowSettings\n\tPH_SETTING_STRING(setCurrentDocument, currentDocument)\n\tPH_SETTING_STRING2(setLastDocumentFolder, lastDocumentFolder, QDir::homePath())\n\tPH_SETTING_STRINGLIST(setRecentDocumentList, recentDocumentList)\n\tPH_SETTING_INT2(setMaxRecentDocument, maxRecentDocument, 5)\n\tPH_SETTING_BOOL2(setAutoReload, autoReload, true)\n\n\t// Other settings\n\tPH_SETTING_INT(setIntTest1, intTest1)\n\tPH_SETTING_INT(setIntTest2, intTest2)\n\tPH_SETTING_INT2(setIntTest3, intTest3, 4)\n\tPH_SETTING_INT3(setIntTest4, intTest4, intTest1)\n\n\tPH_SETTING_UCHAR(setUnsignedCharTest1, unsignedCharTest1)\n\tPH_SETTING_UCHAR(setUnsignedCharTest2, unsignedCharTest2)\n\tPH_SETTING_UCHAR2(setUnsignedCharTest3, unsignedCharTest3, 0xF0)\n\n\tPH_SETTING_BOOL(setBoolTest1, boolTest1)\n\tPH_SETTING_BOOL(setBoolTest2, boolTest2)\n\tPH_SETTING_BOOL2(setBoolTest3, boolTest3, true)\n\n\tPH_SETTING_FLOAT(setFloatTest1, floatTest1)\n\tPH_SETTING_FLOAT(setFloatTest2, floatTest2)\n\tPH_SETTING_FLOAT2(setFloatTest3, floatTest3, 3.14f)\n\n\tPH_SETTING_STRING(setStringTest1, stringTest1)\n\tPH_SETTING_STRING(setStringTest2, stringTest2)\n\tPH_SETTING_STRING2(setStringTest3, stringTest3, \"stringTest default value\")\n\n\tPH_SETTING_STRING(setStringTest4, stringTest4)\n\tPH_SETTING_STRINGLIST(setStringListTest1, stringListTest1)\n\tPH_SETTING_STRINGLIST(setStringListTest2, stringListTest2)\n\n\tPH_SETTING_BYTEARRAY(setByteArrayTest1, byteArrayTest1)\n\tPH_SETTING_BYTEARRAY(setByteArrayTest2, byteArrayTest2)\n};\n\n#endif // AUTOTESTSETTINGS_H\n", "name": "tests/AutoTest/AutoTestSettings.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include <QPlainTextEdit>\n\n#include \"PhTools/PhDebug.h\"\n\n#include \"AutoTestWindow.h\"\n#include \"ui_AutoTestWindow.h\"\n\nAutoTestWindow::AutoTestWindow(PhDocumentWindowSettings *settings) :\n\tPhDocumentWindow(settings),\n\tui(new Ui::AutoTestWindow)\n{\n\tui->setupUi(this);\n\n\tconnect(ui->actionFull_screen, SIGNAL(triggered()), this, SLOT(toggleFullScreen()));\n}\n\nAutoTestWindow::~AutoTestWindow()\n{\n\tdelete ui;\n}\n\nQAction *AutoTestWindow::fullScreenAction()\n{\n\treturn ui->actionFull_screen;\n}\n\nbool AutoTestWindow::openDocument(QString fileName)\n{\n\tPHDEBUG << fileName;\n\tQFile file(fileName);\n\tif(!file.open(QFile::ReadOnly))\n\t\treturn false;\n\n\tQTextStream ts(&file);\n\tui->plainTextEdit->setPlainText(ts.readAll());\n\n\tsetCurrentDocument(fileName);\n\treturn true;\n}\n\nQMenu *AutoTestWindow::recentDocumentMenu()\n{\n\treturn ui->menuOpen_recent;\n}\n\nQString AutoTestWindow::text()\n{\n\treturn ui->plainTextEdit->toPlainText();\n}\n", "name": "tests/AutoTest/AutoTestWindow.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef AUTOTESTWINDOW_H\n#define AUTOTESTWINDOW_H\n\n#include \"PhCommonUI/PhDocumentWindow.h\"\n\nnamespace Ui {\nclass AutoTestWindow;\n}\n\nclass AutoTestWindow : public PhDocumentWindow\n{\n\tQ_OBJECT\n\npublic:\n\texplicit AutoTestWindow(PhDocumentWindowSettings *settings);\n\t~AutoTestWindow();\n\n\tQAction *fullScreenAction();\n\n\tbool openDocument(QString fileName);\n\tQMenu* recentDocumentMenu();\n\n\tQString text();\nprivate:\n\tUi::AutoTestWindow *ui;\n};\n\n#endif // AUTOTESTWINDOW_H\n", "name": "tests/AutoTest/AutoTestWindow.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * Copyright (C) 2012-2014 Phonations\n * License: http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#include <QTest>\n#include <QDate>\n#include \"GraphicStripTest.h\"\n\n#include \"PhGraphic/PhGraphicView.h\"\n#include \"PhGraphicStrip/PhGraphicStrip.h\"\n#include \"PhGraphicStrip/PhGraphicStripView.h\"\n\nGraphicStripTest::GraphicStripTest(QObject *parent) :\n\tQObject(parent)\n{\n}\n\nvoid GraphicStripTest::testStripDocObject()\n{\n\tPhGraphicStripView view;\n\tGraphicStripTestSettings settings;\n\tsettings.setStripHeight(1);\n\tsettings.setTextFontFile(QCoreApplication::applicationDirPath() + \"/SWENSON.TTF\");\n\tview.setStripSettings(&settings);\n\n\tview.setMinimumSize(QSize(981, 319));\n\tview.setMaximumSize(QSize(981, 319));\n\tview.show();\n\n\n\tPhStripDoc * doc = view.strip()->doc();\n\tdoc->reset();\n\tdoc->addPeople(new PhPeople(\"A people\"));\n\tdoc->addPeople(new PhPeople(\"A second people\", \"red\"));\n\n\tdoc->addObject(new PhStripText(0, doc->peoples().first(), 10000, 1, \"Hello\"));\n\tdoc->addObject(new PhStripCut(PhStripCut::CrossFade, 5400));\n\tdoc->addObject(new PhStripDetect(PhStripDetect::Off, 0, doc->peoples().first(), 10000, 1));\n\tdoc->addObject(new PhStripLoop(3, 22000));\n\tdoc->addObject(new PhStripText(10000, doc->peoples().last(), 15000, 2, \"Hi !\"));\n\tdoc->addObject(new PhStripDetect(PhStripDetect::SemiOff, 10000, doc->peoples().last(), 15000, 2));\n\n\n\n\tview.strip()->draw(0, 0, 981, 319);\n\tQImage impr(view.grabFrameBuffer());\n\timpr.save(\"graphicStripTestResult.bmp\");\n\tQString expectedFile = QCoreApplication::applicationDirPath() + PATH_TO_RESSOURCES + QString(\"/graphicStripTest.bmp\");\n\tif(view.windowHandle()->devicePixelRatio() == 2)\n\t\texpectedFile = QCoreApplication::applicationDirPath() + PATH_TO_RESSOURCES + QString(\"/graphicStripRetinaTest.bmp\");\n\tif(QString(qgetenv(\"TRAVIS\")) == \"true\")\n\t\texpectedFile = QCoreApplication::applicationDirPath() + PATH_TO_RESSOURCES + QString(\"/graphicStripTravisTest.bmp\");\n\n\tQVERIFY(impr == QImage(expectedFile));\n\n}\n", "name": "tests/AutoTest/GraphicStripTest.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * Copyright (C) 2012-2014 Phonations\n * License: http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef GRAPHICSTRIPTEST_H\n#define GRAPHICSTRIPTEST_H\n\n#include <QObject>\n\nclass GraphicStripTest : public QObject\n{\n\tQ_OBJECT\npublic:\n\texplicit GraphicStripTest(QObject *parent = 0);\n\nprivate slots:\n\tvoid testStripDocObject();\n};\n\n#include \"PhTools/PhGenericSettings.h\"\n#include \"PhGraphicStrip/PhGraphicStripSettings.h\"\n#include \"PhCommonUI/PhDocumentWindowSettings.h\"\n\nclass GraphicStripTestSettings : PhGenericSettings,\n\tpublic PhGraphicStripSettings,\n\tpublic PhDocumentWindowSettings\n\n{\npublic:\n\tPH_SETTING_INT(setScreenDelay, screenDelay)\n\n\t// PhGraphicSettings\n\tPH_SETTING_BOOL(setDisplayInfo, displayInfo)\n\tPH_SETTING_BOOL(setResetInfo, resetInfo)\n\n\t// PhGraphicStripSettings :\n\tPH_SETTING_FLOAT2(setStripHeight, stripHeight, 0.25f)\n\tPH_SETTING_INT2(setHorizontalTimePerPixel, horizontalTimePerPixel, 80)\n\tPH_SETTING_INT2(setVerticalTimePerPixel, verticalTimePerPixel, 1000)\n\tPH_SETTING_STRING(setTextFontFile, textFontFile)\n\tPH_SETTING_INT2(setTextBoldness, textBoldness, 1)\n\tPH_SETTING_BOOL(setStripTestMode, stripTestMode)\n\tPH_SETTING_BOOL2(setDisplayNextText, displayNextText, true)\n\tPH_SETTING_BOOL(setInvertColor, invertColor)\n\tPH_SETTING_BOOL(setDisplayRuler, displayRuler)\n\tPH_SETTING_INT(setRulerTimeIn, rulerTimeIn)\n\tPH_SETTING_INT2(setTimeBetweenRuler, timeBetweenRuler, 48000)\n\n\t// PhDocumentWindowSettings\n\tPH_SETTING_STRING(setCurrentDocument, currentDocument)\n\tPH_SETTING_STRING2(setLastDocumentFolder, lastDocumentFolder, QDir::homePath())\n\tPH_SETTING_STRINGLIST(setRecentDocumentList, recentDocumentList)\n\tPH_SETTING_INT2(setMaxRecentDocument, maxRecentDocument, 10)\n\tPH_SETTING_BOOL2(setAutoReload, autoReload, true)\n\n\t// PhWindowSettings\n\tPH_SETTING_BOOL(setFullScreen, fullScreen)\n\tPH_SETTING_BYTEARRAY(setWindowGeometry, windowGeometry)\n\n\t// Other settings :\n\tPH_SETTING_BOOL(setGenerate, generate)\n\tPH_SETTING_INT2(setPeopleNumber, peopleNumber, 1)\n\tPH_SETTING_INT2(setLoopNumber, loopNumber, 1)\n\tPH_SETTING_INT2(setTextNumber, textNumber, 10)\n\tPH_SETTING_INT2(setSpaceBetweenText, spaceBetweenText, 24000)\n\tPH_SETTING_INT2(setTrackNumber, trackNumber, 4)\n\tPH_SETTING_STRING2(setTextContent, textContent, \"Per hoc minui studium suum existimans Paulus.\")\n\tPH_SETTING_INT2(setStartTime, startTime, 0)\n};\n\n#endif // GRAPHICSTRIPTEST_H\n", "name": "tests/AutoTest/GraphicStripTest.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * Copyright (C) 2012-2014 Phonations\n * License: http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n\n#include <QTest>\n#include <QThread>\n\n#include \"GraphicTextTest.h\"\n#include \"PhGraphic/PhGraphicText.h\"\n#include \"PhGraphic/PhGraphicSolidRect.h\"\n\nGraphicTextTest::GraphicTextTest(QWidget *parent)\n\t: PhGraphicView( NULL)\n{\n}\n\nvoid GraphicTextTest::testSwenson() {\n\t_font.setFontFile(QCoreApplication::applicationDirPath() + \"/SWENSON.TTF\");\n\tsetGeometry(0, 0, 776, 576);\n\n\tQString expectedFile = QCoreApplication::applicationDirPath() + PATH_TO_RESSOURCES + QString(\"/swensonTest.bmp\");\n\tif(windowHandle()->devicePixelRatio() == 2)\n\t\texpectedFile = QCoreApplication::applicationDirPath() + PATH_TO_RESSOURCES + QString(\"/swensonRetinaTest.bmp\");\n\tif(QString(qgetenv(\"TRAVIS\")) == \"true\")\n\t\texpectedFile = QCoreApplication::applicationDirPath() + PATH_TO_RESSOURCES + QString(\"/swensonTravisTest.bmp\");\n\n\tshow();\n\tpaint();\n\tsleep(2);\n\tQImage img(grabFrameBuffer());\n\timg.save(\"./swensonTestResult.bmp\");\n\tQVERIFY(QImage(grabFrameBuffer()) == QImage(expectedFile));\n}\n\nvoid GraphicTextTest::testArial() {\n\t_font.setFontFile(QCoreApplication::applicationDirPath() + \"/Arial.ttf\");\n\tsetGeometry(0, 0, 776, 576);\n\n\tQString expectedFile = QCoreApplication::applicationDirPath() + PATH_TO_RESSOURCES + QString(\"/arialTest.bmp\");\n\tif(windowHandle()->devicePixelRatio() == 2)\n\t\texpectedFile = QCoreApplication::applicationDirPath() + PATH_TO_RESSOURCES + QString(\"/arialRetinaTest.bmp\");\n\tif(QString(qgetenv(\"TRAVIS\")) == \"true\")\n\t\texpectedFile = QCoreApplication::applicationDirPath() + PATH_TO_RESSOURCES + QString(\"/arialTravisTest.bmp\");\n\n\tshow();\n\tpaint();\n\tsleep(2);\n\tQImage img(grabFrameBuffer());\n\timg.save(\"./arialTestResult.bmp\");\n\tQVERIFY(QImage(grabFrameBuffer()) == QImage(expectedFile));\n\n}\n\nvoid GraphicTextTest::testWeblysleekuil()\n{\n\t_font.setFontFile(QCoreApplication::applicationDirPath() + \"/weblysleekuil.ttf\");\n\tsetGeometry(0, 0, 776, 576);\n\n\tQString expectedFile = QCoreApplication::applicationDirPath() + PATH_TO_RESSOURCES + QString(\"/weblysleekuilTest.bmp\");\n\tif(windowHandle()->devicePixelRatio() == 2)\n\t\texpectedFile = QCoreApplication::applicationDirPath() + PATH_TO_RESSOURCES + QString(\"/weblysleekuilRetinaTest.bmp\");\n\tif(QString(qgetenv(\"TRAVIS\")) == \"true\")\n\t\texpectedFile = QCoreApplication::applicationDirPath() + PATH_TO_RESSOURCES + QString(\"/weblysleekuilTravisTest.bmp\");\n\n\tshow();\n\tpaint();\n\tsleep(2);\n\tQImage img(grabFrameBuffer());\n\timg.save(\"./weblysleekuilTestResult.bmp\");\n\tQVERIFY(QImage(grabFrameBuffer()) == QImage(expectedFile));\n}\n\nvoid GraphicTextTest::testBedizen() {\n\t_font.setFontFile(QCoreApplication::applicationDirPath() + \"/Bedizen.ttf\");\n\tsetGeometry(0, 0, 776, 576);\n\n\tQString expectedFile = QCoreApplication::applicationDirPath() + PATH_TO_RESSOURCES + QString(\"/bedizenTest.bmp\");\n\tif(windowHandle()->devicePixelRatio() == 2)\n\t\texpectedFile = QCoreApplication::applicationDirPath() + PATH_TO_RESSOURCES + QString(\"/bedizenRetinaTest.bmp\");\n\tif(QString(qgetenv(\"TRAVIS\")) == \"true\")\n\t\texpectedFile = QCoreApplication::applicationDirPath() + PATH_TO_RESSOURCES + QString(\"/bedizenTravisTest.bmp\");\n\n\tshow();\n\tpaint();\n\tsleep(2);\n\tQImage img(grabFrameBuffer());\n\timg.save(\"./bedizenTestResult.bmp\");\n\tQVERIFY(QImage(grabFrameBuffer()) == QImage(expectedFile));\n\n}\n\nvoid GraphicTextTest::computeMaxFontSizeTest()\n{\n\tQCOMPARE(PhFont::computeMaxFontSize(QCoreApplication::applicationDirPath() + \"/Arial.ttf\"), 113);\n\tQCOMPARE(PhFont::computeMaxFontSize(QCoreApplication::applicationDirPath() + \"/SWENSON.ttf\"), 124);\n\tQCOMPARE(PhFont::computeMaxFontSize(QCoreApplication::applicationDirPath() + \"/Bedizen.ttf\"), 97);\n\tQCOMPARE(PhFont::computeMaxFontSize(QCoreApplication::applicationDirPath() + \"/weblysleekuil.ttf\"), 94);\n}\n\nvoid GraphicTextTest::paint() {\n\tglClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\tglClearColor(1.0f, 1.0f, 1.0f, 1.0f);\n\n\n\tint textHeight = 50;\n\tint textWidth = 600;\n\n\tPhGraphicSolidRect rect(0, 0, 900, textHeight);\n\trect.setColor(Qt::yellow);\n\trect.setZ(2);\n\n\tQString lowerCase(\"abcdefghijklmnopqrstuvwxyz\");\n\tPhGraphicText text1(&_font, lowerCase);\n\ttext1.setRect(0, 0, textWidth, textHeight);\n\ttext1.setColor(Qt::black);\n\ttext1.setZ(5);\n\ttext1.draw();\n\n\trect.setY(100);\n\trect.draw();\n\tQString upperCase(lowerCase.toUpper());\n\tPhGraphicText text2(&_font, upperCase);\n\ttext2.setRect(0, 100, textWidth, textHeight);\n\ttext2.setColor(Qt::black);\n\ttext2.setZ(5);\n\ttext2.draw();\n\n\trect.setY(200);\n\trect.draw();\n\tQString specials(\"\u00e0 \u00e2 \u00e7 \u00e8 \u00e9 \u00ea \u00ee \u00f4 \u00f9 \u00fb\");\n\tPhGraphicText text3(&_font, specials);\n\ttext3.setRect(0, 200, textWidth, textHeight);\n\ttext3.setColor(Qt::black);\n\ttext3.setZ(5);\n\ttext3.draw();\n\n\trect.setY(300);\n\trect.draw();\n\tQString numbers(\"0 1 2 3 4 5 6 7 8 9 0\");\n\tPhGraphicText text4(&_font, numbers);\n\ttext4.setRect(0, 300, textWidth, textHeight);\n\ttext4.setColor(Qt::black);\n\ttext4.setZ(5);\n\ttext4.draw();\n}\n", "name": "tests/AutoTest/GraphicTextTest.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * Copyright (C) 2012-2014 Phonations\n * License: http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef GRAPHICTEXTTEST_H\n#define GRAPHICTEXTTEST_H\n\n#include <QObject>\n\n#include \"PhGraphic/PhGraphicView.h\"\n\n\nclass GraphicTextTest : public PhGraphicView\n{\n\tQ_OBJECT\npublic:\n\texplicit GraphicTextTest(QWidget *parent = 0);\n\nsignals:\n\npublic slots:\n\nprivate slots:\n\tvoid testBedizen();\n\tvoid testSwenson();\n\tvoid testArial();\n\tvoid testWeblysleekuil();\n\tvoid computeMaxFontSizeTest();\nprivate:\n\tPhFont _font;\n\tvoid paint();\n\n};\n\n#endif // GRAPHICTEXTTEST_H\n", "name": "tests/AutoTest/GraphicTextTest.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include <QTest>\n\n#include \"LockableSpinBoxTest.h\"\n\n#include \"PhCommonUI/PhLockableSpinBox.h\"\n\nLockableSpinBoxTest::LockableSpinBoxTest(QObject *parent) :\n\tQObject(parent)\n{\n}\n\nvoid LockableSpinBoxTest::testMultiClickUnlock()\n{\n\tPhLockableSpinBox spinBox;\n\n\tQVERIFY(!spinBox.isEnabled());\n\tfor(int i = 0; i < 7; i++)\n\t\tQTest::mouseClick(&spinBox, Qt::LeftButton);\n\tQVERIFY(!spinBox.isEnabled());\n\tQTest::mouseClick(&spinBox, Qt::LeftButton);\n\tQVERIFY(spinBox.isEnabled());\n}\n\nvoid LockableSpinBoxTest::testControlClickUnload()\n{\n\tPhLockableSpinBox spinBox;\n\n\tQVERIFY(!spinBox.isEnabled());\n\tQTest::mouseClick(&spinBox, Qt::LeftButton);\n\tQVERIFY(!spinBox.isEnabled());\n\n\tQTest::mouseClick(&spinBox, Qt::LeftButton, Qt::ControlModifier);\n\tQVERIFY(spinBox.isEnabled());\n\n}\n", "name": "tests/AutoTest/LockableSpinBoxTest.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef PHLOCKABLESPINBOXTEST_H\n#define PHLOCKABLESPINBOXTEST_H\n\n#include <QObject>\n\nclass LockableSpinBoxTest : public QObject\n{\n\tQ_OBJECT\npublic:\n\texplicit LockableSpinBoxTest(QObject *parent = 0);\n\nprivate slots:\n\tvoid testMultiClickUnlock();\n\tvoid testControlClickUnload();\n\n};\n\n#endif // PHLOCKABLESPINBOXTEST_H\n", "name": "tests/AutoTest/LockableSpinBoxTest.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include <stdio.h>\n\n#include <QApplication>\n\n#include \"TimeCodeTest.h\"\n#include \"SettingsTest.h\"\n#include \"StripDocTest.h\"\n#include \"SonyControllerTest.h\"\n#include \"TimeCodeEditTest.h\"\n#include \"LockableSpinBoxTest.h\"\n#include \"WindowTest.h\"\n#include \"GraphicStripTest.h\"\n#include \"GraphicTextTest.h\"\n\nint main(int argc, char *argv[])\n{\n\tQApplication a(argc, argv);\n\n\tPHDEBUG << \"AutoTest\";\n\n\tbool testAll = (argc < 2); // if no argument, test all\n\tbool testTC = testAll;\n\tbool testSettings = testAll;\n\tbool testDoc = testAll;\n\tbool testSony = testAll;\n\tbool testUi = testAll;\n\tbool testGraphicStrip = testAll;\n\tbool testGraphicText = testAll;\n\n\tint result = 0;\n\n\tfor(int i = 1; i < argc; i++) {\n\t\tif(strcmp(argv[i], \"tc\") == 0)\n\t\t\ttestTC = true;\n\t\telse if(strcmp(argv[i], \"settings\") == 0)\n\t\t\ttestSettings = true;\n\t\telse if(strcmp(argv[i], \"doc\") == 0)\n\t\t\ttestDoc = true;\n\t\telse if(strcmp(argv[i], \"sony\") == 0)\n\t\t\ttestSony = true;\n\t\telse if(strcmp(argv[i], \"ui\") == 0)\n\t\t\ttestUi = true;\n\t\telse if(strcasecmp(argv[i], \"graphicstrip\") == 0)\n\t\t\ttestGraphicStrip = true;\n\t\telse if(strcasecmp(argv[i], \"graphictext\") == 0)\n\t\t\ttestGraphicText = true;\n\t}\n\n\tif(testTC) {\n\t\t// Testing PhTimeCode\n\t\tTimeCodeTest tcTest;\n\t\tresult += QTest::qExec(&tcTest);\n\t}\n\n\tif(testSettings) {\n\t\t// Testing PhSettings\n\t\tSettingsTest settingsTest;\n\t\tresult += QTest::qExec(&settingsTest);\n\t}\n\n\tif(testDoc) {\n\t\t// Testing PhStripDoc\n\t\tStripDocTest docTest;\n\t\tresult += QTest::qExec(&docTest);\n\t}\n\n\tif(testSony) {\n\t\t// Testing PhSonyController\n\t\tSonyControllerTest sonyTest;\n\t\tresult += QTest::qExec(&sonyTest);\n\t}\n\n\tif(testUi) {\n\t\t// Testing PhTimeCodeEdit\n\t\tTimeCodeEditTest tcEditTest;\n\t\tresult += QTest::qExec(&tcEditTest);\n\n\t\tLockableSpinBoxTest spinBoxTest;\n\t\tresult += QTest::qExec(&spinBoxTest);\n\n\t\tWindowTest windowTest;\n\t\tresult += QTest::qExec(&windowTest);\n\t}\n\n\tif(testGraphicStrip) {\n\t\tGraphicStripTest viewTest;\n\t\tresult += QTest::qExec(&viewTest);\n\t}\n\tif(testGraphicText) {\n\t\tGraphicTextTest viewTest;\n\t\tresult += QTest::qExec(&viewTest);\n\t}\n\n\tQThread::msleep(500);\n\n\tif(qgetenv(\"TRAVIS\") == \"true\") {\n\n\t\tif(result == 0) {\n\n\t\t\tPHDEBUG << \"                            ************\";\n\t\t\tPHDEBUG << \"                         *****************\";\n\t\t\tPHDEBUG << \"                       ********************\";\n\t\t\tPHDEBUG << \"                        ********************\";\n\t\t\tPHDEBUG << \"                         ********\";\n\t\t\tPHDEBUG << \"                          ********                 *********\";\n\t\t\tPHDEBUG << \"                           ***********              *********\";\n\t\t\tPHDEBUG << \"              *********      ****       *            *********\";\n\t\t\tPHDEBUG << \"            *            ***               *          *********\";\n\t\t\tPHDEBUG << \"          *                       **         *          ********\";\n\t\t\tPHDEBUG << \"         *                         **         *       ***********\";\n\t\t\tPHDEBUG << \"        *        *****              **      *********************\";\n\t\t\tPHDEBUG << \"       *        *******                     *********************\";\n\t\t\tPHDEBUG << \"       *         *****                         *****************\";\n\t\t\tPHDEBUG << \"       *                                        *\";\n\t\t\tPHDEBUG << \"        *     *               *                 *\";\n\t\t\tPHDEBUG << \"         *     *             *                  *\";\n\t\t\tPHDEBUG << \"           *    *           *                  *\";\n\t\t\tPHDEBUG << \"             *    *       *                   *\";\n\t\t\tPHDEBUG << \"                *   *****                   *\";\n\t\t\tPHDEBUG << \"       ***               *     ************\";\n\t\t\tPHDEBUG << \"      *   *            *      *\";\n\t\t\tPHDEBUG << \"      *   *          *********          ***\";\n\t\t\tPHDEBUG << \"  ****    **********        *          *   *\";\n\t\t\tPHDEBUG << \" *               *         *           *   *\";\n\t\t\tPHDEBUG << \"*              *           *************    ****\";\n\t\t\tPHDEBUG << \"*      *******                                  *\";\n\t\t\tPHDEBUG << \"*      *    *                                    *\";\n\t\t\tPHDEBUG << \"  *****    *              *****************      *\";\n\t\t\tPHDEBUG << \"          *               *               *      *\";\n\t\t\tPHDEBUG << \"         *      ****      *                *****\";\n\t\t\tPHDEBUG << \"         *    *      **   *\";\n\t\t\tPHDEBUG << \"         *   *         ** *\";\n\t\t\tPHDEBUG << \"      *** *  *            *\";\n\t\t\tPHDEBUG << \"     *    *   *            *    *\";\n\t\t\tPHDEBUG << \"      *    *   *           *   * *\";\n\t\t\tPHDEBUG << \"       *     *  *          *  *  *\";\n\t\t\tPHDEBUG << \"         *     * *         *  *  *\";\n\t\t\tPHDEBUG << \"          *       *        *  *  *\";\n\t\t\tPHDEBUG << \"            *       *    *****   *\";\n\t\t\tPHDEBUG << \"               *      * * *****  *\";\n\t\t}\n\t\telse {\n\t\t\tPHDEBUG << \"                                     _\";\n\t\t\tPHDEBUG << \"                                     gs        ,8+\";\n\t\t\tPHDEBUG << \"                                    d88        888.\";\n\t\t\tPHDEBUG << \"                                    888        888b\";\n\t\t\tPHDEBUG << \"                                   8888        8888\";\n\t\t\tPHDEBUG << \"                                   8888        8888\";\n\t\t\tPHDEBUG << \"                                   8888        8888.\";\n\t\t\tPHDEBUG << \"                                  ,8888        8888\";\n\t\t\tPHDEBUG << \"                                  88888        88888\";\n\t\t\tPHDEBUG << \"                                  88888        88889\";\n\t\t\tPHDEBUG << \"                                  88888        88888\";\n\t\t\tPHDEBUG << \"                                  88888        88888\";\n\t\t\tPHDEBUG << \"                                  88888        88888\";\n\t\t\tPHDEBUG << \"                                  88888        88888\";\n\t\t\tPHDEBUG << \"                                  88888        88888\";\n\t\t\tPHDEBUG << \"                                  88888        88888\";\n\t\t\tPHDEBUG << \"                                  88888        88888\";\n\t\t\tPHDEBUG << \"                                  88888        88888\";\n\t\t\tPHDEBUG << \"                                  88888        88888\";\n\t\t\tPHDEBUG << \"                                  88888        88888\";\n\t\t\tPHDEBUG << \"                                  ~8888        8888~\";\n\t\t\tPHDEBUG << \"                                   8888Y+y.'fsY8888\";\n\t\t\tPHDEBUG << \"                                   Y8888+lif'f+8888\";\n\t\t\tPHDEBUG << \"                                   '8886~~~~~~~7888\";\n\t\t\tPHDEBUG << \"                                   88`          V88\";\n\t\t\tPHDEBUG << \"                                 ,88       _    d88\";\n\t\t\tPHDEBUG << \"                                 88   __+  ]]   ~ Yi\";\n\t\t\tPHDEBUG << \"                               d88`   !8!  ]]]    !8.\";\n\t\t\tPHDEBUG << \"                   _cooooooooood888i   889  ]]]]    88\";\n\t\t\tPHDEBUG << \"                i88~~~~` ~Y8~~~Y~808   808   ]]]    88\";\n\t\t\tPHDEBUG << \"              g88f`       '~`    808   808   ]]]    888\";\n\t\t\tPHDEBUG << \"             d88                 !8!   !8!    ]]    88!\";\n\t\t\tPHDEBUG << \"            88!                                     d8\";\n\t\t\tPHDEBUG << \"           ,88                                     ,8!\";\n\t\t\tPHDEBUG << \"           888     ,d88888.                       ,d8\";\n\t\t\tPHDEBUG << \"           888   ,888888888]                     g88\";\n\t\t\tPHDEBUG << \"           '88.  !888888888]                  ,g88f`\";\n\t\t\tPHDEBUG << \"            !88.                             ,888\";\n\t\t\tPHDEBUG << \"             '88nsnnnnnnnnnnnnnn___________nnn88~\";\n\t\t\tPHDEBUG << \"              '~~~~~~~~~~~~~~~~~88888i  g8~`\";\n\t\t\tPHDEBUG << \"                                88  88` T8`\";\n\t\t\tPHDEBUG << \"                                88     i8f\";\n\t\t\tPHDEBUG << \"                                88    ,88\";\n\t\t\tPHDEBUG << \"                                88    888\";\n\t\t\tPHDEBUG << \"                                888b____d88\";\n\t\t\tPHDEBUG << \"                                88888888888\";\n\t\t\tPHDEBUG << \"                               ~88~~~~~~Y8~\";\n\t\t\tPHDEBUG << \"                              ,88`      88\";\n\t\t\tPHDEBUG << \"                              d8        88\";\n\t\t\tPHDEBUG << \"                              88        '88\";\n\t\t\tPHDEBUG << \"                             88          88\";\n\t\t\tPHDEBUG << \"                             88          !8b\";\n\t\t\tPHDEBUG << \"                             Y8       /\\\\  ~88\";\n\t\t\tPHDEBUG << \"                             !8.      88   ~88s.      o\";\n\t\t\tPHDEBUG << \"                              8b      88   88!88b.    #o_\";\n\t\t\tPHDEBUG << \"                              88.     88   '888888b    88o\";\n\t\t\tPHDEBUG << \"                              8V8     88    88~~V88b   d88s\";\n\t\t\tPHDEBUG << \"                   ,____d8____8.8!    88    88   !88   d888\";\n\t\t\tPHDEBUG << \"                _o88f~~~  o8888888888g88    88!   8b.  88088\";\n\t\t\tPHDEBUG << \"               g88~,_i  ,8888f~~~~~~~V88    8b__gg888888~ 889\";\n\t\t\tPHDEBUG << \"              ,88  88   88  ,d!   ,.        8888_.!88d88_8889      ,\";\n\t\t\tPHDEBUG << \"_/\\\\===+/\\\\~~T/\\\\/\\\\/\\\\/\\\\/\\\\/\\\\/\\\\/\\\\/\\\\/\\\\/\\\\/\\\\/\\\\/\\\\/\\\\/\\\\/\\\\/\\\\/\\\\/\\\\/\\\\/\\\\/\\\\/\\\\/\\\\/\\\\/\\\\/\\\\\";\n\t\t\tPHDEBUG << \"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\";\n\t\t}\n\t}\n\n\treturn result;\n}\n", "name": "tests/AutoTest/main.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include \"SettingsTest.h\"\n#include \"AutoTestSettings.h\"\n\nvoid SettingsTest::testClear()\n{\n\tAutoTestSettings settings;\n\n\tsettings.setIntTest1(1);\n\tsettings.setUnsignedCharTest1('a');\n\tsettings.setBoolTest1(true);\n\tsettings.setFloatTest1(0.12f);\n\tsettings.setStringTest1(\"coucou\");\n\n\tQStringList list;\n\tlist.append(\"alpha\");\n\tlist.append(\"beta\");\n\tlist.append(\"gamma\");\n\tsettings.setStringListTest1(list);\n\n\tQByteArray array;\n\tarray.append('a');\n\tarray.append('b');\n\tarray.append('c');\n\tarray.append('b');\n\tsettings.setByteArrayTest1(array);\n\n\t// Clear the settings\n\tsettings.clear();\n\n\tQCOMPARE(settings.intTest1(), 0);\n\tQCOMPARE((int)settings.unsignedCharTest1(), 0);\n\tQVERIFY(!settings.boolTest1());\n\tQCOMPARE(settings.floatTest1(), 0.0f);\n\tQCOMPARE(settings.stringTest1(), QString(\"\"));\n\tQCOMPARE(settings.stringListTest1().count(), 0);\n\tQCOMPARE(settings.byteArrayTest1().count(), 0);\n}\n\nvoid SettingsTest::testIntSettings()\n{\n\tAutoTestSettings settings(true);\n\n\tsettings.setIntTest1(6);\n\tQCOMPARE(settings.intTest1(), 6);\n\tQCOMPARE(settings.intTest2(), 0);\n\tQCOMPARE(settings.intTest3(), 4);\n\tQCOMPARE(settings.intTest4(), 6);\n\tsettings.setIntTest4(8);\n\tQCOMPARE(settings.intTest1(), 6);\n\tQCOMPARE(settings.intTest4(), 8);\n}\n\nvoid SettingsTest::testUnsignedCharSettings()\n{\n\tAutoTestSettings settings(true);\n\n\tsettings.setUnsignedCharTest1(0x11);\n\tQCOMPARE((int)settings.unsignedCharTest1(), 0x11);\n\tQCOMPARE((int)settings.unsignedCharTest2(), 0x0);\n\tQCOMPARE((int)settings.unsignedCharTest3(), 0xF0);\n}\n\nvoid SettingsTest::testBoolSettings()\n{\n\tAutoTestSettings settings(true);\n\n\tsettings.setBoolTest1(true);\n\tQVERIFY(settings.boolTest1());\n\tQVERIFY(!settings.boolTest2());\n\tQVERIFY(settings.boolTest3());\n}\n\nvoid SettingsTest::testFloatSettings()\n{\n\tAutoTestSettings settings(true);\n\n\tsettings.setFloatTest1(-1.34f);\n\tQCOMPARE(settings.floatTest1(), -1.34f);\n\tQCOMPARE(settings.floatTest2(), 0.0f);\n\tQCOMPARE(settings.floatTest3(), 3.14f);\n}\n\nvoid SettingsTest::testStringSettings()\n{\n\tAutoTestSettings settings(true);\n\n\tsettings.setStringTest1(\"test setString\");\n\tQCOMPARE(settings.stringTest1(), QString(\"test setString\"));\n\tQCOMPARE(settings.stringTest2(), QString(\"\"));\n\tQCOMPARE(settings.stringTest3(), QString(\"stringTest default value\"));\n}\n\nvoid SettingsTest::testStringListSettings()\n{\n\tAutoTestSettings settings(true);\n\n\t// Test empty string list\n\tQCOMPARE(0, settings.stringListTest1().size());\n\n\t// Test changing string list settings\n\n\tsettings.setStringTest4(\"Check other settings are not affected by string list settings\");\n\tQStringList list1;\n\tlist1.append(\"a\");\n\tlist1.append(\"b\");\n\tlist1.append(\"c\");\n\tlist1.append(\"d\");\n\n\tsettings.setStringListTest2(list1);\n\n\tQCOMPARE(settings.stringTest4(), QString(\"Check other settings are not affected by string list settings\"));\n\n\tQStringList list2 = settings.stringListTest2();\n\n\tQCOMPARE(list2.size(), list1.size());\n\n\tfor(int i = 0; i < list1.size(); i++)\n\t\tQCOMPARE(list2.at(i), list1.at(i));\n\n\t// Test changin an existing list settings\n\tQStringList list3;\n\tlist3.append(\"e\");\n\tlist3.append(\"f\");\n\tlist3.append(\"g\");\n\n\tsettings.setStringListTest2(list3);\n\n\tQCOMPARE(settings.stringTest4(), QString(\"Check other settings are not affected by string list settings\"));\n\n\tQStringList list4 = settings.stringListTest2();\n\n\tQCOMPARE(list3.size(), list4.size());\n\n\tfor(int i = 0; i < list3.size(); i++)\n\t\tQCOMPARE(list4.at(i), list3.at(i));\n}\n\nvoid SettingsTest::testByteArraySettings()\n{\n\tAutoTestSettings settings(true);\n\n\t// Test empty array\n\tQCOMPARE(0, settings.byteArrayTest1().size());\n\n\t// Test changing array settings\n\tQByteArray array1;\n\tarray1.append('t');\n\tarray1.append('e');\n\tarray1.append('s');\n\tarray1.append('t');\n\n\tsettings.setByteArrayTest2(array1);\n\n\tQByteArray array2 = settings.byteArrayTest2();\n\n\tQCOMPARE(array2.size(), array1.size());\n\n\tfor(int i = 0; i < array1.size(); i++)\n\t\tQCOMPARE(array2.at(i), array1.at(i));\n}\n", "name": "tests/AutoTest/SettingsTest.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef PHSETTINGSTEST_H\n#define PHSETTINGSTEST_H\n\n#include <QObject>\n#include <QTest>\n\n#include \"PhTools/PhGenericSettings.h\"\n\nclass SettingsTest : public QObject\n{\n\tQ_OBJECT\n\nprivate slots:\n\tvoid testClear();\n\tvoid testIntSettings();\n\tvoid testUnsignedCharSettings();\n\tvoid testBoolSettings();\n\tvoid testFloatSettings();\n\tvoid testStringSettings();\n\tvoid testStringListSettings();\n\tvoid testByteArraySettings();\n};\n\n#endif // PHSETTINGSTEST_H\n", "name": "tests/AutoTest/SettingsTest.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#include <QtMath>\n\n#include \"SonyControllerTest.h\"\n\n#include \"PhSync/PhSonyController.h\"\n\n#include \"PhTools/PhDebug.h\"\n\nvoid SonyControllerTest::testComputeRate()\n{\n\tQVERIFY(qAbs(PhSonyController::computeRate(0)) < 0.01);\n\tQVERIFY(qAbs(PhSonyController::computeRate(32) - 0.1) < 0.01);\n\tQVERIFY(qAbs(PhSonyController::computeRate(64) - 1.0) < 0.01);\n\tQVERIFY(qAbs(PhSonyController::computeRate(79) - 2.94) < 0.01);\n\tQVERIFY(qAbs(PhSonyController::computeRate(118) - 48.69) < 0.01);\n}\n", "name": "tests/AutoTest/SonyControllerTest.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef PHSONYCONTROLLERTEST_H\n#define PHSONYCONTROLLERTEST_H\n\n#include <QtTest>\n\n/**\n * @brief Test for the PhSonyController class.\n */\nclass SonyControllerTest : public QObject\n{\n\tQ_OBJECT\nprivate slots:\n\t/**\n\t * @brief Test some rate computation.\n\t *\n\t * See : http://www.belle-nuit.com/archives/9pin.html#shuttleFwd\n\t */\n\tvoid testComputeRate();\n};\n\n#endif // PHSONYCONTROLLERTEST_H\n", "name": "tests/AutoTest/SonyControllerTest.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#include \"PhTools/PhTimeCode.h\"\n\n#include \"StripDocTest.h\"\n\nvoid StripDocTest::initTestCase()\n{\n\tPhDebug::disable();\n}\n\nvoid StripDocTest::importDetXHeaderTest()\n{\n\tPhStripDoc doc;\n\tQVERIFY(doc.importDetXFile(\"test01.detx\"));\n\n\tQCOMPARE(doc.generator(), QString(\"Cappella v0.12.5, 1\"));\n\tQCOMPARE(doc.title(), QString(\"Title test\"));\n\tQCOMPARE(doc.translatedTitle(), QString(\"Translated title\"));\n\tQCOMPARE(doc.episode(), QString(\"episode ref\"));\n\tQCOMPARE(doc.season(), QString(\"season ref\"));\n\tQCOMPARE(doc.videoFilePath(), QString(\"/Path/to/video.mov\"));\n\tQCOMPARE(t2s(doc.videoTimeIn(), doc.timeCodeType()), QString(\"01:00:00:00\"));\n\tQCOMPARE(doc.authorName(), QString(\"Pierre Dupont\"));\n\tQCOMPARE(t2s(doc.lastTime(), doc.timeCodeType()), QString(\"01:00:16:00\"));\n\n\tQList<QString> metaKey = doc.metaKeys();\n\n\tQCOMPARE(metaKey.count(), 6);\n\tQVERIFY(metaKey.contains(\"Producteur\"));\n\tQVERIFY(metaKey.contains(\"Ann\u00e9e de production\"));\n\tQVERIFY(metaKey.contains(\"Distributeur\"));\n\tQVERIFY(metaKey.contains(\"R\u00e9alisateur\"));\n\tQVERIFY(metaKey.contains(\"Diffuseur\"));\n\tQVERIFY(metaKey.contains(\"Pays d'origine\"));\n\n\tQCOMPARE(doc.metaInformation(\"Producteur\"), QString(\"Producer\"));\n\tQCOMPARE(doc.metaInformation(\"Ann\u00e9e de production\"), QString(\"2014\"));\n\tQCOMPARE(doc.metaInformation(\"Distributeur\"), QString(\"Distributor\"));\n\tQCOMPARE(doc.metaInformation(\"R\u00e9alisateur\"), QString(\"Director\"));\n\tQCOMPARE(doc.metaInformation(\"Diffuseur\"), QString(\"Publisher\"));\n\tQCOMPARE(doc.metaInformation(\"Pays d'origine\"), QString(\"Country\"));\n\tPHDEBUG << doc.title();\n}\n\nvoid StripDocTest::importDetXNoFile()\n{\n\tPhStripDoc doc;\n\n\tQVERIFY(!doc.importDetXFile(\"does_not_exist.detx\"));\n}\n\nvoid StripDocTest::importDetXPeopleTest()\n{\n\tPhStripDoc doc;\n\tQVERIFY(doc.importDetXFile(\"test01.detx\"));\n\n\tQCOMPARE(doc.peoples().count(), 3);\n\tPhPeople *jeanne = doc.peopleByName(\"Jeanne\");\n\tQVERIFY(jeanne);\n\tQCOMPARE(jeanne->name(), QString(\"Jeanne\"));\n\tQCOMPARE(jeanne->color(), QString(\"#00BB00\"));\n\n\tPhPeople *sue = doc.peopleByName(\"Sue\");\n\tQVERIFY(sue);\n\tQCOMPARE(sue->name(), QString(\"Sue\"));\n\tQCOMPARE(sue->color(), QString(\"#BB0000\"));\n\n\tPhPeople *paul = doc.peopleByName(\"Paul\");\n\tQVERIFY(paul);\n\tQCOMPARE(paul->name(), QString(\"Paul\"));\n\tQCOMPARE(paul->color(), QString(\"#0000BB\"));\n\tQVERIFY(doc.peopleByName(\"Johnny\") == NULL);\n}\n\nvoid StripDocTest::importDetXLoopTest()\n{\n\tPhStripDoc doc;\n\n\tQVERIFY(doc.importDetXFile(\"test01.detx\"));\n\n\tQVERIFY(doc.loops().count() == 2);\n\tQCOMPARE(t2s(doc.loops()[0]->timeIn(), doc.timeCodeType()), QString(\"01:00:00:00\"));\n\tQCOMPARE(t2s(doc.loops()[1]->timeIn(), doc.timeCodeType()), QString(\"01:01:00:00\"));\n\n}\n\nvoid StripDocTest::importDetXCutTest()\n{\n\tPhStripDoc doc;\n\n\tQVERIFY(doc.importDetXFile(\"test01.detx\"));\n\n\tQVERIFY(doc.cuts().count() == 1);\n\tQCOMPARE(t2s(doc.cuts()[0]->timeIn(), doc.timeCodeType()), QString(\"01:00:01:00\"));\n}\n\nvoid StripDocTest::importDetXTextTest()\n{\n\tPhStripDoc doc;\n\n\tQVERIFY(doc.importDetXFile(\"test01.detx\"));\n\n\tQVERIFY(doc.texts().count() == 6);\n\n\tQCOMPARE(doc.texts()[0]->content(), QString(\"Simple sentence\"));\n\tQCOMPARE(t2s(doc.texts()[0]->timeIn(), doc.timeCodeType()), QString(\"01:00:02:00\"));\n\tQCOMPARE(t2s(doc.texts()[0]->timeOut(), doc.timeCodeType()), QString(\"01:00:04:00\"));\n\tQCOMPARE(doc.texts()[0]->people(), doc.peopleByName(\"Jeanne\"));\n\tQCOMPARE(doc.texts()[0]->track(), 1);\n\n\tQCOMPARE(doc.texts()[1]->content(), QString(\"Composed \"));\n\tQCOMPARE(t2s(doc.texts()[1]->timeIn(), doc.timeCodeType()), QString(\"01:00:05:00\"));\n\tQCOMPARE(t2s(doc.texts()[1]->timeOut(), doc.timeCodeType()), QString(\"01:00:06:00\"));\n\n\tQCOMPARE(doc.texts()[2]->content(), QString(\"sentence\"));\n\tQCOMPARE(t2s(doc.texts()[2]->timeIn(), doc.timeCodeType()), QString(\"01:00:06:00\"));\n\tQCOMPARE(t2s(doc.texts()[2]->timeOut(), doc.timeCodeType()), QString(\"01:00:07:00\"));\n\n\tQCOMPARE(doc.texts()[3]->content(), QString(\"Simple off sentence\"));\n\tQCOMPARE(t2s(doc.texts()[3]->timeIn(), doc.timeCodeType()), QString(\"01:00:12:00\"));\n\tQCOMPARE(t2s(doc.texts()[3]->timeOut(), doc.timeCodeType()), QString(\"01:00:14:00\"));\n\n\tQCOMPARE(doc.texts()[4]->content(), QString(\"Composed sentence with off\"));\n\tQCOMPARE(t2s(doc.texts()[4]->timeIn(), doc.timeCodeType()), QString(\"01:00:15:00\"));\n\tQCOMPARE(t2s(doc.texts()[4]->timeOut(), doc.timeCodeType()), QString(\"01:00:17:00\"));\n\n\tQCOMPARE(doc.texts()[5]->content(), QString(\"Sentence with out not linked\"));\n\tQCOMPARE(t2s(doc.texts()[5]->timeIn(), doc.timeCodeType()), QString(\"01:00:30:00\"));\n\tQCOMPARE(t2s(doc.texts()[5]->timeOut(), doc.timeCodeType()), QString(\"01:00:31:04\"));\n}\n\nvoid StripDocTest::importDetXDetectTest()\n{\n\tPhStripDoc doc;\n\n\tQVERIFY(doc.importDetXFile(\"test01.detx\"));\n\n\tQCOMPARE(doc.detects().count(), 6);\n\n\tQCOMPARE(doc.detects()[0]->people(), doc.peopleByName(\"Jeanne\"));\n\tQCOMPARE(doc.detects()[0]->type(), PhStripDetect::On);\n\tQCOMPARE(t2s(doc.detects()[0]->timeIn(), doc.timeCodeType()), QString(\"01:00:02:00\"));\n\tQCOMPARE(t2s(doc.detects()[0]->timeOut(), doc.timeCodeType()), QString(\"01:00:04:00\"));\n\tQCOMPARE(doc.detects()[0]->track(), 1);\n\n\tQCOMPARE(doc.detects()[1]->people(), doc.peopleByName(\"Sue\"));\n\tQCOMPARE(doc.detects()[1]->type(), PhStripDetect::On);\n\tQCOMPARE(t2s(doc.detects()[1]->timeIn(), doc.timeCodeType()), QString(\"01:00:05:00\"));\n\tQCOMPARE(t2s(doc.detects()[1]->timeOut(), doc.timeCodeType()), QString(\"01:00:07:00\"));\n\tQCOMPARE(doc.detects()[1]->track(), 2);\n\n\tQCOMPARE(doc.detects()[2]->people(), doc.peopleByName(\"Paul\"));\n\tQCOMPARE(doc.detects()[2]->type(), PhStripDetect::Off);\n\tQCOMPARE(t2s(doc.detects()[2]->timeIn(), doc.timeCodeType()), QString(\"01:00:12:00\"));\n\tQCOMPARE(t2s(doc.detects()[2]->timeOut(), doc.timeCodeType()), QString(\"01:00:14:00\"));\n\tQCOMPARE(doc.detects()[2]->track(), 1);\n\n\tQCOMPARE(doc.detects()[3]->people(), doc.peopleByName(\"Sue\"));\n\tQCOMPARE(doc.detects()[3]->type(), PhStripDetect::Off);\n\tQCOMPARE(t2s(doc.detects()[3]->timeIn(), doc.timeCodeType()), QString(\"01:00:15:00\"));\n\tQCOMPARE(t2s(doc.detects()[3]->timeOut(), doc.timeCodeType()), QString(\"01:00:17:00\"));\n\tQCOMPARE(doc.detects()[3]->track(), 2);\n\n\tQCOMPARE(doc.detects()[4]->people(), doc.peopleByName(\"Sue\"));\n\tQCOMPARE(doc.detects()[4]->type(), PhStripDetect::Off);\n\tQCOMPARE(t2s(doc.detects()[4]->timeIn(), doc.timeCodeType()), QString(\"01:00:20:00\"));\n\tQCOMPARE(t2s(doc.detects()[4]->timeOut(), doc.timeCodeType()), QString(\"01:00:22:00\"));\n\tQCOMPARE(doc.detects()[4]->track(), 2);\n\n\tQCOMPARE(doc.detects()[5]->people(), doc.peopleByName(\"Sue\"));\n\tQCOMPARE(doc.detects()[5]->type(), PhStripDetect::On);\n\tQCOMPARE(t2s(doc.detects()[5]->timeIn(), doc.timeCodeType()), QString(\"01:00:30:00\"));\n\tQCOMPARE(t2s(doc.detects()[5]->timeOut(), doc.timeCodeType()), QString(\"01:00:31:04\"));\n\tQCOMPARE(doc.detects()[5]->track(), 2);\n}\n\nvoid StripDocTest::importMosTest01()\n{\n\tPhStripDoc doc;\n\n\tQVERIFY(doc.importMosFile(\"test01.mos\"));\n\n\tQVERIFY(doc.timeCodeType() == PhTimeCodeType25);\n\n\tQCOMPARE(doc.authorName(), QString(\"auteur\"));\n\n\tQCOMPARE(doc.videoFilePath(), QString(\"\"));\n\tQCOMPARE(t2s(doc.videoTimeIn(), doc.timeCodeType()), QString(\"00:00:00:00\"));\n\n\tQCOMPARE(doc.title(), QString(\"Titre VO\"));\n\tQCOMPARE(doc.season(), QString(\"saison\"));\n\tQCOMPARE(doc.episode(), QString(\"episode\"));\n\n\t// Test peoples\n\tQCOMPARE(doc.peoples().count(), 1);\n\tPhPeople * people = doc.peopleByName(\"Nom personnage\");\n\tQVERIFY(people != NULL);\n\tQCOMPARE(people->name(), QString(\"Nom personnage\"));\n\n\t// Test cuts\n\tQCOMPARE(doc.cuts().count(), 0);\n\n\t// Test loop\n\tQCOMPARE(doc.loops().count(), 0);\n\n\t// Test texts\n\tQCOMPARE(doc.texts().count(), 3);\n\tQCOMPARE(doc.texts()[0]->people(), people);\n\tQCOMPARE(doc.texts()[0]->content(), QString(\"Ceci \"));\n\tQCOMPARE(t2s(doc.texts()[0]->timeIn(), doc.timeCodeType()), QString(\"00:00:00:20\"));\n\tQCOMPARE(t2s(doc.texts()[0]->timeOut(), doc.timeCodeType()), QString(\"00:00:01:12\"));\n\n\tQCOMPARE(doc.texts()[1]->content(), QString(\"est un\"));\n\tQCOMPARE(t2s(doc.texts()[1]->timeIn(), doc.timeCodeType()), QString(\"00:00:01:12\"));\n\tQCOMPARE(t2s(doc.texts()[1]->timeOut(), doc.timeCodeType()), QString(\"00:00:01:16\"));\n\n\tQCOMPARE(doc.texts()[2]->content(), QString(\" test.\"));\n\tQCOMPARE(t2s(doc.texts()[2]->timeIn(), doc.timeCodeType()), QString(\"00:00:01:16\"));\n\tQCOMPARE(t2s(doc.texts()[2]->timeOut(), doc.timeCodeType()), QString(\"00:00:02:03\"));\n\n\t// Detect test\n\t//#warning TODO more test on detect\n\tQCOMPARE(doc.detects().count(), 4);\n}\n\nvoid StripDocTest::importMosTest02()\n{\n\tPhStripDoc doc;\n\n\tQVERIFY(doc.importMosFile(\"test02.mos\"));\n\n\tQVERIFY(doc.timeCodeType() == PhTimeCodeType25);\n\n\tQCOMPARE(doc.videoFilePath(), QString(\"C:\\\\Users\\\\Matthhou\\\\Desktop\\\\Burn Notice\\\\710\\\\BurnNotice_BCI710_VOVI.mov\"));\n#warning TODO Matthias told me that the timestamp was in fact 00:58:00:00...\n\tQCOMPARE(t2s(doc.videoTimeIn(), doc.timeCodeType()), QString(\"00:58:24:00\"));\n\n\t// Test peoples\n\tQCOMPARE(doc.peoples().count(), 2);\n\n\tPhPeople * pierre = doc.peopleByName(\"Pierre\");\n\tQVERIFY(pierre != NULL);\n\tQCOMPARE(pierre->name(), QString(\"Pierre\"));\n\n\tPhPeople * marie = doc.peopleByName(\"Marie\");\n\tQVERIFY(marie != NULL);\n\tQCOMPARE(marie->name(), QString(\"Marie\"));\n\n\t// Test cuts\n\tQCOMPARE(doc.cuts().count(), 1);\n\tQCOMPARE(t2s(doc.cuts()[0]->timeIn(), doc.timeCodeType()), QString(\"01:00:00:00\"));\n\n\t// Test loops\n\tQCOMPARE(doc.loops().count(), 1);\n\tQCOMPARE(t2s(doc.loops()[0]->timeIn(), doc.timeCodeType()), QString(\"01:00:00:00\"));\n\n\t// Test texts\n\tQCOMPARE(doc.texts().count(), 2);\n\tQCOMPARE(doc.texts()[0]->people(), pierre);\n\tQCOMPARE(doc.texts()[0]->track(), 0);\n\tQCOMPARE(doc.texts()[0]->content(), QString(\"Bonjour, Marie.\"));\n\tQCOMPARE(t2s(doc.texts()[0]->timeIn(), doc.timeCodeType()), QString(\"01:00:00:00\"));\n\tQCOMPARE(t2s(doc.texts()[0]->timeOut(), doc.timeCodeType()), QString(\"01:00:02:00\"));\n\n\tQCOMPARE(doc.texts()[1]->people(), marie);\n\tQCOMPARE(doc.texts()[1]->track(), 3);\n\tQCOMPARE(doc.texts()[1]->content(), QString(\"Bonjour, Pierre.\"));\n\tQCOMPARE(t2s(doc.texts()[1]->timeIn(), doc.timeCodeType()), QString(\"01:00:04:00\"));\n\tQCOMPARE(t2s(doc.texts()[1]->timeOut(), doc.timeCodeType()), QString(\"01:00:06:00\"));\n\n\t// Detect test\n\tQCOMPARE(doc.detects().count(), 0);\n}\n\nvoid StripDocTest::importMosTest03()\n{\n\tPhStripDoc doc;\n\n\tQVERIFY(doc.importMosFile(\"test03.mos\"));\n\n\tQVERIFY(doc.timeCodeType() == PhTimeCodeType24);\n\n\tQCOMPARE(doc.videoFilePath(), QString(\"Z:\\\\MOT POUR MO\\\\AU FIL D'ARIANE_DETECTION\\\\jpegAFA_BOB 06_SEQ 30_PISTES SEPARES_H264.mov\"));\n\tQCOMPARE(t2s(doc.videoTimeIn(), doc.timeCodeType()), QString(\"05:59:50:00\"));\n\n\t// Test peoples\n\tQCOMPARE(doc.peoples().count(), 2);\n\n\tPhPeople * noName = doc.peopleByName(\"\");\n\tQVERIFY(noName != NULL);\n\tQCOMPARE(noName->name(), QString(\"\"));\n\n\tPhPeople * denis = doc.peopleByName(\"Denis\");\n\tQVERIFY(denis != NULL);\n\tQCOMPARE(denis->name(), QString(\"Denis\"));\n\n\t// Test cuts\n\tQCOMPARE(doc.cuts().count(), 29);\n\tQCOMPARE(t2s(doc.cuts()[0]->timeIn(), doc.timeCodeType()), QString(\"05:59:50:00\"));\n\tQCOMPARE(t2s(doc.cuts()[1]->timeIn(), doc.timeCodeType()), QString(\"05:59:58:00\"));\n\tQCOMPARE(t2s(doc.cuts()[2]->timeIn(), doc.timeCodeType()), QString(\"06:00:00:00\"));\n\tQCOMPARE(t2s(doc.cuts()[3]->timeIn(), doc.timeCodeType()), QString(\"06:00:05:22\"));\n\tQCOMPARE(t2s(doc.cuts()[4]->timeIn(), doc.timeCodeType()), QString(\"06:00:08:05\"));\n\n\t// Test loops\n\tQCOMPARE(doc.loops().count(), 2);\n#warning /// @todo test loop number and name\n\tQCOMPARE(t2s(doc.loops()[0]->timeIn(), doc.timeCodeType()), QString(\"06:00:01:00\"));\n//\tQCOMPARE(doc.getLoops()[0]->getLoopNumber(), 1);\n\tQCOMPARE(t2s(doc.loops()[1]->timeIn(), doc.timeCodeType()), QString(\"06:01:15:00\"));\n//\tQCOMPARE(doc.getLoops()[1]->getLoopNumber(), 2);\n\n\t// Test texts\n\tQCOMPARE(doc.texts(false).count(), 206);\n\tQCOMPARE(doc.texts(true).count(), 0);\n//#warning TODO more test on text\n\t// Detect test\n\tQCOMPARE(doc.detects().count(), 24);\n\t//#warning TODO more test on detect\n}\n\nvoid StripDocTest::importMosTest04()\n{\n\tPhStripDoc doc;\n\n\tQVERIFY(doc.importMosFile(\"test04.mos\"));\n\n\tQCOMPARE(doc.texts().count(), 1118);\n\tQCOMPARE(doc.texts(true).count(), 4329);\n\tQCOMPARE(doc.detects().count(), 4552);\n\n\tQCOMPARE(t2s(doc.detects()[0]->timeIn(), doc.timeCodeType()), QString(\"01:00:01:13\"));\n\tQCOMPARE(t2s(doc.detects()[0]->timeOut(), doc.timeCodeType()), QString(\"01:00:02:20\"));\n\tQCOMPARE(doc.detects()[0]->type(), PhStripDetect::Off);\n}\n\nvoid StripDocTest::openStripFileTest()\n{\n\tPhStripDoc doc;\n\n\t// DetX test\n\tQVERIFY(doc.openStripFile(\"test01.detx\"));\n\tQCOMPARE(t2s(doc.lastTime(), doc.timeCodeType()), QString(\"01:00:16:00\"));\n\tQCOMPARE(t2s(doc.videoTimeIn(), doc.timeCodeType()), QString(\"01:00:00:00\"));\n\n\t// Mos test\n\tQVERIFY(doc.openStripFile(\"test03.mos\"));\n\tQCOMPARE(doc.timeCodeType(), PhTimeCodeType24);\n\n\t// Strip file\n\tQVERIFY(doc.openStripFile(\"test.strip\"));\n\tQCOMPARE(doc.forceRatio169(), true);\n\tQCOMPARE(doc.videoFilePath(), QString(\"test01.mov\"));\n\tQCOMPARE(t2s(doc.videoTimeIn(), doc.timeCodeType()), QString(\"00:59:00:00\"));\n\tQCOMPARE(t2s(doc.lastTime(), doc.timeCodeType()), QString(\"01:02:03:04\"));\n\n\t// Test regular joker file linked to detx\n\tQVERIFY(doc.openStripFile(\"test01.joker\"));\n\tQCOMPARE(doc.filePath(), QString(\"test01.detx\"));\n\tQCOMPARE(doc.videoFilePath(), QString(\"test01.mov\"));\n\tQCOMPARE(t2s(doc.videoTimeIn(), doc.timeCodeType()), QString(\"01:01:00:00\"));\n\tQCOMPARE(doc.forceRatio169(), true);\n\tQCOMPARE(t2s(doc.lastTime(), doc.timeCodeType()), QString(\"01:30:00:00\"));\n\n\tQCOMPARE(doc.title(), QString(\"Title test\"));\n\tQCOMPARE(doc.generator(), QString(\"Cappella v0.12.5, 1\"));\n\n\t// Test regular joker file linked to mos\n\tQVERIFY(doc.openStripFile(\"test02.joker\"));\n\tQCOMPARE(doc.filePath(), QString(\"test03.mos\"));\n\tQCOMPARE(doc.videoFilePath(), QString(\"test02.mov\"));\n\tQCOMPARE(t2s(doc.videoTimeIn(), doc.timeCodeType()), QString(\"01:03:00:00\"));\n\tQCOMPARE(doc.forceRatio169(), false);\n\tQCOMPARE(t2s(doc.lastTime(), doc.timeCodeType()), QString(\"01:20:00:00\"));\n\n\tQCOMPARE(doc.title(), QString(\"Au fil d'Ariane\"));\n\tQCOMPARE(doc.generator(), QString(\"Mosaic\"));\n\n\t// Test bad files\n\tQVERIFY(QFile::exists(\"bad_tag.joker\"));\n\tQVERIFY(!doc.openStripFile(\"bad_tag.joker\"));\n\n\tQVERIFY(QFile::exists(\"empty.joker\"));\n\tQVERIFY(!doc.openStripFile(\"empty.joker\"));\n\n\t// Test accepted files\n\tQVERIFY(QFile::exists(\"empty_root.joker\"));\n\tQVERIFY(doc.openStripFile(\"empty_root.joker\"));\n\n\tQVERIFY(QFile::exists(\"empty_meta.joker\"));\n\tQVERIFY(doc.openStripFile(\"empty_meta.joker\"));\n}\n\nvoid StripDocTest::openSaveTest01()\n{\n\tPhStripDoc doc1;\n\n\tQVERIFY(doc1.openStripFile(\"test01.joker\"));\n\n\tQVERIFY(doc1.saveStripFile(\"save01.joker\", \"01:01:01:01\"));\n\n\tPhStripDoc doc2;\n\n\tQVERIFY(doc2.openStripFile(\"save01.joker\"));\n\n\tQCOMPARE(doc2.filePath(), doc1.filePath());\n\tQCOMPARE(doc2.videoFilePath(), doc1.videoFilePath());\n\tQCOMPARE(t2s(doc2.videoTimeIn(), doc2.timeCodeType()), t2s(doc1.videoTimeIn(), doc1.timeCodeType()));\n\tQCOMPARE(doc2.forceRatio169(), true);\n\tQCOMPARE(doc2.videoDeinterlace(), false);\n\tQCOMPARE(t2s(doc2.lastTime(), doc2.timeCodeType()), QString(\"01:01:01:01\"));\n\n\tQCOMPARE(doc2.title(), doc1.title());\n\tQCOMPARE(doc2.generator(), doc1.generator());\n}\n\nvoid StripDocTest::openSaveTest02()\n{\n\tPhStripDoc doc1;\n\n\tQVERIFY(doc1.openStripFile(\"test02.joker\"));\n\n\tQVERIFY(doc1.saveStripFile(\"save02.joker\", \"02:02:02:02\"));\n\n\tPhStripDoc doc2;\n\n\tQVERIFY(doc2.openStripFile(\"save02.joker\"));\n\n\tQCOMPARE(doc2.filePath(), doc1.filePath());\n\tQCOMPARE(doc2.videoFilePath(), doc1.videoFilePath());\n\tQCOMPARE(t2s(doc2.videoTimeIn(), doc2.timeCodeType()), t2s(doc1.videoTimeIn(), doc1.timeCodeType()));\n\tQCOMPARE(doc2.forceRatio169(), false);\n\tQCOMPARE(doc2.videoDeinterlace(), true);\n\tQCOMPARE(t2s(doc2.lastTime(), doc2.timeCodeType()), QString(\"02:02:02:02\"));\n\n\tQCOMPARE(doc2.title(), doc1.title());\n\tQCOMPARE(doc2.generator(), doc1.generator());\n}\n\nvoid StripDocTest::getPeopleByNameTest()\n{\n\tPhStripDoc doc;\n\n\tQVERIFY(doc.importDetXFile(\"test01.detx\"));\n\n\tQCOMPARE(doc.peopleByName(\"Jeanne\")->name(), QString(\"Jeanne\"));\n\tQCOMPARE(doc.peopleByName(\"Sue\")->name(), QString(\"Sue\"));\n\tQCOMPARE(doc.peopleByName(\"Paul\")->name(), QString(\"Paul\"));\n\tQVERIFY(doc.peopleByName(\"Bob\") == NULL);\n}\n\nvoid StripDocTest::getPreviousElementTimeTest()\n{\n\tPhStripDoc doc;\n\n\tQVERIFY(doc.importDetXFile(\"test01.detx\"));\n\tPhTimeCodeType tcType = doc.timeCodeType();\n\n\tQCOMPARE(t2s(doc.previousElementTime(s2t(\"23:00:00:00\", tcType)), tcType), QString(\"01:01:00:00\"));\n\tQCOMPARE(t2s(doc.previousElementTime(s2t(\"01:01:00:00\", tcType)), tcType), QString(\"01:00:30:00\"));\n\tQCOMPARE(t2s(doc.previousElementTime(s2t(\"01:00:30:00\", tcType)), tcType), QString(\"01:00:15:00\"));\n\tQCOMPARE(t2s(doc.previousElementTime(s2t(\"01:00:15:00\", tcType)), tcType), QString(\"01:00:12:00\"));\n\tQCOMPARE(doc.previousElementTime(s2t(\"01:00:00:00\", tcType)), PHTIMEMIN);\n}\n\nvoid StripDocTest::getNextElementTimeTest()\n{\n\tPhStripDoc doc;\n\n\tQVERIFY(doc.importDetXFile(\"test01.detx\"));\n\tPhTimeCodeType tcType = doc.timeCodeType();\n\n\tQCOMPARE(t2s(doc.nextElementTime(s2t(\"00:00:00:00\", tcType)), tcType), QString(\"01:00:00:00\"));\n\tQCOMPARE(t2s(doc.nextElementTime(s2t(\"01:00:00:00\", tcType)), tcType), QString(\"01:00:01:00\"));\n\tQCOMPARE(t2s(doc.nextElementTime(s2t(\"01:00:01:00\", tcType)), tcType), QString(\"01:00:02:00\"));\n\tQCOMPARE(t2s(doc.nextElementTime(s2t(\"01:00:02:00\", tcType)), tcType), QString(\"01:00:05:00\"));\n\tQCOMPARE(t2s(doc.nextElementTime(s2t(\"01:00:17:00\", tcType)), tcType), QString(\"01:00:30:00\"));\n\tQCOMPARE(t2s(doc.nextElementTime(s2t(\"01:00:30:00\", tcType)), tcType), QString(\"01:01:00:00\"));\n\tQCOMPARE(doc.nextElementTime(s2t(\"01:01:00:00\", tcType)), PHTIMEMAX);\n\n}\n\nvoid StripDocTest::getNextTextTest()\n{\n\tPhStripDoc doc;\n\n\tQVERIFY(doc.importDetXFile(\"test01.detx\"));\n\tPhTimeCodeType tcType = doc.timeCodeType();\n\n\tQCOMPARE(t2s(doc.nextText(s2t(\"00:00:00:00\", tcType))->timeIn(), tcType), QString(\"01:00:02:00\"));\n\tQCOMPARE(t2s(doc.nextText(s2t(\"01:00:02:00\", tcType))->timeIn(), tcType), QString(\"01:00:05:00\"));\n\tQCOMPARE(t2s(doc.nextText(s2t(\"01:00:05:00\", tcType))->timeIn(), tcType), QString(\"01:00:06:00\"));\n\tQCOMPARE(t2s(doc.nextText(s2t(\"01:00:06:00\", tcType))->timeIn(), tcType), QString(\"01:00:12:00\"));\n\tQCOMPARE(t2s(doc.nextText(s2t(\"01:00:12:00\", tcType))->timeIn(), tcType), QString(\"01:00:15:00\"));\n\tQCOMPARE(t2s(doc.nextText(s2t(\"01:00:15:00\", tcType))->timeIn(), tcType), QString(\"01:00:30:00\"));\n\tQVERIFY(doc.nextText(s2t(\"01:00:30:00\", tcType)) == NULL);\n}\n\nvoid StripDocTest::getNextTextTestByPeople()\n{\n\tPhStripDoc doc;\n\n\tQVERIFY(doc.importDetXFile(\"test01.detx\"));\n\tPhTimeCodeType tcType = doc.timeCodeType();\n\n\tPhPeople* sue = doc.peopleByName(\"Sue\");\n\n\tQCOMPARE(t2s(doc.nextText(sue, s2t(\"00:00:00:00\", tcType))->timeIn(), tcType), QString(\"01:00:05:00\"));\n\tQCOMPARE(t2s(doc.nextText(sue, s2t(\"01:00:05:00\", tcType))->timeIn(), tcType), QString(\"01:00:06:00\"));\n\tQCOMPARE(t2s(doc.nextText(sue, s2t(\"01:00:06:00\", tcType))->timeIn(), tcType), QString(\"01:00:15:00\"));\n\tQCOMPARE(t2s(doc.nextText(sue, s2t(\"01:00:15:00\", tcType))->timeIn(), tcType), QString(\"01:00:30:00\"));\n\tQVERIFY(doc.nextText(sue, s2t(\"01:00:30:00\", tcType)) == NULL);\n}\n\nvoid StripDocTest::getNextTextTestByPeopleList()\n{\n\tPhStripDoc doc;\n\n\tQVERIFY(doc.importDetXFile(\"test01.detx\"));\n\tPhTimeCodeType tcType = doc.timeCodeType();\n\n\tQList<PhPeople*> peopleList;\n\tpeopleList.append(doc.peopleByName(\"Sue\"));\n\tpeopleList.append(doc.peopleByName(\"Paul\"));\n\n\tQCOMPARE(t2s(doc.nextText(peopleList, s2t(\"00:00:00:00\", tcType))->timeIn(), tcType), QString(\"01:00:05:00\"));\n\tQCOMPARE(t2s(doc.nextText(peopleList, s2t(\"01:00:05:00\", tcType))->timeIn(), tcType), QString(\"01:00:06:00\"));\n\tQCOMPARE(t2s(doc.nextText(peopleList, s2t(\"01:00:06:00\", tcType))->timeIn(), tcType), QString(\"01:00:12:00\"));\n\tQCOMPARE(t2s(doc.nextText(peopleList, s2t(\"01:00:12:00\", tcType))->timeIn(), tcType), QString(\"01:00:15:00\"));\n\tQCOMPARE(t2s(doc.nextText(peopleList, s2t(\"01:00:15:00\", tcType))->timeIn(), tcType), QString(\"01:00:30:00\"));\n\tQVERIFY(doc.nextText(peopleList, s2t(\"01:00:30:00\", tcType)) == NULL);\n}\n\nvoid StripDocTest::getNextLoopTest()\n{\n\tPhStripDoc doc;\n\n\tQVERIFY(doc.importDetXFile(\"test01.detx\"));\n\tPhTimeCodeType tcType = doc.timeCodeType();\n\n\tQCOMPARE(t2s(doc.nextLoop(s2t(\"00:00:00:00\", tcType))->timeIn(), tcType), QString(\"01:00:00:00\"));\n\tQCOMPARE(t2s(doc.nextLoop(s2t(\"01:00:00:00\", tcType))->timeIn(), tcType), QString(\"01:01:00:00\"));\n\tQVERIFY(doc.nextLoop(s2t(\"01:01:00:00\", tcType)) == NULL);\n}\n\nvoid StripDocTest::getPreviousLoopTest()\n{\n\tPhStripDoc doc;\n\n\tQVERIFY(doc.importDetXFile(\"test01.detx\"));\n\tPhTimeCodeType tcType = doc.timeCodeType();\n\n\tQVERIFY(doc.previousLoop(s2t(\"01:00:00:00\", tcType)) == NULL);\n\tQCOMPARE(t2s(doc.previousLoop(s2t(\"01:01:00:00\", tcType))->timeIn(), tcType), QString(\"01:00:00:00\"));\n\tQCOMPARE(t2s(doc.previousLoop(s2t(\"23:00:00:00\", tcType))->timeIn(), tcType), QString(\"01:01:00:00\"));\n}\n\nvoid StripDocTest::addObjectTest()\n{\n\tPhStripDoc doc;\n\tdoc.addPeople(new PhPeople(\"A people\"));\n\n\tdoc.addObject(new PhStripText(0, doc.peoples().last(), 10000, 1, \"Hello\"));\n\tQVERIFY(doc.texts().count() == 1);\n\tdoc.addObject(new PhStripCut(PhStripCut::CrossFade, 5400));\n\tQVERIFY(doc.cuts().count() == 1);\n\tdoc.addObject(new PhStripDetect(PhStripDetect::Aperture, 10000, doc.peoples().last(), 11000, 1));\n\tQVERIFY(doc.detects().count() == 1);\n\n\tdoc.addObject(new PhStripLoop(3, 22000));\n\tQVERIFY(doc.loops().count() == 1);\n\n}\n\nvoid StripDocTest::addPeopleTest()\n{\n\tPhStripDoc doc;\n\tdoc.addPeople(new PhPeople(\"A people\"));\n\tQVERIFY(doc.peoples().count() == 1);\n\tdoc.addPeople(new PhPeople(\"A second people\"));\n\tQVERIFY(doc.peoples().count() == 2);\n\n}\n\nQString StripDocTest::t2s(PhTime time, PhTimeCodeType tcType)\n{\n\treturn PhTimeCode::stringFromTime(time, tcType);\n}\n\nPhTime StripDocTest::s2t(QString string, PhTimeCodeType tcType)\n{\n\treturn PhTimeCode::timeFromString(string, tcType);\n}\n\nvoid StripDocTest::importDetXNoTitleTest()\n{\n\tPhStripDoc doc;\n\n\tQVERIFY(doc.importDetXFile(\"notitle.detx\"));\n\tQVERIFY(doc.title() == \"notitle\");\n\n}\n", "name": "tests/AutoTest/StripDocTest.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef PHSTRIPDOCTEST_H\n#define PHSTRIPDOCTEST_H\n\n#include <QtTest>\n\n#include \"PhStrip/PhStripDoc.h\"\n\nclass StripDocTest : public QObject\n{\n\tQ_OBJECT\nprivate slots:\n\tvoid initTestCase();\n\n\t// Import DetX tests\n\tvoid importDetXHeaderTest();\n\tvoid importDetXNoFile();\n\tvoid importDetXPeopleTest();\n\tvoid importDetXLoopTest();\n\tvoid importDetXCutTest();\n\tvoid importDetXTextTest();\n\tvoid importDetXDetectTest();\n\tvoid importDetXNoTitleTest();\n\n\t// Import Mos tests\n\tvoid importMosTest01();\n\tvoid importMosTest02();\n\tvoid importMosTest03();\n\tvoid importMosTest04();\n\n\t// Open any doc (*.detx, *.strip, *.joker) test\n\tvoid openStripFileTest();\n\tvoid openSaveTest01();\n\tvoid openSaveTest02();\n\n\t// Get people\n\tvoid getPeopleByNameTest();\n\n\t// Get prev/next element tests\n\tvoid getPreviousElementTimeTest();\n\tvoid getNextElementTimeTest();\n\tvoid getNextTextTest();\n\tvoid getNextTextTestByPeople();\n\tvoid getNextTextTestByPeopleList();\n\tvoid getNextLoopTest();\n\tvoid getPreviousLoopTest();\n\n\tvoid addObjectTest();\n\tvoid addPeopleTest();\n\nprivate:\n\tQString t2s(PhTime time, PhTimeCodeType tcType);\n\tPhTime s2t(QString string, PhTimeCodeType tcType);\n};\n\n#endif // PHSTRIPDOCTEST_H\n", "name": "tests/AutoTest/StripDocTest.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include <QTest>\n#include <QMouseEvent>\n\n#include \"PhTools/PhDebug.h\"\n#include \"TimeCodeEditTest.h\"\n\n#include \"PhCommonUI/PhTimeCodeEdit.h\"\n\nTimeCodeEditTest::TimeCodeEditTest() : QObject(NULL) {\n}\n\nvoid TimeCodeEditTest::frameTest()\n{\n\tPhTimeCodeEdit tcEdit;\n\n\tQCOMPARE((int)tcEdit.frame(), 0);\n\n\ttcEdit.setText(\"00:00:01:00\");\n\tQCOMPARE((int)tcEdit.frame(), 25);\n}\n\nvoid TimeCodeEditTest::setFrameTest() {\n\tPhTimeCodeEdit tcEdit;\n\n\tQCOMPARE(tcEdit.text(), QString(\"00:00:00:00\"));\n\n\ttcEdit.setFrame(25, PhTimeCodeType25);\n\tQCOMPARE(tcEdit.text(), QString(\"00:00:01:00\"));\n\n\ttcEdit.setFrame(48, PhTimeCodeType24);\n\tQCOMPARE(tcEdit.text(), QString(\"00:00:02:00\"));\n}\n\nvoid TimeCodeEditTest::keyboardInputTest()\n{\n\tPhTimeCodeEdit tcEdit;\n\n\tQTest::keyClicks(&tcEdit, \"9\");\n\tQCOMPARE(tcEdit.text(), QString(\"00:00:00:09\"));\n\tQCOMPARE((int)tcEdit.frame(), 9);\n\tQVERIFY(tcEdit.isTimeCode());\n\n\tQTest::keyClicks(&tcEdit, \"1\");\n\tQCOMPARE(tcEdit.text(), QString(\"00:00:00:91\"));\n\tQCOMPARE((int)tcEdit.frame(), 0);\n\tQVERIFY(!tcEdit.isTimeCode());\n\n\tQTest::keyClicks(&tcEdit, \"2\");\n\tQCOMPARE(tcEdit.text(), QString(\"00:00:09:12\"));\n\tQCOMPARE((int)tcEdit.frame(), 9 * 25 + 12);\n\tQVERIFY(tcEdit.isTimeCode());\n\n\tQTest::keyClick(&tcEdit, Qt::Key_Backspace);\n\tQCOMPARE(tcEdit.text(), QString(\"00:00:00:91\"));\n\tQCOMPARE((int)tcEdit.frame(), 0);\n\tQVERIFY(!tcEdit.isTimeCode());\n\n\tQTest::keyClick(&tcEdit, Qt::Key_Enter);\n\tQCOMPARE(tcEdit.text(), QString(\"00:00:00:91\"));\n}\n\nvoid TimeCodeEditTest::keyboardBadInputTest()\n{\n\tPhTimeCodeEdit tcEdit;\n\n\ttcEdit.setFrame(25, PhTimeCodeType25);\n\tQCOMPARE(tcEdit.text(), QString(\"00:00:01:00\"));\n\n\tQTest::keyClicks(&tcEdit, \"a\");\n\tQCOMPARE(tcEdit.text(), QString(\"00:00:01:00\"));\n}\n\nvoid TimeCodeEditTest::mouseInputTest()\n{\n\tPhTimeCodeEdit tcEdit;\n\n\ttcEdit.show();\n\n\t// Hour testing\n\t// Vertical axis mouse move\n\tQTest::mousePress(&tcEdit, Qt::LeftButton, Qt::NoModifier, QPoint(130, 5));\n\n\t//QTest::mouseMove(&tcEdit, QPoint(130, 200)); // It doesn't seems to work use rather:\n\tQApplication::sendEvent(&tcEdit, new QMouseEvent(QEvent::MouseMove, QPoint(130, 4), Qt::LeftButton, Qt::LeftButton, Qt::NoModifier));\n\tQCOMPARE(tcEdit.text(), QString(\"01:00:00:00\"));\n\n\tQApplication::sendEvent(&tcEdit, new QMouseEvent(QEvent::MouseMove, QPoint(130, 5), Qt::LeftButton, Qt::LeftButton, Qt::NoModifier));\n\tQCOMPARE(tcEdit.text(), QString(\"00:00:00:00\"));\n\n\tQApplication::sendEvent(&tcEdit, new QMouseEvent(QEvent::MouseMove, QPoint(130, 6), Qt::LeftButton, Qt::LeftButton, Qt::NoModifier));\n\tQCOMPARE(tcEdit.text(), QString(\"-01:00:00:00\"));\n\n\t// Vertical and Horizontal axis mouse move, horizontal moves are out\n\t// of the text limits\n\tQApplication::sendEvent(&tcEdit, new QMouseEvent(QEvent::MouseMove, QPoint(100, 5), Qt::LeftButton, Qt::LeftButton, Qt::NoModifier));\n\tQCOMPARE(tcEdit.text(), QString(\"00:00:00:00\"));\n\n\tQApplication::sendEvent(&tcEdit, new QMouseEvent(QEvent::MouseMove, QPoint(200, 4), Qt::LeftButton, Qt::LeftButton, Qt::NoModifier));\n\tQCOMPARE(tcEdit.text(), QString(\"01:00:00:00\"));\n\n\tQTest::mouseRelease(&tcEdit, Qt::LeftButton, Qt::NoModifier, QPoint(130, 200));\n\n\t//Reset\n\ttcEdit.setText(\"00:00:00:00\");\n\t// Minutes testing\n\t// Vertical axis mouse move\n\tQTest::mousePress(&tcEdit, Qt::LeftButton, Qt::NoModifier, QPoint(167, 5), 100);\n\n\tQApplication::sendEvent(&tcEdit, new QMouseEvent(QEvent::MouseMove, QPoint(167, 4), Qt::LeftButton, Qt::LeftButton, Qt::NoModifier));\n\tQCOMPARE(tcEdit.text(), QString(\"00:01:00:00\"));\n\n\tQApplication::sendEvent(&tcEdit, new QMouseEvent(QEvent::MouseMove, QPoint(167, 5), Qt::LeftButton, Qt::LeftButton, Qt::NoModifier));\n\tQCOMPARE(tcEdit.text(), QString(\"00:00:00:00\"));\n\n\tQApplication::sendEvent(&tcEdit, new QMouseEvent(QEvent::MouseMove, QPoint(167, 6), Qt::LeftButton, Qt::LeftButton, Qt::NoModifier));\n\tQCOMPARE(tcEdit.text(), QString(\"-00:01:00:00\"));\n\n\t// Vertical and Horizontal axis mouse move, horizontal moves are out\n\t// of the text limits\n\tQApplication::sendEvent(&tcEdit, new QMouseEvent(QEvent::MouseMove, QPoint(100, 5), Qt::LeftButton, Qt::LeftButton, Qt::NoModifier));\n\tQCOMPARE(tcEdit.text(), QString(\"00:00:00:00\"));\n\n\tQApplication::sendEvent(&tcEdit, new QMouseEvent(QEvent::MouseMove, QPoint(200, 4), Qt::LeftButton, Qt::LeftButton, Qt::NoModifier));\n\tQCOMPARE(tcEdit.text(), QString(\"00:01:00:00\"));\n\n\tQTest::mouseRelease(&tcEdit, Qt::LeftButton, Qt::NoModifier, QPoint(130, 200));\n\n\t//Reset\n\ttcEdit.setText(\"00:00:00:00\");\n\t// Seconds testing\n\t// Vertical axis mouse move\n\tQTest::mousePress(&tcEdit, Qt::LeftButton, Qt::NoModifier, QPoint(167, 5), 100);\n\n\tQApplication::sendEvent(&tcEdit, new QMouseEvent(QEvent::MouseMove, QPoint(167, 4), Qt::LeftButton, Qt::LeftButton, Qt::NoModifier));\n\tQCOMPARE(tcEdit.text(), QString(\"00:01:00:00\"));\n\n\tQApplication::sendEvent(&tcEdit, new QMouseEvent(QEvent::MouseMove, QPoint(167, 5), Qt::LeftButton, Qt::LeftButton, Qt::NoModifier));\n\tQCOMPARE(tcEdit.text(), QString(\"00:00:00:00\"));\n\n\tQApplication::sendEvent(&tcEdit, new QMouseEvent(QEvent::MouseMove, QPoint(167, 6), Qt::LeftButton, Qt::LeftButton, Qt::NoModifier));\n\tQCOMPARE(tcEdit.text(), QString(\"-00:01:00:00\"));\n\n\t// Vertical and Horizontal axis mouse move, horizontal moves are out\n\t// of the text limits\n\tQApplication::sendEvent(&tcEdit, new QMouseEvent(QEvent::MouseMove, QPoint(100, 5), Qt::LeftButton, Qt::LeftButton, Qt::NoModifier));\n\tQCOMPARE(tcEdit.text(), QString(\"00:00:00:00\"));\n\n\tQApplication::sendEvent(&tcEdit, new QMouseEvent(QEvent::MouseMove, QPoint(200, 4), Qt::LeftButton, Qt::LeftButton, Qt::NoModifier));\n\tQCOMPARE(tcEdit.text(), QString(\"00:01:00:00\"));\n\n\tQTest::mouseRelease(&tcEdit, Qt::LeftButton, Qt::NoModifier, QPoint(130, 200));\n\n#warning /// @todo do more mouse test\n\n}\n\n", "name": "tests/AutoTest/TimeCodeEditTest.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef PHTIMECODEEDITTEST_H\n#define PHTIMECODEEDITTEST_H\n\n#include <QObject>\n\nclass TimeCodeEditTest : public QObject\n{\n\tQ_OBJECT\npublic:\n\texplicit TimeCodeEditTest();\n\nprivate slots:\n\tvoid frameTest();\n\tvoid setFrameTest();\n\n\tvoid keyboardInputTest();\n\tvoid keyboardBadInputTest();\n\n\tvoid mouseInputTest();\n};\n\n#endif // PHTIMECODEEDITTEST_H\n", "name": "tests/AutoTest/TimeCodeEditTest.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#include \"TimeCodeTest.h\"\n#include \"PhTools/PhTimeCode.h\"\n\nTimeCodeTest::TimeCodeTest(QObject *parent) :\n\tQObject(parent)\n{\n}\n\nvoid TimeCodeTest::testStringFromFrameForTC2398()\n{\n\tPhTimeCodeType type = PhTimeCodeType2398;\n\n\t// Check various value of frame\n\tPhFrame frame = 0;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:00:00:00\"));\n\tframe = 1;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:00:00:01\"));\n\tframe = 23;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:00:00:23\"));\n\tframe = 24;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:00:01:00\"));\n\tframe = 47;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:00:01:23\"));\n\tframe = 48;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:00:02:00\"));\n\tframe = 1439;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:00:59:23\"));\n\tframe = 1440;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:01:00:00\"));\n\tframe = 2879;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:01:59:23\"));\n\tframe = 2880;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:02:00:00\"));\n\tframe = 4319;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:02:59:23\"));\n\tframe = 4320;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:03:00:00\"));\n\tframe = 14399;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:09:59:23\"));\n\tframe = 14400;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:10:00:00\"));\n\tframe = 14401;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:10:00:01\"));\n\tframe = 15839;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:10:59:23\"));\n\tframe = 15840;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:11:00:00\"));\n}\n\nvoid TimeCodeTest::testStringFromFrameForTC24() {\n\tPhTimeCodeType type = PhTimeCodeType24;\n\n\t// Check various value of frame\n\tPhFrame frame = 0;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:00:00:00\"));\n\tframe = 1;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:00:00:01\"));\n\tframe = 23;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:00:00:23\"));\n\tframe = 24;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:00:01:00\"));\n\tframe = 47;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:00:01:23\"));\n\tframe = 48;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:00:02:00\"));\n\tframe = 1439;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:00:59:23\"));\n\tframe = 1440;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:01:00:00\"));\n\tframe = 2879;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:01:59:23\"));\n\tframe = 2880;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:02:00:00\"));\n\tframe = 4319;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:02:59:23\"));\n\tframe = 4320;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:03:00:00\"));\n\tframe = 14399;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:09:59:23\"));\n\tframe = 14400;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:10:00:00\"));\n\tframe = 14401;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:10:00:01\"));\n\tframe = 15839;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:10:59:23\"));\n\tframe = 15840;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:11:00:00\"));\n}\n\nvoid TimeCodeTest::testStringFromFrameForTC25() {\n\tPhTimeCodeType type = PhTimeCodeType25;\n\n\t// Check various value of frame\n\tPhFrame frame = 0;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:00:00:00\"));\n\tframe = 1;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:00:00:01\"));\n\tframe = 24;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:00:00:24\"));\n\tframe = 25;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:00:01:00\"));\n\tframe = 49;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:00:01:24\"));\n\tframe = 50;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:00:02:00\"));\n\tframe = 1499;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:00:59:24\"));\n\tframe = 1500;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:01:00:00\"));\n\tframe = 2999;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:01:59:24\"));\n\tframe = 3000;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:02:00:00\"));\n\tframe = 4499;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:02:59:24\"));\n\tframe = 4500;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:03:00:00\"));\n\tframe = 14999;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:09:59:24\"));\n\tframe = 15000;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:10:00:00\"));\n\tframe = 15001;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:10:00:01\"));\n\tframe = 16499;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:10:59:24\"));\n\tframe = 16500;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:11:00:00\"));\n}\n\nvoid TimeCodeTest::testStringFromFrameForTC2997() {\n\tPhTimeCodeType type = PhTimeCodeType2997;\n\n\t// Check various value of frame\n\tPhFrame frame = 0;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:00:00:00\"));\n\tframe = 1;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:00:00:01\"));\n\tframe = 2;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:00:00:02\"));\n\tframe = 29;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:00:00:29\"));\n\tframe = 30;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:00:01:00\"));\n\tframe = 59;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:00:01:29\"));\n\tframe = 60;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:00:02:00\"));\n\tframe = 1799;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:00:59:29\"));\n\tframe = 1800;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:01:00:02\"));\n\tframe = 3597;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:01:59:29\"));\n\tframe = 3598;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:02:00:02\"));\n\tframe = 5395;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:02:59:29\"));\n\tframe = 5396;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:03:00:02\"));\n\tframe = 7193;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:03:59:29\"));\n\tframe = 7194;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:04:00:02\"));\n\tframe = 17981;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:09:59:29\"));\n\tframe = 17982;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:10:00:00\"));\n\tframe = 17983;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:10:00:01\"));\n\tframe = 19781;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:10:59:29\"));\n\tframe = 19782;\n\tQCOMPARE(PhTimeCode::stringFromFrame(frame, type), QString(\"00:11:00:02\"));\n}\n\nvoid TimeCodeTest::testFrameFromStringForTC2398()\n{\n\tPhTimeCodeType type = PhTimeCodeType2398;\n\n\t// Check various value of string\n\tQString string = \"00:00:00:00\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 0);\n\tstring = \"00:00:00:01\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 1);\n\tstring = \"00:00:00:23\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 23);\n\tstring = \"00:00:01:00\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 24);\n\tstring = \"00:00:01:23\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 47);\n\tstring = \"00:00:02:00\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 48);\n\tstring = \"00:00:59:23\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 1439);\n\tstring = \"00:01:00:00\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 1440);\n\tstring = \"00:01:59:23\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 2879);\n\tstring = \"00:02:00:00\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 2880);\n\tstring = \"00:02:59:23\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 4319);\n\tstring = \"00:03:00:00\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 4320);\n\tstring = \"00:09:59:23\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 14399);\n\tstring = \"00:10:00:00\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 14400);\n\tstring = \"00:10:00:01\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 14401);\n\tstring = \"00:10:59:23\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 15839);\n\tstring = \"00:11:00:00\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 15840);\n}\n\nvoid TimeCodeTest::testFrameFromStringForTC24() {\n\tPhTimeCodeType type = PhTimeCodeType24;\n\n\t// Check various value of string\n\tQString string = \"00:00:00:00\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 0);\n\tstring = \"00:00:00:01\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 1);\n\tstring = \"00:00:00:23\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 23);\n\tstring = \"00:00:01:00\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 24);\n\tstring = \"00:00:01:23\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 47);\n\tstring = \"00:00:02:00\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 48);\n\tstring = \"00:00:59:23\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 1439);\n\tstring = \"00:01:00:00\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 1440);\n\tstring = \"00:01:59:23\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 2879);\n\tstring = \"00:02:00:00\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 2880);\n\tstring = \"00:02:59:23\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 4319);\n\tstring = \"00:03:00:00\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 4320);\n\tstring = \"00:09:59:23\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 14399);\n\tstring = \"00:10:00:00\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 14400);\n\tstring = \"00:10:00:01\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 14401);\n\tstring = \"00:10:59:23\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 15839);\n\tstring = \"00:11:00:00\";\n\n}\n\nvoid TimeCodeTest::testFrameFromStringForTC25() {\n\tPhTimeCodeType type = PhTimeCodeType25;\n\n\t// Check various value of string\n\tQString string = \"00:00:00:00\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 0);\n\tstring = \"00:00:00:01\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 1);\n\tstring = \"00:00:00:24\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 24);\n\tstring = \"00:00:01:00\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 25);\n\tstring = \"00:00:01:24\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 49);\n\tstring = \"00:00:02:00\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 50);\n\tstring = \"00:00:59:24\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 1499);\n\tstring = \"00:01:00:00\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 1500);\n\tstring = \"00:01:59:24\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 2999);\n\tstring = \"00:02:00:00\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 3000);\n\tstring = \"00:02:59:24\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 4499);\n\tstring = \"00:03:00:00\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 4500);\n\tstring = \"00:09:59:24\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 14999);\n\tstring = \"00:10:00:00\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 15000);\n\tstring = \"00:10:00:01\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 15001);\n\tstring = \"00:10:59:24\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 16499);\n\tstring = \"00:11:00:00\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 16500);\n}\n\nvoid TimeCodeTest::testFrameFromStringForTC2997() {\n\tPhTimeCodeType type = PhTimeCodeType2997;\n\n\t// Check various value of string\n\tQString string = \"00:00:00:00\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 0);\n\tstring = \"00:00:00:01\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 1);\n\tstring = \"00:00:00:29\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 29);\n\tstring = \"00:00:01:00\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 30);\n\tstring = \"00:00:01:29\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 59);\n\tstring = \"00:00:02:00\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 60);\n\tstring = \"00:00:59:29\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 1799);\n\tstring = \"00:01:00:02\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 1800);\n\tstring = \"00:01:59:29\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 3597);\n\tstring = \"00:02:00:02\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 3598);\n\tstring = \"00:02:59:29\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 5395);\n\tstring = \"00:03:00:02\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 5396);\n\tstring = \"00:03:59:29\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 7193);\n\tstring = \"00:04:00:02\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 7194);\n\tstring = \"00:09:59:29\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 17981);\n\tstring = \"00:10:00:00\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 17982);\n\tstring = \"00:10:00:01\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 17983);\n\tstring = \"00:10:59:29\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 19781);\n\tstring = \"00:11:00:02\";\n\tQCOMPARE((int)PhTimeCode::frameFromString(string, type), 19782);\n}\n\nvoid TimeCodeTest::testBcdFromFrameForTC2398() {\n\tPhTimeCodeType type = PhTimeCodeType2398;\n\tPhFrame frame = 0;\n\n\t// Check various value of frame\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00000000);\n\tframe = 1;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00000001);\n\tframe = 23;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00000023);\n\tframe = 24;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00000100);\n\tframe = 47;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00000123);\n\tframe = 48;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00000200);\n\tframe = 1439;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00005923);\n\tframe = 1440;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00010000);\n\tframe = 2879;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00015923);\n\tframe = 2880;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00020000);\n\tframe = 4319;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00025923);\n\tframe = 4320;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00030000);\n\tframe = 14399;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00095923);\n\tframe = 14400;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00100000);\n\tframe = 14401;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00100001);\n\tframe = 15839;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00105923);\n\tframe = 15840;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00110000);\n}\n\nvoid TimeCodeTest::testBcdFromFrameForTC24() {\n\tPhTimeCodeType type = PhTimeCodeType24;\n\tPhFrame frame = 0;\n\n\t// Check various value of frame\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00000000);\n\tframe = 1;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00000001);\n\tframe = 23;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00000023);\n\tframe = 24;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00000100);\n\tframe = 47;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00000123);\n\tframe = 48;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00000200);\n\tframe = 1439;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00005923);\n\tframe = 1440;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00010000);\n\tframe = 2879;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00015923);\n\tframe = 2880;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00020000);\n\tframe = 4319;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00025923);\n\tframe = 4320;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00030000);\n\tframe = 14399;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00095923);\n\tframe = 14400;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00100000);\n\tframe = 14401;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00100001);\n\tframe = 15839;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00105923);\n\tframe = 15840;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00110000);\n}\n\nvoid TimeCodeTest::testBcdFromFrameForTC25() {\n\tPhTimeCodeType type = PhTimeCodeType25;\n\n\t// Check various value of frame\n\tPhFrame frame = 0;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00000000);\n\tframe = 1;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00000001);\n\tframe = 24;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00000024);\n\tframe = 25;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00000100);\n\tframe = 49;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00000124);\n\tframe = 50;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00000200);\n\tframe = 1499;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00005924);\n\tframe = 1500;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00010000);\n\tframe = 2999;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00015924);\n\tframe = 3000;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00020000);\n\tframe = 4499;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00025924);\n\tframe = 4500;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00030000);\n\tframe = 14999;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00095924);\n\tframe = 15000;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00100000);\n\tframe = 15001;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00100001);\n\tframe = 16499;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00105924);\n\tframe = 16500;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00110000);\n}\n\nvoid TimeCodeTest::testBcdFromFrameForTC2997() {\n\tPhTimeCodeType type = PhTimeCodeType2997;\n\n\t// Check various value of frame\n\tPhFrame frame = 0;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x000000);\n\tframe = 1;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00000001);\n\tframe = 2;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00000002);\n\tframe = 29;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00000029);\n\tframe = 30;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00000100);\n\tframe = 59;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00000129);\n\tframe = 60;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00000200);\n\tframe = 1799;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00005929);\n\tframe = 1800;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00010002);\n\tframe = 3597;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00015929);\n\tframe = 3598;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00020002);\n\tframe = 5395;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00025929);\n\tframe = 5396;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00030002);\n\tframe = 7193;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00035929);\n\tframe = 7194;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00040002);\n\tframe = 17981;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00095929);\n\tframe = 17982;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00100000);\n\tframe = 17983;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00100001);\n\tframe = 19781;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00105929);\n\tframe = 19782;\n\tQCOMPARE((int)PhTimeCode::bcdFromFrame(frame, type), 0x00110002);\n}\n\nvoid TimeCodeTest::testFrameFromBcdForTC2398() {\n\tPhTimeCodeType type = PhTimeCodeType2398;\n\n\t// Check various value of binary coded decimal (bcd)\n\tunsigned int bcd = 0x00000000;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 0);\n\tbcd = 0x00000001;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 1);\n\tbcd = 0x00000023;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 23);\n\tbcd = 0x00000100;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 24);\n\tbcd = 0x00000123;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 47);\n\tbcd = 0x00000200;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 48);\n\tbcd = 0x00005923;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 1439);\n\tbcd = 0x00010000;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 1440);\n\tbcd = 0x00015923;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 2879);\n\tbcd = 0x00020000;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 2880);\n\tbcd = 0x00025923;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 4319);\n\tbcd = 0x00030000;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 4320);\n\tbcd = 0x00095923;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 14399);\n\tbcd = 0x00100000;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 14400);\n\tbcd = 0x00100001;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 14401);\n\tbcd = 0x00105923;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 15839);\n\tbcd = 0x00110000;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 15840);\n}\n\nvoid TimeCodeTest::testFrameFromBcdForTC24() {\n\tPhTimeCodeType type = PhTimeCodeType24;\n\n\t// Check various value of binary coded decimal (bcd)\n\tunsigned int bcd = 0x00000000;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 0);\n\tbcd = 0x00000001;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 1);\n\tbcd = 0x00000023;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 23);\n\tbcd = 0x00000100;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 24);\n\tbcd = 0x00000123;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 47);\n\tbcd = 0x00000200;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 48);\n\tbcd = 0x00005923;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 1439);\n\tbcd = 0x00010000;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 1440);\n\tbcd = 0x00015923;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 2879);\n\tbcd = 0x00020000;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 2880);\n\tbcd = 0x00025923;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 4319);\n\tbcd = 0x00030000;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 4320);\n\tbcd = 0x00095923;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 14399);\n\tbcd = 0x00100000;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 14400);\n\tbcd = 0x00100001;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 14401);\n\tbcd = 0x00105923;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 15839);\n\tbcd = 0x00110000;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 15840);\n}\n\nvoid TimeCodeTest::testFrameFromBcdForTC25() {\n\tPhTimeCodeType type = PhTimeCodeType25;\n\n\t// Check various value of binary coded decimal (bcd)\n\tunsigned int bcd = 0x00000000;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 0);\n\tbcd = 0x00000001;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 1);\n\tbcd = 0x00000024;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 24);\n\tbcd = 0x00000100;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 25);\n\tbcd = 0x00000124;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 49);\n\tbcd = 0x00000200;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 50);\n\tbcd = 0x00005924;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 1499);\n\tbcd = 0x00010000;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 1500);\n\tbcd = 0x00015924;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 2999);\n\tbcd = 0x00020000;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 3000);\n\tbcd = 0x00025924;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 4499);\n\tbcd = 0x00030000;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 4500);\n\tbcd = 0x00095924;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 14999);\n\tbcd = 0x00100000;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 15000);\n\tbcd = 0x00100001;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 15001);\n\tbcd = 0x00105924;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 16499);\n\tbcd = 0x00110000;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 16500);\n}\n\nvoid TimeCodeTest::testFrameFromBcdForTC2997() {\n\tPhTimeCodeType type = PhTimeCodeType2997;\n\n\t// Check various value of binary coded decimal (bcd)\n\tunsigned int bcd = 0x00000000;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 0);\n\tbcd = 0x00000001;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 1);\n\tbcd = 0x00000029;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 29);\n\tbcd = 0x00000100;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 30);\n\tbcd = 0x00000129;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 59);\n\tbcd = 0x00000200;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 60);\n\tbcd = 0x00005929;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 1799);\n\tbcd = 0x00010002;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 1800);\n\tbcd = 0x00015929;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 3597);\n\tbcd = 0x00020002;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 3598);\n\tbcd = 0x00025929;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 5395);\n\tbcd = 0x00030002;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 5396);\n\tbcd = 0x00035929;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 7193);\n\tbcd = 0x00040002;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 7194);\n\tbcd = 0x00095929;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 17981);\n\tbcd = 0x00100000;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 17982);\n\tbcd = 0x00100001;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 17983);\n\tbcd = 0x00105929;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 19781);\n\tbcd = 0x00110002;\n\tQCOMPARE((int)PhTimeCode::frameFromBcd(bcd, type), 19782);\n}\n\n\nvoid TimeCodeTest::testStringFromFrameWithExtremeValue() {\n\tPhTimeCodeType type = PhTimeCodeType25;\n\n\t// Test frame values around 24h\n\tQCOMPARE(PhTimeCode::stringFromFrame(2159999, type), QString(\"23:59:59:24\"));\n\tQCOMPARE(PhTimeCode::stringFromFrame(2160000, type), QString(\"24:00:00:00\"));\n\tQCOMPARE(PhTimeCode::stringFromFrame(2160001, type), QString(\"24:00:00:01\"));\n\tQCOMPARE(PhTimeCode::stringFromFrame(2176499, type), QString(\"24:10:59:24\"));\n\n\t// Test frame values around -24h\n\tQCOMPARE(PhTimeCode::stringFromFrame(-1, type), QString(\"-00:00:00:01\"));\n\tQCOMPARE(PhTimeCode::stringFromFrame(-2159999, type), QString(\"-23:59:59:24\"));\n\tQCOMPARE(PhTimeCode::stringFromFrame(-2160000, type), QString(\"-24:00:00:00\"));\n\tQCOMPARE(PhTimeCode::stringFromFrame(-2160001, type), QString(\"-24:00:00:01\"));\n\tQCOMPARE(PhTimeCode::stringFromFrame(-2176499, type), QString(\"-24:10:59:24\"));\n}\n\nvoid TimeCodeTest::testTCWithSpecialString() {\n\tPhTimeCodeType type = PhTimeCodeType25;\n\n\t// Test bad value for hh, mm, ss and ff\n\tQCOMPARE(PhTimeCode::stringFromFrame(PhTimeCode::frameFromString(\"12:23:34:30\", type), type), QString(\"12:23:34:00\"));\n\tQCOMPARE(PhTimeCode::stringFromFrame(PhTimeCode::frameFromString(\"12:23:34:ff\", type), type), QString(\"12:23:34:00\"));\n\tQCOMPARE(PhTimeCode::stringFromFrame(PhTimeCode::frameFromString(\"12:23:60:19\", type), type), QString(\"12:23:00:19\"));\n\tQCOMPARE(PhTimeCode::stringFromFrame(PhTimeCode::frameFromString(\"12:23:ss:19\", type), type), QString(\"12:23:00:19\"));\n\tQCOMPARE(PhTimeCode::stringFromFrame(PhTimeCode::frameFromString(\"12:60:34:19\", type), type), QString(\"12:00:34:19\"));\n\tQCOMPARE(PhTimeCode::stringFromFrame(PhTimeCode::frameFromString(\"12:mm:34:19\", type), type), QString(\"12:00:34:19\"));\n\tQCOMPARE(PhTimeCode::stringFromFrame(PhTimeCode::frameFromString(\"hh:23:34:19\", type), type), QString(\"00:23:34:19\"));\n\n\t// Test extreme value for hh\n\tQCOMPARE(PhTimeCode::stringFromFrame(PhTimeCode::frameFromString(\"24:23:34:19\", type), type), QString(\"24:23:34:19\"));\n\tQCOMPARE(PhTimeCode::stringFromFrame(PhTimeCode::frameFromString(\"-1:23:34:19\", type), type), QString(\"-01:23:34:19\"));\n\n\t// Test bad digit count : if there is not enough digit, frame are considered first, then seconds, minutes and hours\n\tQCOMPARE(PhTimeCode::stringFromFrame(PhTimeCode::frameFromString(\"19\", type), type), QString(\"00:00:00:19\"));\n\tQCOMPARE(PhTimeCode::stringFromFrame(PhTimeCode::frameFromString(\"34:19\", type), type), QString(\"00:00:34:19\"));\n\tQCOMPARE(PhTimeCode::stringFromFrame(PhTimeCode::frameFromString(\"23:34:19\", type), type), QString(\"00:23:34:19\"));\n\n\t// Test bad digit count : if there is to much digit, only the first four are taken in account\n\tQCOMPARE(PhTimeCode::stringFromFrame(PhTimeCode::frameFromString(\"12:23:34:19:12\", type), type), QString(\"12:23:34:19\"));\n}\n\n", "name": "tests/AutoTest/TimeCodeTest.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * @file\n * @copyright (C) 2012-2014 Phonations\n * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef PHTIMECODETEST_H\n#define PHTIMECODETEST_H\n\n#include <QtTest>\n\n/**\n * @brief Test the PhTimeCode class.\n */\nclass TimeCodeTest : public QObject\n{\n\tQ_OBJECT\npublic:\n\t/**\n\t * @brief PhTimeCodeTest constructor.\n\t * @param parent The object owner.\n\t */\n\texplicit TimeCodeTest(QObject *parent = 0);\n\nprivate slots:\n\t/** @brief Test stringFromFrame for 23.98 timecode. */\n\tvoid testStringFromFrameForTC2398();\n\n\t/** @brief Test stringFromFrame for 24 timecode. */\n\tvoid testStringFromFrameForTC24();\n\n\t/** @brief Test stringFromFrame for 25 timecode. */\n\tvoid testStringFromFrameForTC25();\n\n\t/** @brief Test stringFromFrame for 29.97 timecode. */\n\tvoid testStringFromFrameForTC2997();\n\n\t/** @brief Test frameFromString for 23.98 timecode. */\n\tvoid testFrameFromStringForTC2398();\n\n\t/** @brief Test frameFromString for 24 timecode. */\n\tvoid testFrameFromStringForTC24();\n\n\t/** @brief Test frameFromString for 25 timecode. */\n\tvoid testFrameFromStringForTC25();\n\n\t/** @brief Test frameFromString for 29.97 timecode. */\n\tvoid testFrameFromStringForTC2997();\n\n\t/** @brief Test bcdFromFrame for 23.98 timecode. */\n\tvoid testBcdFromFrameForTC2398();\n\n\t/** @brief Test bcdFromFrame for 24 timecode. */\n\tvoid testBcdFromFrameForTC24();\n\n\t/** @brief Test bcdFromFrame for 25 timecode. */\n\tvoid testBcdFromFrameForTC25();\n\n\t/** @brief Test bcdFromFrame for 29.97 timecode. */\n\tvoid testBcdFromFrameForTC2997();\n\n\t/** @brief Test frameFromBcd for 23.98 timecode. */\n\tvoid testFrameFromBcdForTC2398();\n\n\t/** @brief Test frameFromBcd for 24 timecode. */\n\tvoid testFrameFromBcdForTC24();\n\n\t/** @brief Test frameFromBcd for 25 timecode. */\n\tvoid testFrameFromBcdForTC25();\n\n\t/** @brief Test frameFromBcd for 29.97 timecode. */\n\tvoid testFrameFromBcdForTC2997();\n\n\t/** @brief Test stringFromFrame with value out of the common scope */\n\tvoid testStringFromFrameWithExtremeValue();\n\n\t/** @brief Test stringFromFrame with bad formated strings */\n\tvoid testTCWithSpecialString();\n};\n\n#endif // PHTIMECODETEST_H\n", "name": "tests/AutoTest/TimeCodeTest.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include <QTest>\n#include <QAction>\n\n#include \"PhTools/PhDebug.h\"\n\n#include \"WindowTest.h\"\n\n#include \"AutoTestSettings.h\"\n#include \"AutoTestWindow.h\"\n\nvoid WindowTest::fullScreenTest01()\n{\n\tAutoTestSettings settings;\n\tQByteArray emptyArray;\n\tsettings.setWindowGeometry(emptyArray);\n\tsettings.setFullScreen(false);\n\tAutoTestWindow w(&settings);\n\tw.show();\n\tQVERIFY(!w.isFullScreen());\n\tQVERIFY(!w.fullScreenAction()->isChecked());\n\n\tw.toggleFullScreen();\n\tQVERIFY(w.isFullScreen());\n\tQVERIFY(settings.fullScreen());\n\tQVERIFY(w.fullScreenAction()->isChecked());\n\tw.close();\n}\n\nvoid WindowTest::fullScreenTest02()\n{\n\tAutoTestSettings settings(true);\n\n\tsettings.setFullScreen(true);\n\tAutoTestWindow w(&settings);\n\tw.show();\n\tQTest::qWait(900);\n\t// full screen take one second to trigger\n//\tQVERIFY(!w.isFullScreen());\n//\tQVERIFY(!w.fullScreenAction()->isChecked()); ----> fails only on travis-ci.org\n\tQTest::qWait(200);\n\tQVERIFY(w.isFullScreen());\n\tQVERIFY(w.fullScreenAction()->isChecked());\n\n\tw.fullScreenAction()->trigger();\n\tQVERIFY(!w.isFullScreen());\n\tQVERIFY(!w.fullScreenAction()->isChecked());\n\n\tw.close();\n}\n\nvoid WindowTest::currentDocumentTest()\n{\n\tAutoTestSettings settings(true);\n\n\tsettings.setCurrentDocument(\"text.txt\");\n\n\tAutoTestWindow w(&settings);\n\tw.processArg(0, NULL);\n\tQCOMPARE(w.text(), QString(\"bonjour\"));\n}\n", "name": "tests/AutoTest/WindowTest.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef WINDOWTEST_H\n#define WINDOWTEST_H\n\n#include <QObject>\n\nclass WindowTest : public QObject\n{\n\tQ_OBJECT\nprivate slots:\n\tvoid fullScreenTest01();\n\tvoid fullScreenTest02();\n\n\tvoid currentDocumentTest();\n};\n\n#endif // WINDOWTEST_H\n", "name": "tests/AutoTest/WindowTest.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include \"AVTestWindow.h\"\n#include \"ui_AVTestWindow.h\"\n\n#include <QPushButton>\n#include <QBoxLayout>\n#include <QFileInfo>\n#include <QFileDialog>\n#include <QMessageBox>\n\n#include \"PhCommonUI/PhTimeCodeDialog.h\"\n\nAVTestWindow::AVTestWindow(QSettings *settings)\n\t: QMainWindow(0),\n\tui(new Ui::AVTestWindow),\n\t_settings(settings),\n\t_videoEngine(true)\n{\n\tui->setupUi(this);\n\t_videoEngine.setSettings(settings);\n\t_mediaPanelDialog.setClock(_videoEngine.clock());\n\t_mediaPanelDialog.show();\n\n\tui->_videoView->setEngine(&_videoEngine);\n}\n\nAVTestWindow::~AVTestWindow()\n{\n\tdelete ui;\n}\n\nbool AVTestWindow::openFile(QString fileName)\n{\n\tQFileInfo fileInfo(fileName);\n\tif (fileInfo.exists()) {\n\t\tif(_videoEngine.open(fileName)) {\n\t\t\tthis->setWindowTitle(fileName);\n\t\t\t_mediaPanelDialog.setMediaLength(_videoEngine.length());\n\n\t\t\tPhFrame frameStamp = _videoEngine.frameStamp();\n\t\t\t_mediaPanelDialog.setFirstFrame(frameStamp);\n\n\t\t\t_videoEngine.clock()->setFrame(frameStamp);\n\t\t\t//_videoEngine.clock()->setRate(1.0);\n\t\t\t_settings->setValue(\"lastVideoFile\", fileName);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid AVTestWindow::resizeEvent(QResizeEvent *)\n{\n\tPHDEBUG << this->width() << this->height();\n\t_mediaPanelDialog.move(this->x() + this->width() / 2 - _mediaPanelDialog.width() / 2,\n\t                       this->y() + this->height() * 0.95 - _mediaPanelDialog.height());\n}\n\nvoid AVTestWindow::on_actionPlay_pause_triggered()\n{\n\tif(_videoEngine.clock()->rate() != 0)\n\t\t_videoEngine.clock()->setRate(0);\n\telse\n\t\t_videoEngine.clock()->setRate(1);\n}\n\nvoid AVTestWindow::on_actionNext_frame_triggered()\n{\n\t_videoEngine.clock()->setFrame(_videoEngine.clock()->frame() + 1);\n}\n\nvoid AVTestWindow::on_actionPrevious_frame_triggered()\n{\n\t_videoEngine.clock()->setFrame(_videoEngine.clock()->frame() - 1);\n}\n\nvoid AVTestWindow::on_actionSet_timestamp_triggered()\n{\n\tPhTimeCodeDialog dlg(_videoEngine.clock()->timeCodeType(), _videoEngine.clock()->frame());\n\tif(dlg.exec() == QDialog::Accepted) {\n\t\tPhFrame frameStamp = _videoEngine.frameStamp();\n\t\tframeStamp += dlg.frame() - _videoEngine.clock()->frame();\n\t\t_videoEngine.setFrameStamp(frameStamp);\n\t\t_mediaPanelDialog.setFirstFrame(frameStamp);\n\t\t_videoEngine.clock()->setFrame(dlg.frame());\n\t}\n}\n\nvoid AVTestWindow::on_actionOpen_triggered()\n{\n\tQString fileName = QFileDialog::getOpenFileName(this, tr(\"Open Movie\"), QDir::homePath());\n\tif(!openFile(fileName))\n\t\tQMessageBox::critical(this, \"Error\", \"Unable to open \" + fileName);\n}\n\nvoid AVTestWindow::on_actionReverse_triggered()\n{\n\t_videoEngine.clock()->setRate(-1);\n}\n", "name": "tests/AVTest/AVTestWindow.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef AVTESTWINDOW_H\n#define AVTESTWINDOW_H\n\n#include <QMainWindow>\n#include <QString>\n#include <QTimer>\n#include <QSettings>\n\n#include \"PhTools/PhClock.h\"\n#include \"PhTools/PhDebug.h\"\n\n#include \"PhVideo/PhVideoView.h\"\n#include \"PhVideo/PhVideoEngine.h\"\n\n#include \"PhCommonUI/PhMediaPanelDialog.h\"\n\nnamespace Ui {\nclass AVTestWindow;\n}\n\nclass AVTestWindow : public QMainWindow\n{\n\tQ_OBJECT\npublic:\n\t/**\n\t * @brief MainView constructor\n\t */\n\tAVTestWindow(QSettings *settings);\n\n\t~AVTestWindow();\n\t/**\n\t * Open a video file.\n\t * @param fileName Path of the video file to open.\n\t * @return True if succeeds, false otherwise.\n\t */\n\tbool openFile(QString fileName);\n\nprotected:\n\tvoid resizeEvent(QResizeEvent *);\n\nprivate slots:\n\tvoid on_actionPlay_pause_triggered();\n\n\tvoid on_actionNext_frame_triggered();\n\n\tvoid on_actionPrevious_frame_triggered();\n\n\tvoid on_actionSet_timestamp_triggered();\n\n\tvoid on_actionOpen_triggered();\n\n\tvoid on_actionReverse_triggered();\n\nprivate:\n\n\tUi::AVTestWindow *ui;\n\tQSettings *_settings;\n\tPhVideoEngine _videoEngine;\n\tPhMediaPanelDialog _mediaPanelDialog;\n};\n\n#endif\n", "name": "tests/AVTest/AVTestWindow.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include <QtWidgets/QApplication>\n#include <QSettings>\n\n#include \"AVTestWindow.h\"\n\nint main(int argc, char *argv[])\n{\n\tQApplication app(argc, argv);\n\tQSettings settings(\"Phonations\", \"AVTest\");\n\n\tAVTestWindow w(&settings);\n\tw.resize(800, 600);\n\n\tw.show();\n\n\tQString fileName = settings.value(\"lastVideoFile\", \"\").toString();\n\tif(argc > 1)\n\t\tfileName = argv[1];\n\tif(QFile(fileName).exists())\n\t\tw.openFile(QString(fileName));\n\n\treturn app.exec();\n}\n", "name": "tests/AVTest/main.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include <QCoreApplication>\n#include <QTest>\n#include <QTime>\n\n#include \"PhTools/PhTimeCode.h\"\n#include \"PhTools/PhDebug.h\"\n\n/**\n * @brief The application main entry point\n * @param argc Command line argument count\n * @param argv Command line argument list\n * @return 0 if the application works well.\n */\nint main(int argc, char *argv[])\n{\n\tPhDebug::setDisplay(true, true, true, true, true);\n\tPhDebug::setLogMask(0b111);\n\tPHDEBUG << QString(\"test\");\n\tfor(int i = 0; i < 5; i++) {\n\t\tPHDBG(i) << \"level\" << i;\n\t}\n\n\tqWarning() << \"pouet\";\n\tPHERR << \"coucou\";\n\treturn 0;\n}\n", "name": "tests/ConsoleTest/main.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include \"FFmpegTestWindow.h\"\n#include \"ui_FFmpegTestWindow.h\"\n\n#include <QFileDialog>\n#include <QMessageBox>\n#include <QDebug>\n#include <QPainter>\n\nFFmpegTestWindow::FFmpegTestWindow(QWidget *parent) :\n\tQMainWindow(parent),\n\tui(new Ui::FFmpegTestWindow),\n\t_pFormatContext(NULL),\n\t_videoStream(NULL),\n\t_pCodecContext(NULL),\n\t_pFrame(NULL),\n\t_pSwsCtx(NULL),\n\t_image(NULL),\n\t_rgb(NULL),\n\t_currentFrame(0),\n\t_rate(0)\n{\n\tui->setupUi(this);\n\n\tav_register_all();\n\n\tconnect(&_timer, SIGNAL(timeout()), this, SLOT(onTimeOut()));\n\t_timer.start(40);\n}\n\nFFmpegTestWindow::~FFmpegTestWindow()\n{\n\tdelete ui;\n}\n\nbool FFmpegTestWindow::openFile(QString fileName)\n{\n\tqDebug() << fileName;\n\tif(avformat_open_input(&_pFormatContext, fileName.toStdString().c_str(), NULL, NULL) < 0)\n\t\treturn false;\n\n\t// Retrieve stream information\n\tif (avformat_find_stream_info(_pFormatContext, NULL) < 0)\n\t\treturn -1; // Couldn't find stream information\n\n\tav_dump_format(_pFormatContext, 0, fileName.toStdString().c_str(), 0);\n\n\t// Find video stream :\n\tfor(int i = 0; i < _pFormatContext->nb_streams; i++) {\n\t\tif(_pFormatContext->streams[i]->codec->codec_type == AVMEDIA_TYPE_VIDEO) {\n\t\t\t_videoStream = _pFormatContext->streams[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(_videoStream == NULL)\n\t\treturn false;\n\n\t_pCodecContext = _videoStream->codec;\n\n\tqDebug() << \"size : \" << _pCodecContext->width << \"x\" << _pCodecContext->height;\n\tAVCodec * pCodec = avcodec_find_decoder(_pCodecContext->codec_id);\n\tif(pCodec == NULL) {\n\t\tqDebug() << \"Unable to find decoder\";\n\t\treturn false;\n\t}\n\n\tif(avcodec_open2(_pCodecContext, pCodec, NULL) < 0) {\n\t\tqDebug() << \"Unable to open decoder\";\n\t\treturn false;\n\t}\n\n\t_pFrame = avcodec_alloc_frame();\n\n\tresizeEvent(NULL);\n\n\t_currentFrame = 0;\n\treturn setFrame(0);\n}\n\nbool FFmpegTestWindow::setFrame(int frame)\n{\n\tif(!_videoStream)\n\t\treturn false;\n\tav_seek_frame(_pFormatContext, _videoStream->index, frame, 0);\n\n\tAVPacket packet;\n\twhile(av_read_frame(_pFormatContext, &packet) >= 0) {\n\t\tif(packet.stream_index == _videoStream->index) {\n\t\t\tint ok;\n\t\t\tavcodec_decode_video2(_pCodecContext, _pFrame, &ok, &packet);\n\t\t\tif(!ok)\n\t\t\t\treturn false;\n\n\t\t\tint linesize = _image->width() * 3;\n\t\t\t// Convert the image into YUV format that SDL uses\n\t\t\tif (sws_scale(_pSwsCtx, (const uint8_t * const *) _pFrame->data,\n\t\t\t              _pFrame->linesize, 0, _pCodecContext->height, &_rgb,\n\t\t\t              &linesize) < 0)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid FFmpegTestWindow::paintEvent(QPaintEvent *)\n{\n\tif(_image) {\n\t\tQPainter painter(this);\n\t\tpainter.drawImage(0, 0, *_image);\n\t}\n}\n\nvoid FFmpegTestWindow::resizeEvent(QResizeEvent *)\n{\n\tif(_pCodecContext == NULL)\n\t\treturn;\n\tint w = this->width();\n\tint h = this->height();\n\n\t// adjust width to a multiple of 4:\n\tint pow = 4;\n\tif(w % pow)\n\t\tw += pow - (w % pow);\n\n\tif(_rgb)\n\t\tdelete _rgb;\n\t_rgb = new uint8_t[3 * w * h];\n\n\tif(_image)\n\t\tdelete _image;\n\n\t_image = new QImage(_rgb, w, h, QImage::Format_RGB888);\n\n\n\t_pSwsCtx = sws_getContext(_pCodecContext->width, _pCodecContext->height,\n\t                          _pCodecContext->pix_fmt, w, h,\n\t                          AV_PIX_FMT_RGB24, SWS_FAST_BILINEAR, NULL, NULL, NULL);\n}\n\nvoid FFmpegTestWindow::on_actionOpen_triggered()\n{\n\tQString fileName = QFileDialog::getOpenFileName(this, \"Open...\");\n\tif(QFile::exists(fileName)) {\n\t\tif(!openFile(fileName))\n\t\t\tQMessageBox::critical(this, \"Error\", \"Unable to open \" + fileName);\n\t}\n}\n\nvoid FFmpegTestWindow::on_actionPlay_pause_triggered()\n{\n\tif(_rate)\n\t\t_rate = 0;\n\telse\n\t\t_rate = 1;\n}\n\nvoid FFmpegTestWindow::on_actionNext_frame_triggered()\n{\n\tthis->setFrame(++_currentFrame);\n}\n\nvoid FFmpegTestWindow::on_actionPrevious_frame_triggered()\n{\n\tthis->setFrame(--_currentFrame);\n}\n\nvoid FFmpegTestWindow::onTimeOut()\n{\n\t_currentFrame += _rate;\n\tthis->setFrame(_currentFrame);\n\tthis->update();\n}\n", "name": "tests/FFmpegTest/FFmpegTestWindow.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef FFMPEGTESTWINDOW_H\n#define FFMPEGTESTWINDOW_H\n\n#include <QMainWindow>\n#include <QImage>\n#include <QTimer>\n\nextern \"C\" {\n#ifndef INT64_C\n/** see http://code.google.com/p/ffmpegsource/issues/detail?id=11#c13 */\n#define INT64_C(c) (c ## LL)\n/** and http://code.google.com/p/ffmpegsource/issues/detail?id=11#c23 */\n#define UINT64_C(c) (c ## ULL)\n#endif\n\n#include <libavformat/avformat.h>\n#include <libavutil/avutil.h>\n#include <libavcodec/avcodec.h>\n#include <libswscale/swscale.h>\n}\n\nnamespace Ui {\nclass FFmpegTestWindow;\n}\n\nclass FFmpegTestWindow : public QMainWindow\n{\n\tQ_OBJECT\n\npublic:\n\texplicit FFmpegTestWindow(QWidget *parent = 0);\n\t~FFmpegTestWindow();\n\n\tbool openFile(QString fileName);\n\n\tbool setFrame(int frame);\n\nprotected:\n\tvoid paintEvent(QPaintEvent *);\n\tvoid resizeEvent(QResizeEvent *);\n\nprivate slots:\n\tvoid on_actionOpen_triggered();\n\n\tvoid on_actionPlay_pause_triggered();\n\n\tvoid on_actionNext_frame_triggered();\n\n\tvoid on_actionPrevious_frame_triggered();\n\n\tvoid onTimeOut();\n\nprivate:\n\tUi::FFmpegTestWindow *ui;\n\n\tAVFormatContext * _pFormatContext;\n\tAVStream *_videoStream;\n\tAVCodecContext * _pCodecContext;\n\tAVFrame * _pFrame;\n\tstruct SwsContext * _pSwsCtx;\n\tQImage * _image;\n\tuint8_t *_rgb;\n\n\tQTimer _timer;\n\tint _currentFrame;\n\tint _rate;\n};\n\n#endif // FFMPEGTESTWINDOW_H\n", "name": "tests/FFmpegTest/FFmpegTestWindow.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include \"FFmpegTestWindow.h\"\n#include <QApplication>\n\nint main(int argc, char *argv[])\n{\n\tQApplication a(argc, argv);\n\tFFmpegTestWindow w;\n\tw.show();\n\n\tif(argc > 1)\n\t\tw.openFile(argv[1]);\n\n\treturn a.exec();\n}\n", "name": "tests/FFmpegTest/main.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include \"AboutDialog.h\"\n#include \"ui_AboutDialog.h\"\n\nAboutDialog::AboutDialog(QWidget *parent) :\n\tQDialog(parent),\n\tui(new Ui::AboutDialog)\n{\n\tui->setupUi(this);\n\tQString version = APP_NAME;\n\tversion += \" v\";\n\tversion += APP_VERSION;\n\tui->label->setText(version);\n}\n\nAboutDialog::~AboutDialog()\n{\n\tdelete ui;\n}\n", "name": "tests/FormTest/AboutDialog.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef ABOUTDIALOG_H\n#define ABOUTDIALOG_H\n\n#include <QDialog>\n\nnamespace Ui {\nclass AboutDialog;\n}\n\nclass AboutDialog : public QDialog\n{\n\tQ_OBJECT\n\npublic:\n\texplicit AboutDialog(QWidget *parent = 0);\n\t~AboutDialog();\n\nprivate:\n\tUi::AboutDialog *ui;\n};\n\n#endif // ABOUTDIALOG_H\n", "name": "tests/FormTest/AboutDialog.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef FORMTESTSETTINGS_H\n#define FORMTESTSETTINGS_H\n\n#include \"PhTools/PhGenericSettings.h\"\n#include \"PhCommonUI/PhDocumentWindowSettings.h\"\n#include \"PhCommonUI/PhFeedbackSettings.h\"\n\nclass FormTestSettings : protected PhGenericSettings, public PhWindowSettings, public PhFeedbackSettings\n{\npublic:\n\t// PhWindowSettings\n\tPH_SETTING_BOOL(setFullScreen, fullScreen)\n\tPH_SETTING_BYTEARRAY(setWindowGeometry, windowGeometry)\n\n\t// PhFeedbackSettings\n\tQString settingsFileName() {\n\t\treturn _settings.fileName();\n\t}\n\tPH_SETTING_STRINGLIST(setEmailList, emailList)\n};\n\n#endif // FORMTESTSETTINGS_H\n", "name": "tests/FormTest/FormTestSettings.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include <QDesktopServices>\n#include <QUrl>\n#include <QFileDialog>\n#include <QPainter>\n#include <QMessageBox>\n#include <QScreen>\n#include <QTime>\n\n#include \"PhTools/PhDebug.h\"\n#include \"PhTools/PhPictureTools.h\"\n#include \"PhCommonUI/PhFeedbackDialog.h\"\n\n#include \"FormTestWindow.h\"\n#include \"ui_FormTestWindow.h\"\n\nFormTestWindow::FormTestWindow(FormTestSettings *settings) :\n\tPhWindow(settings),\n\tui(new Ui::FormTestWindow),\n\t_settings(settings),\n\t_image(NULL),\n\t_rgb(NULL)\n{\n\tui->setupUi(this);\n\n\tconnect(ui->actionFull_screen, SIGNAL(triggered()), this, SLOT(toggleFullScreen()));\n\n\tQScreen *screen = QGuiApplication::primaryScreen();\n\tif (screen)\n\t\tui->labelFrequency->setText(QString::number(screen->refreshRate()) + \"hz\");\n}\n\nFormTestWindow::~FormTestWindow()\n{\n\tdelete ui;\n}\n\nQAction *FormTestWindow::fullScreenAction()\n{\n\treturn ui->actionFull_screen;\n}\n\nvoid FormTestWindow::on_actionAbout_triggered()\n{\n\t_about.exec();\n}\n\nvoid FormTestWindow::on_actionDocumentation_triggered()\n{\n\tif(QDesktopServices::openUrl(QUrl(\"http://www.doublage.org\", QUrl::TolerantMode)))\n\t\tPHDEBUG <<\"openned url correctly\";\n}\n\nvoid FormTestWindow::on_pushButton_clicked()\n{\n\tPhFeedbackDialog dlg(_settings);\n\tdlg.exec();\n}\n", "name": "tests/FormTest/FormTestWindow.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef MAINWINDOW_H\n#define MAINWINDOW_H\n\n#include <QDialog>\n#include <QGraphicsScene>\n\n#include \"AboutDialog.h\"\n\n#include \"PhCommonUI/PhWindow.h\"\n\n#include \"FormTestSettings.h\"\n\nnamespace Ui {\nclass FormTestWindow;\n}\n\nclass GoTo;\nclass AboutDialog;\n\nclass FormTestWindow : public PhWindow\n{\n\tQ_OBJECT\n\npublic:\n\texplicit FormTestWindow(FormTestSettings *settings);\n\t~FormTestWindow();\n\nprotected:\n\tQAction *fullScreenAction();\n\nprivate slots:\n\tvoid on_actionAbout_triggered();\n\n\tvoid on_actionDocumentation_triggered();\n\n\tvoid on_pushButton_clicked();\n\nprivate:\n\tUi::FormTestWindow *ui;\n\tAboutDialog _about;\n\tFormTestSettings *_settings;\n\tQImage *_image;\n\tunsigned char * _rgb;\n};\n\n#endif // MAINWINDOW_H\n", "name": "tests/FormTest/FormTestWindow.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include <QApplication>\n#include <QFile>\n\n#include \"PhTools/PhDebug.h\"\n\n#include \"FormTestWindow.h\"\n\n/**\n * @brief The application main entry point\n * @param argc Command line argument count\n * @param argv Command line argument list\n * @return 0 if the application works well.\n */\nint main(int argc, char *argv[])\n{\n\tFormTestSettings settings;\n\tPHDEBUG << ORG_NAME << APP_NAME << APP_VERSION;\n\tQApplication a(argc, argv);\n\ta.setApplicationVersion(APP_VERSION);\n\ta.setOrganizationName(ORG_NAME);\n\ta.setOrganizationDomain(ORG_NAME);\n\n\tFormTestWindow window(&settings);\n\twindow.show();\n\n\treturn a.exec();\n}\n", "name": "tests/FormTest/main.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef GRAPHICSTRIPSYNCTESTSETTINGS_H\n#define GRAPHICSTRIPSYNCTESTSETTINGS_H\n\n#include <QDir>\n\n#include \"PhTools/PhGenericSettings.h\"\n#include \"PhGraphicStrip/PhGraphicStripSettings.h\"\n#include \"PhSync/PhSyncSettings.h\"\n#include \"PhCommonUI/PhDocumentWindowSettings.h\"\n\nclass GraphicStripSyncTestSettings : protected PhGenericSettings,\n\tpublic PhGraphicStripSettings,\n\tpublic PhSyncSettings,\n\tpublic PhDocumentWindowSettings\n{\npublic:\n\tPH_SETTING_INT(setScreenDelay, screenDelay)\n\n\t// PhGraphicSettings\n\tPH_SETTING_BOOL(setDisplayInfo, displayInfo)\n\tPH_SETTING_BOOL(setResetInfo, resetInfo)\n\n\t// PhGraphicStripSettings :\n\tPH_SETTING_FLOAT2(setStripHeight, stripHeight, 1)\n\tPH_SETTING_INT2(setHorizontalTimePerPixel, horizontalTimePerPixel, 80)\n\tPH_SETTING_INT2(setVerticalTimePerPixel, verticalTimePerPixel, 1000)\n\tPH_SETTING_STRING(setTextFontFile, textFontFile)\n\tPH_SETTING_INT2(setTextBoldness, textBoldness, 2)\n\tPH_SETTING_BOOL(setStripTestMode, stripTestMode)\n\tPH_SETTING_BOOL2(setDisplayNextText, displayNextText, true)\n\tPH_SETTING_BOOL(setInvertColor, invertColor)\n\tPH_SETTING_BOOL(setDisplayRuler, displayRuler)\n\tPH_SETTING_INT(setRulerTimeIn, rulerTimeIn)\n\tPH_SETTING_INT2(setTimeBetweenRuler, timeBetweenRuler, 24000)\n\n\t// PhSyncSettings:\n\tPH_SETTING_BOOL2(setVideoSyncUp, videoSyncUp, true)\n\tPH_SETTING_UCHAR2(setSonyDevice1, sonyDevice1, 0xF0)\n\tPH_SETTING_UCHAR2(setSonyDevice2, sonyDevice2, 0xC0)\n\tPH_SETTING_FLOAT2(setSonyFastRate, sonyFastRate, 3)\n\tPH_SETTING_STRING2(setSonySlavePortSuffix, sonySlavePortSuffix, \"A\")\n\tPH_SETTING_STRING2(setSonyMasterPortSuffix, sonyMasterPortSuffix, \"B\")\n\n\t// PhWindowSettings\n\tPH_SETTING_BOOL(setFullScreen, fullScreen)\n\tPH_SETTING_BYTEARRAY(setWindowGeometry, windowGeometry)\n\n\t// PhDocumentWindowSettings\n\tPH_SETTING_STRING(setCurrentDocument, currentDocument)\n\tPH_SETTING_STRING2(setLastDocumentFolder, lastDocumentFolder, QDir::homePath())\n\tPH_SETTING_STRINGLIST(setRecentDocumentList, recentDocumentList)\n\tPH_SETTING_INT2(setMaxRecentDocument, maxRecentDocument, 10)\n\tPH_SETTING_BOOL2(setAutoReload, autoReload, true)\n\n\t// Others\n\tPH_SETTING_BOOL(setUseQuarterFrame, useQuarterFrame)\n};\n\n#endif // GRAPHICSTRIPSYNCTESTSETTINGS_H\n", "name": "tests/GraphicStripSyncTest/GraphicStripSyncTestSettings.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include <QMessageBox>\n#include <QFileDialog>\n\n#include \"PhTools/PhDebug.h\"\n#include \"PhCommonUI/PhTimeCodeDialog.h\"\n#include \"PreferencesDialog.h\"\n\n#include \"GraphicStripSyncTestWindow.h\"\n#include \"ui_GraphicStripSyncTestWindow.h\"\n\nGraphicStripSyncTestWindow::GraphicStripSyncTestWindow(GraphicStripSyncTestSettings *settings) :\n\tPhDocumentWindow(settings),\n\tui(new Ui::GraphicStripSyncTestWindow),\n\t_settings(settings),\n\t_sonySlave(PhTimeCodeType25, _settings)\n{\n\tui->setupUi(this);\n\t_strip = ui->stripView->strip();\n\tui->stripView->setStripSettings(_settings);\n\t_doc = _strip->doc();\n\t_clock = _strip->clock();\n\t_clockSynchroniser.setStripClock(_clock);\n\n\tconnect(ui->actionOpen, SIGNAL(triggered()), this, SLOT(onOpenFile()));\n\n\tconnect(_clock, SIGNAL(frameChanged(PhFrame, PhTimeCodeType)), this, SLOT(onFrameChanged(PhFrame, PhTimeCodeType)));\n\tconnect(_clock, SIGNAL(rateChanged(PhRate)), this, SLOT(onRateChanged(PhRate)));\n\n\tif(_sonySlave.open()) {\n\t\t_clock = _sonySlave.clock();\n\t\t_clockSynchroniser.setSonyClock(_clock);\n\t\tconnect(ui->stripView, SIGNAL(beforePaint(int)), &_sonySlave, SLOT(checkVideoSync(int)));\n\t}\n\telse\n\t\tQMessageBox::critical(this, \"Sony Test\", \"Unable to connect to Sony slave\");\n}\n\nGraphicStripSyncTestWindow::~GraphicStripSyncTestWindow()\n{\n\tdelete ui;\n}\n\nbool GraphicStripSyncTestWindow::openDocument(QString fileName)\n{\n\tPHDEBUG << \"openFile : \" << fileName;\n\tif(QFile::exists(fileName)) {\n\t\tif(_doc->openStripFile(fileName)) {\n\t\t\t_clock->setTimeCodeType(_doc->timeCodeType());\n\t\t\t_clock->setTime(_doc->lastTime());\n\t\t\tsetCurrentDocument(fileName);\n\t\t}\n\t}\n}\n\nQMenu *GraphicStripSyncTestWindow::recentDocumentMenu()\n{\n\treturn ui->menuOpen_recent;\n}\n\nvoid GraphicStripSyncTestWindow::onOpenFile()\n{\n\tQFileDialog dlg(this, \"Open...\", \"\", \"Rythmo files (*.detx)\");\n\tif(dlg.exec()) {\n\t\tQString fileName = dlg.selectedFiles()[0];\n\t\topenDocument(fileName);\n\t}\n}\n\nvoid GraphicStripSyncTestWindow::onFrameChanged(PhFrame frame, PhTimeCodeType tcType)\n{\n\tQString message = QString(\"%1 - x%2\").arg(PhTimeCode::stringFromFrame(frame, tcType), QString::number(_clock->rate()));\n\tui->statusbar->showMessage(message);\n}\n\nvoid GraphicStripSyncTestWindow::onRateChanged(PhRate rate)\n{\n\tQString message = QString(\"%1 - x%2\").arg(PhTimeCode::stringFromFrame(_clock->frame(), _clock->timeCodeType()), QString::number(rate));\n\tui->statusbar->showMessage(message);\n}\n\nvoid GraphicStripSyncTestWindow::on_actionPlay_pause_triggered()\n{\n\tif(_clock->rate() == 0.0)\n\t\t_clock->setRate(1.0);\n\telse\n\t\t_clock->setRate(0.0);\n}\n\nvoid GraphicStripSyncTestWindow::on_actionPlay_backward_triggered()\n{\n\t_clock->setRate(-1.0);\n}\n\nvoid GraphicStripSyncTestWindow::on_actionStep_forward_triggered()\n{\n\t_clock->setRate(0.0);\n\t_clock->setFrame(_clock->frame() + 1);\n}\n\nvoid GraphicStripSyncTestWindow::on_actionStep_backward_triggered()\n{\n\t_clock->setRate(0.0);\n\t_clock->setFrame(_clock->frame() - 1);\n}\n\nvoid GraphicStripSyncTestWindow::on_actionStep_time_forward_triggered()\n{\n\t_clock->setRate(0.0);\n\t_clock->setTime(_clock->time() + 1);\n}\n\nvoid GraphicStripSyncTestWindow::on_actionStep_time_backward_triggered()\n{\n\t_clock->setRate(0.0);\n\t_clock->setTime(_clock->time() - 1);\n}\n\nvoid GraphicStripSyncTestWindow::on_action_3_triggered()\n{\n\t_clock->setRate(-3.0);\n}\n\nvoid GraphicStripSyncTestWindow::on_action_1_triggered()\n{\n\t_clock->setRate(-1.0);\n}\n\nvoid GraphicStripSyncTestWindow::on_action_0_5_triggered()\n{\n\t_clock->setRate(-0.5);\n}\n\nvoid GraphicStripSyncTestWindow::on_action0_triggered()\n{\n\t_clock->setRate(0.0);\n}\n\nvoid GraphicStripSyncTestWindow::on_action0_5_triggered()\n{\n\t_clock->setRate(0.5);\n}\n\nvoid GraphicStripSyncTestWindow::on_action1_triggered()\n{\n\t_clock->setRate(1.0);\n}\n\nvoid GraphicStripSyncTestWindow::on_action3_triggered()\n{\n\t_clock->setRate(3.0);\n}\n\nvoid GraphicStripSyncTestWindow::on_actionGo_To_triggered()\n{\n\tPhTimeCodeDialog dlg(_clock->timeCodeType(), _clock->frame());\n\tif(dlg.exec() == QDialog::Accepted)\n\t\t_clock->setFrame(dlg.frame());\n\n}\n\nvoid GraphicStripSyncTestWindow::on_actionPreferences_triggered()\n{\n\tPreferencesDialog dlg(_settings);\n\tif(dlg.exec() == QDialog::Accepted)\n\t\tPHDEBUG << \"accepted\";\n\telse\n\t\tPHDEBUG << \"canceled\";\n}\n", "name": "tests/GraphicStripSyncTest/GraphicStripSyncTestWindow.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef MAINWINDOW_H\n#define MAINWINDOW_H\n\n#include \"PhGraphicStrip/PhGraphicStrip.h\"\n#include \"PhSync/PhSonySlaveController.h\"\n#include \"PhCommonUI/PhDocumentWindow.h\"\n\n#include \"GraphicStripSyncTestSettings.h\"\n#include \"SonyStripSynchronizer.h\"\n\nnamespace Ui {\nclass GraphicStripSyncTestWindow;\n}\n\nclass GraphicStripSyncTestWindow : public PhDocumentWindow\n{\n\tQ_OBJECT\n\npublic:\n\texplicit GraphicStripSyncTestWindow(GraphicStripSyncTestSettings *settings);\n\t~GraphicStripSyncTestWindow();\n\n\tbool openDocument(QString fileName);\n\nprotected:\n\tQMenu *recentDocumentMenu();\n\tQAction* fullScreenAction() {\n\t\treturn NULL;\n\t}\n\nprivate slots:\n\tvoid onOpenFile();\n\tvoid onFrameChanged(PhFrame frame, PhTimeCodeType tcType);\n\tvoid onRateChanged(PhRate rate);\n\n\tvoid on_actionPlay_pause_triggered();\n\n\tvoid on_actionPlay_backward_triggered();\n\n\tvoid on_actionStep_forward_triggered();\n\n\tvoid on_actionStep_backward_triggered();\n\n\tvoid on_actionStep_time_forward_triggered();\n\n\tvoid on_actionStep_time_backward_triggered();\n\n\tvoid on_action_3_triggered();\n\n\tvoid on_action_1_triggered();\n\n\tvoid on_action_0_5_triggered();\n\n\tvoid on_action0_triggered();\n\n\tvoid on_action0_5_triggered();\n\n\tvoid on_action1_triggered();\n\n\tvoid on_action3_triggered();\n\n\tvoid on_actionGo_To_triggered();\n\n\tvoid on_actionPreferences_triggered();\n\nprivate:\n\tUi::GraphicStripSyncTestWindow *ui;\n\tPhGraphicStrip *_strip;\n\tPhStripDoc *_doc;\n\tPhClock *_clock;\n\tGraphicStripSyncTestSettings *_settings;\n\tPhSonySlaveController _sonySlave;\n\tSonyStripSynchronizer _clockSynchroniser;\n};\n\n#endif // MAINWINDOW_H\n", "name": "tests/GraphicStripSyncTest/GraphicStripSyncTestWindow.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * Copyright (C) 2012-2014 Phonations\n * License: http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n\n#include <QApplication>\n#include <QDebug>\n\n#include \"PhStrip/PhStripDoc.h\"\n\n#include \"GraphicStripSyncTestWindow.h\"\n\n/**\n * @brief The application main entry point\n * @param argc Command line argument count\n * @param argv Command line argument list\n * @return 0 if the application works well.\n */\nint main(int argc, char *argv[])\n{\n\tQApplication a(argc, argv);\n\tGraphicStripSyncTestSettings settings;\n\tGraphicStripSyncTestWindow w(&settings);\n\tw.processArg(argc, argv);\n\tw.show();\n\n\treturn a.exec();\n\n}\n", "name": "tests/GraphicStripSyncTest/main.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include \"PreferencesDialog.h\"\n#include \"ui_PreferencesDialog.h\"\n\nPreferencesDialog::PreferencesDialog(GraphicStripSyncTestSettings *settings, QWidget *parent) :\n\tQDialog(parent),\n\tui(new Ui::PreferencesDialog),\n\t_settings(settings)\n{\n\tui->setupUi(this);\n\n\tif(_settings->useQuarterFrame()) {\n\t\tui->useQuarterFrameRadioButton->setChecked(true);\n\t\tui->delaySpinBox->setValue(_settings->screenDelay() / 20);\n\t}\n\telse\n\t\tui->delaySpinBox->setValue(_settings->screenDelay());\n\n\n\tui->delaySpinBox->setFocus();\n}\n\nPreferencesDialog::~PreferencesDialog()\n{\n\tdelete ui;\n}\n\nvoid PreferencesDialog::on_delaySpinBox_valueChanged(int delay)\n{\n\tif(_settings->useQuarterFrame())\n\t\t_settings->setScreenDelay(delay * 20);\n\telse\n\t\t_settings->setScreenDelay(delay);\n}\n\nvoid PreferencesDialog::on_useQuarterFrameRadioButton_toggled(bool checked)\n{\n\t_settings->setUseQuarterFrame(checked);\n\tif(checked)\n\t\tui->delaySpinBox->setValue(_settings->screenDelay() / 20);\n\telse\n\t\tui->delaySpinBox->setValue(_settings->screenDelay());\n\tui->delaySpinBox->selectAll();\n}\n", "name": "tests/GraphicStripSyncTest/PreferencesDialog.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef PREFERENCESDIALOG_H\n#define PREFERENCESDIALOG_H\n\n#include <QDialog>\n\n#include \"GraphicStripSyncTestSettings.h\"\n\nnamespace Ui {\nclass PreferencesDialog;\n}\n\nclass PreferencesDialog : public QDialog\n{\n\tQ_OBJECT\n\npublic:\n\texplicit PreferencesDialog(GraphicStripSyncTestSettings *settings, QWidget *parent = 0);\n\t~PreferencesDialog();\n\nprivate slots:\n\tvoid on_delaySpinBox_valueChanged(int delay);\n\n\tvoid on_useQuarterFrameRadioButton_toggled(bool checked);\n\nprivate:\n\tUi::PreferencesDialog *ui;\n\tGraphicStripSyncTestSettings *_settings;\n};\n\n#endif // PREFERENCESDIALOG_H\n", "name": "tests/GraphicStripSyncTest/PreferencesDialog.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include \"SonyStripSynchronizer.h\"\n#include \"PhTools/PhDebug.h\"\n\nSonyStripSynchronizer::SonyStripSynchronizer()\n{\n}\n\nvoid SonyStripSynchronizer::setSonyClock(PhClock *clock)\n{\n\t_sonyClock = clock;\n\tconnect(_sonyClock, SIGNAL(frameChanged(PhFrame, PhTimeCodeType)), this, SLOT(onSonyFrameChanged(PhFrame, PhTimeCodeType)));\n\tconnect(_sonyClock, SIGNAL(rateChanged(PhRate)), this, SLOT(onSonyRateChanged(PhRate)));\n}\n\nvoid SonyStripSynchronizer::setStripClock(PhClock *clock)\n{\n\t_stripClock = clock;\n\tconnect(_stripClock, SIGNAL(frameChanged(PhFrame, PhTimeCodeType)), this, SLOT(onStripFrameChanged(PhFrame, PhTimeCodeType)));\n\tconnect(_stripClock, SIGNAL(rateChanged(PhRate)), this, SLOT(onStripRateChanged(PhRate)));\n}\n\nvoid SonyStripSynchronizer::onSonyFrameChanged(PhFrame frame, PhTimeCodeType tcType)\n{\n\tif(qAbs(_stripClock->frame() - frame) > 10) {\n\t\tPHDEBUG << \"error :\" << frame - _stripClock->frame();\n\t\t_settingStripFrame = true;\n\t\t_stripClock->setFrame(frame);\n\t\t_settingStripFrame = false;\n\n\t}\n}\n\nvoid SonyStripSynchronizer::onSonyRateChanged(PhRate rate)\n{\n\t_stripClock->setRate(rate);\n}\n\nvoid SonyStripSynchronizer::onStripFrameChanged(PhFrame frame, PhTimeCodeType tcType)\n{\n\tif(!_settingStripFrame) {\n\t\tif(qAbs(_sonyClock->frame() - frame) > 1) {\n\t\t\tPHDEBUG << \"error :\" << _sonyClock->frame() - frame;\n\t#warning TODO handle frame difference error\n\t\t\t_settingSonyFrame = true;\n\t\t\t_sonyClock->setFrame(frame);\n\t\t\t_settingSonyFrame = false;\n\t\t}\n\t}\n}\n\nvoid SonyStripSynchronizer::onStripRateChanged(PhRate rate)\n{\n\tif(!_settingStripRate) {\n\t\t_settingSonyRate = true;\n\t\tif(_sonyClock)\n\t\t\t_sonyClock->setRate(rate);\n\t\t_settingSonyRate = false;\n\t}\n}\n", "name": "tests/GraphicStripSyncTest/SonyStripSynchronizer.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef SONYSTRIPSYNCHRONIZER_H\n#define SONYSTRIPSYNCHRONIZER_H\n\n#include <QObject>\n\n#include \"PhTools/PhClock.h\"\n\nclass SonyStripSynchronizer : public QObject\n{\n\tQ_OBJECT\npublic:\n\tSonyStripSynchronizer();\n\n\tvoid setSonyClock(PhClock *clock);\n\tvoid setStripClock(PhClock *clock);\n\nprivate slots:\n\tvoid onSonyFrameChanged(PhFrame frame, PhTimeCodeType tcType);\n\tvoid onSonyRateChanged(PhRate rate);\n\tvoid onStripFrameChanged(PhFrame frame, PhTimeCodeType tcType);\n\tvoid onStripRateChanged(PhRate rate);\nprivate:\n\tPhClock * _sonyClock;\n\tPhClock * _stripClock;\n\tbool _settingStripFrame;\n\tbool _settingSonyFrame;\n\tbool _settingStripRate;\n\tbool _settingSonyRate;\n\n};\n\n#endif // SONYSTRIPSYNCHRONIZER_H\n", "name": "tests/GraphicStripSyncTest/SonyStripSynchronizer.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * Copyright (C) 2012-2014 Phonations\n * License: http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#include \"GenerateDialog.h\"\n#include \"ui_GenerateDialog.h\"\n#include \"PhTools/PhTimeCode.h\"\n#include \"PhTools/PhDebug.h\"\n\nGenerateDialog::GenerateDialog(GraphicStripTestSettings *settings, PhStripDoc * doc, QWidget *parent) :\n\tQDialog(parent),\n\tui(new Ui::GenerateDialog),\n\t_settings(settings)\n{\n\tthis->_doc = doc;\n\tui->setupUi(this);\n\tui->lineEditText->setText(_settings->textContent());\n\tui->lineEditTimeCode->setFrame(_settings->startTime() / PhTimeCode::timePerFrame(_doc->timeCodeType()), _doc->timeCodeType());\n\tui->spinBoxNbPeople->setValue(_settings->peopleNumber());\n\tui->spaceBetweenTextSpinBox->setValue(_settings->spaceBetweenText());\n\tui->spinBoxNbText->setValue(_settings->textNumber());\n\tui->spinBoxNbTrack->setValue(_settings->trackNumber());\n\tconnect(ui->lineEditText, SIGNAL(textChanged(QString)), this, SLOT(onTextChanged()));\n\tconnect(ui->spinBoxNbText, SIGNAL(valueChanged(int)), this, SLOT(onTextChanged()));\n\tconnect(ui->buttonBox, SIGNAL(accepted()), this, SLOT(onAccept()));\n\n\t// To update the time value\n\tonTextChanged();\n\n}\n\nGenerateDialog::~GenerateDialog()\n{\n\tdelete ui;\n}\n\nPhTime GenerateDialog::getTC()\n{\n\treturn PhTimeCode::frameFromString(this->ui->lineEditTimeCode->text(), PhTimeCodeType25);\n}\n\nbool GenerateDialog::getCheckBoxState()\n{\n\treturn ui->checkBox->isChecked();\n}\n\n\nvoid GenerateDialog::onTextChanged()\n{\n\tfloat nbFrames = (this->ui->lineEditText->text().length() * 1.20588 + 1) * this->ui->spinBoxNbText->value();\n\n\tthis->ui->labelInfoDuration->setText(PhTimeCode::stringFromFrame(nbFrames, PhTimeCodeType25));\n}\n\nvoid GenerateDialog::onAccept()\n{\n\tint loopCount = this->ui->spinBoxNbLoop->value();\n\tint peopleCount = this->ui->spinBoxNbPeople->value();\n\tint textCount = this->ui->spinBoxNbText->value();\n\tPhTime spaceBetweenText = this->ui->spaceBetweenTextSpinBox->value();\n\tint trackCount = this->ui->spinBoxNbTrack->value();\n\tQString textContent = this->ui->lineEditText->text();\n\tPhTime timeIn = this->ui->lineEditTimeCode->frame() * PhTimeCode::timePerFrame(_doc->timeCodeType());\n\t_doc->generate(textContent, loopCount, peopleCount, spaceBetweenText, textCount, trackCount, timeIn);\n\t_settings->setStartTime(timeIn);\n\t_settings->setLoopNumber(loopCount);\n\t_settings->setPeopleNumber(peopleCount);\n\t_settings->setTextNumber(textCount);\n\t_settings->setSpaceBetweenText(spaceBetweenText);\n\t_settings->setTrackNumber(trackCount);\n\t_settings->setTextContent(textContent);\n\n\tQDialog::accept();\n}\n", "name": "tests/GraphicStripTest/GenerateDialog.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * Copyright (C) 2012-2014 Phonations\n * License: http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef GENERATEDIALOG_H\n#define GENERATEDIALOG_H\n\n#include <QDialog>\n\n#include \"PhStrip/PhStripDoc.h\"\n#include \"PhCommonUI/PhTimeCodeEdit.h\"\n\n#include \"GraphicStripTestSettings.h\"\n\nnamespace Ui {\nclass GenerateDialog;\n}\n\nclass GenerateDialog : public QDialog\n{\n\tQ_OBJECT\n\npublic:\n\texplicit GenerateDialog(GraphicStripTestSettings *settings, PhStripDoc * _doc, QWidget *parent = 0);\n\t~GenerateDialog();\n\tPhTime getTC();\n\tbool getCheckBoxState();\n\nprivate slots:\n\tvoid onTextChanged();\n\tvoid onAccept();\n\nprivate:\n\tUi::GenerateDialog *ui;\n\tPhStripDoc * _doc;\n\tGraphicStripTestSettings * _settings;\n};\n\n#endif // GENERATEDIALOG_H\n", "name": "tests/GraphicStripTest/GenerateDialog.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef GRAPHICSTRIPTESTSETTINGS_H\n#define GRAPHICSTRIPTESTSETTINGS_H\n\n#include \"PhTools/PhGenericSettings.h\"\n#include \"PhGraphicStrip/PhGraphicStripSettings.h\"\n#include \"PhCommonUI/PhDocumentWindowSettings.h\"\n\nclass GraphicStripTestSettings : PhGenericSettings,\n\tpublic PhGraphicStripSettings,\n\tpublic PhDocumentWindowSettings\n\n{\npublic:\n\tPH_SETTING_INT(setScreenDelay, screenDelay)\n\n\t// PhGraphicSettings\n\tPH_SETTING_BOOL(setDisplayInfo, displayInfo)\n\tPH_SETTING_BOOL(setResetInfo, resetInfo)\n\n\t// PhGraphicStripSettings :\n\tPH_SETTING_FLOAT2(setStripHeight, stripHeight, 0.25f)\n\tPH_SETTING_INT2(setHorizontalTimePerPixel, horizontalTimePerPixel, 80)\n\tPH_SETTING_INT2(setVerticalTimePerPixel, verticalTimePerPixel, 1000)\n\tPH_SETTING_STRING(setTextFontFile, textFontFile)\n\tPH_SETTING_INT2(setTextBoldness, textBoldness, 1)\n\tPH_SETTING_BOOL(setStripTestMode, stripTestMode)\n\tPH_SETTING_BOOL2(setDisplayNextText, displayNextText, true)\n\tPH_SETTING_BOOL(setInvertColor, invertColor)\n\tPH_SETTING_BOOL(setDisplayRuler, displayRuler)\n\tPH_SETTING_INT(setRulerTimeIn, rulerTimeIn)\n\tPH_SETTING_INT2(setTimeBetweenRuler, timeBetweenRuler, 48000)\n\n\t// PhDocumentWindowSettings\n\tPH_SETTING_STRING(setCurrentDocument, currentDocument)\n\tPH_SETTING_STRING2(setLastDocumentFolder, lastDocumentFolder, QDir::homePath())\n\tPH_SETTING_STRINGLIST(setRecentDocumentList, recentDocumentList)\n\tPH_SETTING_INT2(setMaxRecentDocument, maxRecentDocument, 10)\n\tPH_SETTING_BOOL2(setAutoReload, autoReload, true)\n\n\t// PhWindowSettings\n\tPH_SETTING_BOOL(setFullScreen, fullScreen)\n\tPH_SETTING_BYTEARRAY(setWindowGeometry, windowGeometry)\n\n\t// Other settings :\n\tPH_SETTING_BOOL(setGenerate, generate)\n\tPH_SETTING_INT2(setPeopleNumber, peopleNumber, 1)\n\tPH_SETTING_INT2(setLoopNumber, loopNumber, 1)\n\tPH_SETTING_INT2(setTextNumber, textNumber, 10)\n\tPH_SETTING_INT2(setSpaceBetweenText, spaceBetweenText, 24000)\n\tPH_SETTING_INT2(setTrackNumber, trackNumber, 4)\n\tPH_SETTING_STRING2(setTextContent, textContent, \"Per hoc minui studium suum existimans Paulus.\")\n\tPH_SETTING_INT2(setStartTime, startTime, 0)\n};\n\n#endif // GRAPHICSTRIPTESTSETTINGS_H\n", "name": "tests/GraphicStripTest/GraphicStripTestSettings.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include \"GraphicStripTestWindow.h\"\n#include \"ui_GraphicStripTestWindow.h\"\n\n#include <QFileDialog>\n#include <QFontDialog>\n#include <QFont>\n#include <QStandardPaths>\n\n#include \"PhTools/PhDebug.h\"\n#include \"PhCommonUI/PhTimeCodeDialog.h\"\n\nGraphicStripTestWindow::GraphicStripTestWindow(GraphicStripTestSettings * settings) :\n\tPhDocumentWindow(settings),\n\tui(new Ui::GraphicStripTestWindow),\n\t_settings(settings)\n{\n\tui->setupUi(this);\n\t_strip = ui->stripView->strip();\n\n\tui->stripView->setStripSettings(_settings);\n\n\t_doc = _strip->doc();\n\t_clock = _strip->clock();\n\tui->actionInvert_colors->setChecked(_settings->invertColor());\n\tui->actionRuler->setChecked(_settings->displayRuler());\n\n\tconnect(ui->actionOpen, SIGNAL(triggered()), this, SLOT(onOpenFile()));\n\tconnect(ui->actionGenerate, SIGNAL(triggered()), this, SLOT(onGenerate()));\n\n\tconnect(ui->actionFull_screen, SIGNAL(triggered()), this, SLOT(toggleFullScreen()));\n\n\tconnect(_clock, SIGNAL(frameChanged(PhFrame, PhTimeCodeType)), this, SLOT(onFrameChanged(PhFrame, PhTimeCodeType)));\n\tconnect(_clock, SIGNAL(rateChanged(PhRate)), this, SLOT(onRateChanged(PhRate)));\n\n\tif(_settings->generate())\n\t\t_doc->generate(_settings->textContent(),\n\t\t               _settings->loopNumber(),\n\t\t               _settings->peopleNumber(),\n\t\t               _settings->spaceBetweenText(),\n\t\t               _settings->textNumber(),\n\t\t               _settings->trackNumber(),\n\t\t               _settings->startTime());\n\n}\n\nGraphicStripTestWindow::~GraphicStripTestWindow()\n{\n\tdelete ui;\n}\n\nbool GraphicStripTestWindow::openDocument(QString fileName)\n{\n\tPHDEBUG << fileName;\n\tif(!_doc->openStripFile(fileName))\n\t\treturn false;\n\n\t_clock->setTimeCodeType(_doc->timeCodeType());\n\t_settings->setGenerate(false);\n\tsetCurrentDocument(fileName);\n\treturn true;\n}\n\nQMenu *GraphicStripTestWindow::recentDocumentMenu()\n{\n\treturn ui->menuOpen_recent;\n}\n\nQAction *GraphicStripTestWindow::fullScreenAction()\n{\n\treturn ui->actionFull_screen;\n}\n\nvoid GraphicStripTestWindow::onOpenFile()\n{\n\tQString fileName = QFileDialog::getOpenFileName(this, \"Open...\", _settings->lastDocumentFolder(), \"Rythmo files (*.strip *.detx)\");\n\tif(QFile::exists(fileName)) {\n\t\tif(!openDocument(fileName))\n\t\t\tQMessageBox::critical(this, \"Error\", \"Unable to open \" + fileName);\n\t}\n}\n\nvoid GraphicStripTestWindow::onGenerate()\n{\n\tGenerateDialog dlgGen(_settings, _doc);\n\tif (dlgGen.exec()) {\n\n\t\tif(dlgGen.getCheckBoxState()) {\n\t\t\t_clock->setTime(0);\n\t\t\t_settings->setGenerate(true);\n\t\t\t_doc->reset();\n\t\t\t_doc->addPeople(new PhPeople(\"A people\"));\n\t\t\t_doc->addPeople(new PhPeople(\"A second people\", \"red\"));\n\n\t\t\t_doc->addObject(new PhStripText(0, _doc->peoples().first(), 10000, 1, \"Hello\"));\n\t\t\t_doc->addObject(new PhStripCut(PhStripCut::CrossFade, 5400));\n\t\t\t_doc->addObject(new PhStripDetect(PhStripDetect::Off, 0, _doc->peoples().first(), 10000, 1));\n\t\t\t_doc->addObject(new PhStripLoop(3, 22000));\n\t\t\t_doc->addObject(new PhStripText(10000, _doc->peoples().last(), 15000, 2, \"Hi !\"));\n\t\t\t_doc->addObject(new PhStripDetect(PhStripDetect::SemiOff, 10000, _doc->peoples().last(), 15000, 2));\n\t\t}\n\t\telse {\n\t\t\t_clock->setTime(_doc->lastTime());\n\t\t\t_settings->setGenerate(true);\n\t\t\tsetCurrentDocument(\"\");\n\t\t}\n\t}\n\n}\n\nvoid GraphicStripTestWindow::onFrameChanged(PhFrame frame, PhTimeCodeType tcType)\n{\n\tQString message = QString(\"%1 - x%2\").arg(PhTimeCode::stringFromFrame(frame, tcType), QString::number(_clock->rate()));\n\tui->statusbar->showMessage(message);\n}\n\nvoid GraphicStripTestWindow::onRateChanged(PhRate rate)\n{\n\tQString message = QString(\"%1 - x%2\").arg(PhTimeCode::stringFromFrame(_clock->frame(), _clock->timeCodeType()), QString::number(rate));\n\tui->statusbar->showMessage(message);\n}\n\nvoid GraphicStripTestWindow::on_actionPlay_pause_triggered()\n{\n\tif(_clock->rate() == 0.0)\n\t\t_clock->setRate(1.0);\n\telse\n\t\t_clock->setRate(0.0);\n}\n\nvoid GraphicStripTestWindow::on_actionPlay_backward_triggered()\n{\n\t_clock->setRate(-1.0);\n}\n\nvoid GraphicStripTestWindow::on_actionStep_forward_triggered()\n{\n\t_clock->setRate(0.0);\n\t_clock->setFrame(_clock->frame() + 1);\n}\n\nvoid GraphicStripTestWindow::on_actionStep_backward_triggered()\n{\n\t_clock->setRate(0.0);\n\t_clock->setFrame(_clock->frame() - 1);\n}\n\nvoid GraphicStripTestWindow::on_actionStep_time_forward_triggered()\n{\n\t_clock->setRate(0.0);\n\t_clock->setTime(_clock->time() + 1);\n}\n\nvoid GraphicStripTestWindow::on_actionStep_time_backward_triggered()\n{\n\t_clock->setRate(0.0);\n\t_clock->setTime(_clock->time() - 1);\n}\n\nvoid GraphicStripTestWindow::on_action_3_triggered()\n{\n\t_clock->setRate(-3.0);\n}\n\nvoid GraphicStripTestWindow::on_action_1_triggered()\n{\n\t_clock->setRate(-1.0);\n}\n\nvoid GraphicStripTestWindow::on_action_0_5_triggered()\n{\n\t_clock->setRate(-0.5);\n}\n\nvoid GraphicStripTestWindow::on_action0_triggered()\n{\n\t_clock->setRate(0.0);\n}\n\nvoid GraphicStripTestWindow::on_action0_5_triggered()\n{\n\t_clock->setRate(0.5);\n}\n\nvoid GraphicStripTestWindow::on_action1_triggered()\n{\n\t_clock->setRate(1.0);\n}\n\nvoid GraphicStripTestWindow::on_action3_triggered()\n{\n\t_clock->setRate(3.0);\n}\n\nvoid GraphicStripTestWindow::on_actionGo_to_triggered()\n{\n\tPhTimeCodeDialog dlg(_clock->timeCodeType(), _clock->frame());\n\tif(dlg.exec() == QDialog::Accepted)\n\t\t_clock->setFrame(dlg.frame());\n}\n\nvoid GraphicStripTestWindow::on_actionPrevious_Element_triggered()\n{\n\tPhTime time = _doc->previousElementTime(_clock->time());\n\tif(time > PHTIMEMIN)\n\t\t_clock->setTime(time);\n}\n\nvoid GraphicStripTestWindow::on_actionNext_Element_triggered()\n{\n\tPhTime time = _doc->nextElementTime(_clock->time());\n\tif(time < PHTIMEMAX)\n\t\t_clock->setTime(time);\n}\n\nvoid GraphicStripTestWindow::on_actionStrip_Properties_triggered()\n{\n\tdlg = new StripPropertiesDialog(_doc, this);\n\tdlg->show();\n}\n\nvoid GraphicStripTestWindow::on_actionInvert_colors_triggered(bool checked)\n{\n\t_settings->setInvertColor(checked);\n}\n\n\nvoid GraphicStripTestWindow::on_actionRuler_triggered(bool checked)\n{\n\t_settings->setDisplayRuler(checked);\n\tif(checked && _settings->rulerTimeIn() == 0)\n\t\ton_actionChange_ruler_timestamp_triggered();\n}\n\nvoid GraphicStripTestWindow::on_actionChange_ruler_timestamp_triggered()\n{\n\tPhTimeCodeType tcType = _doc->timeCodeType();\n\tPhTimeCodeDialog dlg(tcType, _settings->rulerTimeIn() / PhTimeCode::timePerFrame(tcType), this);\n\tif(dlg.exec())\n\t\t_settings->setRulerTimeIn(dlg.frame() * PhTimeCode::timePerFrame(tcType));\n}\n", "name": "tests/GraphicStripTest/GraphicStripTestWindow.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef MAINWINDOW_H\n#define MAINWINDOW_H\n\n#include <QMessageBox>\n\n#include \"PhGraphicStrip/PhGraphicStrip.h\"\n#include \"PhCommonUI/PhDocumentWindow.h\"\n\n#include \"StripPropertiesDialog.h\"\n#include \"GenerateDialog.h\"\n#include \"GraphicStripTestSettings.h\"\n\nnamespace Ui {\nclass GraphicStripTestWindow;\n}\n\nclass GraphicStripTestWindow : public PhDocumentWindow\n{\n\tQ_OBJECT\n\npublic:\n\texplicit GraphicStripTestWindow(GraphicStripTestSettings *settings);\n\t~GraphicStripTestWindow();\n\n\tbool openDocument(QString fileName);\n\nprotected:\n\tQMenu *recentDocumentMenu();\n\tQAction *fullScreenAction();\n\nprivate slots:\n\tvoid onOpenFile();\n\tvoid onGenerate();\n\tvoid onFrameChanged(PhFrame frame, PhTimeCodeType tcType);\n\tvoid onRateChanged(PhRate rate);\n\n\tvoid on_actionPlay_pause_triggered();\n\n\tvoid on_actionPlay_backward_triggered();\n\n\tvoid on_actionStep_forward_triggered();\n\n\tvoid on_actionStep_backward_triggered();\n\n\tvoid on_actionStep_time_forward_triggered();\n\n\tvoid on_actionStep_time_backward_triggered();\n\n\tvoid on_actionPrevious_Element_triggered();\n\n\tvoid on_actionNext_Element_triggered();\n\n\tvoid on_action_3_triggered();\n\n\tvoid on_action_1_triggered();\n\n\tvoid on_action_0_5_triggered();\n\n\tvoid on_action0_triggered();\n\n\tvoid on_action0_5_triggered();\n\n\tvoid on_action1_triggered();\n\n\tvoid on_action3_triggered();\n\n\tvoid on_actionGo_to_triggered();\n\n\tvoid on_actionStrip_Properties_triggered();\n\n\tvoid on_actionInvert_colors_triggered(bool checked);\n\n\tvoid on_actionRuler_triggered(bool checked);\n\n\tvoid on_actionChange_ruler_timestamp_triggered();\n\nprivate:\n\tUi::GraphicStripTestWindow *ui;\n\tGraphicStripTestSettings *_settings;\n\tPhGraphicStrip *_strip;\n\tPhStripDoc *_doc;\n\tPhClock *_clock;\n\tStripPropertiesDialog *dlg;\n};\n\n#endif // MAINWINDOW_H\n", "name": "tests/GraphicStripTest/GraphicStripTestWindow.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * Copyright (C) 2012-2014 Phonations\n * License: http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n\n#include <QApplication>\n\n#include \"PhStrip/PhStripDoc.h\"\n#include \"PhTools/PhDebug.h\"\n\n#include \"GraphicStripTestWindow.h\"\n\n/**\n * @brief The application main entry point\n * @param argc Command line argument count\n * @param argv Command line argument list\n * @return 0 if the application works well.\n */\nint main(int argc, char *argv[])\n{\n\tQApplication a(argc, argv);\n\tGraphicStripTestSettings settings;\n\tGraphicStripTestWindow w(&settings);\n\tw.processArg(argc, argv);\n\tw.show();\n\n\treturn a.exec();\n}\n", "name": "tests/GraphicStripTest/main.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include \"StripPropertiesDialog.h\"\n#include \"ui_StripPropertiesDialog.h\"\n\nStripPropertiesDialog::StripPropertiesDialog(PhStripDoc * doc, QWidget *parent) :\n\tQDialog(parent),\n\tui(new Ui::StripPropertiesDialog)\n{\n\tui->setupUi(this);\n\n\tQString title = doc->title();\n\n\tPhFrame Fps = PhTimeCode::getFps(doc->timeCodeType());\n\tQString ips = QString::number(Fps);\n\n\tQString filePath = doc->filePath();\n\n\tQString videoPath = doc->videoFilePath();\n\n\tui->titleContentLabel->setText(title);\n\tui->videoPathContentLabel->setText(videoPath);\n\tui->pathContentLabel->setText(filePath);\n\tui->fpsContentLabel->setText(ips);\n}\n\nStripPropertiesDialog::~StripPropertiesDialog()\n{\n\tdelete ui;\n}\n", "name": "tests/GraphicStripTest/StripPropertiesDialog.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef STRIPPROPERTIESDIALOG_H\n#define STRIPPROPERTIESDIALOG_H\n\n#include <QDialog>\n#include \"PhStrip/PhStripDoc.h\"\n\nnamespace Ui {\nclass StripPropertiesDialog;\n}\n\nclass StripPropertiesDialog : public QDialog\n{\n\tQ_OBJECT\n\npublic:\n\texplicit StripPropertiesDialog(PhStripDoc * doc, QWidget *parent = 0);\n\t~StripPropertiesDialog();\n\nprivate:\n\tUi::StripPropertiesDialog *ui;\n};\n\n#endif // STRIPPROPERTIESDIALOG_H\n", "name": "tests/GraphicStripTest/StripPropertiesDialog.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include \"GraphicSyncTestView.h\"\n#include <QtGlobal>\n\nGraphicSyncTestView::GraphicSyncTestView(QWidget *parent) :\n\tPhGraphicView(parent),\n\ttext(&font, \"waiting\")\n{\n}\n\nvoid GraphicSyncTestView::setText(QString content)\n{\n\ttext.setContent(content);\n}\n\nbool GraphicSyncTestView::init()\n{\n#if defined(Q_OS_MAC)\n\tfont.setFontFile(\"/Library/Fonts/Arial.ttf\");\n#else\n\tfont.setFontFile(\"C:/Windows/Fonts/Arial.ttf\");\n#endif\n\ttext.setRect(0, 0, 300,  50);\n\treturn true;\n}\n\nvoid GraphicSyncTestView::paint()\n{\n\ttext.draw();\n}\n", "name": "tests/GraphicSyncTest/GraphicSyncTestView.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef GRAPHICSYNCTESTVIEW_H\n#define GRAPHICSYNCTESTVIEW_H\n\n#include \"PhGraphic/PhGraphicView.h\"\n#include \"PhGraphic/PhGraphicText.h\"\n\nclass GraphicSyncTestView : public PhGraphicView\n{\n\tQ_OBJECT\npublic:\n\texplicit GraphicSyncTestView(QWidget *parent = 0);\n\n\tvoid setText(QString content);\nprotected:\n\tbool init();\n\tvoid paint();\n\nprivate:\n\tPhFont font;\n\tPhGraphicText text;\n};\n\n#endif // GRAPHICSYNCTESTVIEW_H\n", "name": "tests/GraphicSyncTest/GraphicSyncTestView.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include \"GraphicSyncTestWindow.h\"\n#include \"ui_GraphicSyncTestWindow.h\"\n\nGraphicSyncTestWindow::GraphicSyncTestWindow(QWidget *parent) :\n\tQMainWindow(parent),\n\tui(new Ui::GraphicSyncTestWindow),\n\t_settings(\"Phonations\", \"GraphicSyncTest\"),\n\t_sony(PhTimeCodeType25, &_settings),\n\t_lastTime(0),\n\t_count(0)\n{\n\tui->setupUi(this);\n\n\t_sony.open(true);\n\t_sony.clock()->setRate(1);\n\n\tconnect(ui->graphicView, SIGNAL(beforePaint(int)), this, SLOT(beforePaint(int)));\n\n\t_time.start();\n}\n\nGraphicSyncTestWindow::~GraphicSyncTestWindow()\n{\n\tdelete ui;\n}\n\nvoid GraphicSyncTestWindow::beforePaint(int frequency)\n{\n\tint elapsed = _time.elapsed() - _lastTime;\n\t_lastTime = _time.elapsed();\n//\tint refreshRate = ui->graphicView->refreshRate();\n\t_sony.checkVideoSync(frequency);\n//\t_sony.clock()->tick(frequency);\n\tfloat ratio = _count++;\n\tif(_sony.clock()->frame() > 0)\n\t\tratio /= _sony.clock()->frame();\n\tQString s = \" \";\n\tif(elapsed < 10 )\n\t\ts = \"<\";\n\telse if(elapsed > 30)\n\t\ts = \">\";\n//\telse if (_count % 60)\n//\t\treturn;\n\n//\tPHDEBUG << s << elapsed << refreshRate << _sony.clock()->frame() << _count << ratio;\n//\tPHDEBUG << s << _sony.clock()->frame() * 1000.0f / _time.elapsed();\n\tui->graphicView->setText(_sony.clock()->timeCode());\n}\n", "name": "tests/GraphicSyncTest/GraphicSyncTestWindow.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef GRAPHICSYNCTESTWINDOW_H\n#define GRAPHICSYNCTESTWINDOW_H\n\n#include <QMainWindow>\n#include <QSettings>\n#include <QTimer>\n#include <QTime>\n\n#include \"PhSync/PhSonySlaveController.h\"\n\nnamespace Ui {\nclass GraphicSyncTestWindow;\n}\n\nclass GraphicSyncTestWindow : public QMainWindow\n{\n\tQ_OBJECT\n\npublic:\n\texplicit GraphicSyncTestWindow(QWidget *parent = 0);\n\t~GraphicSyncTestWindow();\n\nprivate slots:\n\tvoid beforePaint(int frequency);\n\nprivate:\n\tUi::GraphicSyncTestWindow *ui;\n\tQSettings _settings;\n\tPhSonySlaveController _sony;\n\tQTime _time;\n\tint _lastTime;\n\tint _count;\n};\n\n#endif // GRAPHICSYNCTESTWINDOW_H\n", "name": "tests/GraphicSyncTest/GraphicSyncTestWindow.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include \"GraphicSyncTestWindow.h\"\n#include <QApplication>\n\nint main(int argc, char *argv[])\n{\n\tQSettings settings(\"Phonations\", \"GraphicSyncTestWindow\");\n\tint logLevel = settings.value(\"logLevel\", 1).toInt();\n\tPhDebug::setLogMask(logLevel);\n\n\tQApplication a(argc, argv);\n\tGraphicSyncTestWindow w;\n\tw.show();\n\n\treturn a.exec();\n}\n", "name": "tests/GraphicSyncTest/main.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef GRAPHICTESTSETTINGS_H\n#define GRAPHICTESTSETTINGS_H\n\n#include <QApplication>\n\n#include \"PhTools/PhGenericSettings.h\"\n#include \"PhCommonUI/PhWindowSettings.h\"\n#include \"PhGraphic/PhGraphicSettings.h\"\n\nclass GraphicTestSettings : protected PhGenericSettings, public PhWindowSettings, public PhGraphicSettings\n{\npublic:\n\t// PhWindowSettings\n\tPH_SETTING_BOOL(setFullScreen, fullScreen)\n\tPH_SETTING_BYTEARRAY(setWindowGeometry, windowGeometry)\n\n\t// PhGraphicSettings\n\tPH_SETTING_BOOL(setDisplayInfo, displayInfo)\n\tPH_SETTING_BOOL(setResetInfo, resetInfo)\n\n\t// Other settings\n\tPH_SETTING_STRING2(setFontFile, fontFile, QApplication::applicationDirPath() + PATH_TO_RESSOURCES + \"/SWENSON.TTF\")\n\n\tPH_SETTING_INT2(setQuadCount, quadCount, 1)\n\tPH_SETTING_INT2(setTextCount, textCount, 1)\n\n\tPH_SETTING_STRING2(setTextContent, textContent, \"Change the text from the settings\")\n};\n\n#endif // GRAPHICTESTSETTINGS_H\n", "name": "tests/GraphicTest/GraphicTestSettings.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include <qmath.h>\n#include <QCoreApplication>\n\n#include \"PhTools/PhDebug.h\"\n#include \"GraphicTestView.h\"\n#include \"PhTools/PhPictureTools.h\"\n#include \"PhGraphic/PhGraphicDashedLine.h\"\n#include \"PhGraphic/PhGraphicArrow.h\"\n\nGraphicTestView::GraphicTestView(QWidget *parent)\n\t: PhGraphicView( parent),\n\t_settings(NULL),\n\t_x(0)\n{\n}\n\nbool GraphicTestView::setFontFile(QString fontFile)\n{\n\treturn _font1.setFontFile(fontFile);\n}\n\nvoid GraphicTestView::setTestSettings(GraphicTestSettings *settings)\n{\n\t_settings = settings;\n\tPhGraphicView::setGraphicSettings(settings);\n}\n\nbool GraphicTestView::init()\n{\n\tPHDEBUG << \"Initialize _image\";\n\n\tQString imageFile = QCoreApplication::applicationDirPath() + PATH_TO_RESSOURCES + \"/motif-240_black.png\";\n\t_image.setFilename(imageFile);\n\t_image.setTextureCoordinate(1, 1);\n\t_image.setPosition(50, 0, 1);\n\tif (!_image.init()) {\n\t\tPHDEBUG << \"_image not initialize : \" << imageFile;\n\t\treturn false;\n\t}\n\t_image.setSize(_image.originalSize());\n\n\tPHDEBUG << \"Initialize _font\";\n\tif (!_font1.setFontFile(QCoreApplication::applicationDirPath() + PATH_TO_RESSOURCES + \"/SWENSON.TTF\")) {\n\t\tPHDEBUG << \"SWENSON not initialize using path : \" << QCoreApplication::applicationDirPath() + PATH_TO_RESSOURCES + \"/SWENSON.TTF\";\n\t\treturn false;\n\t}\n\n\tif (!_font2.setFontFile(QCoreApplication::applicationDirPath() + PATH_TO_RESSOURCES + \"/Arial.ttf\")) {\n\t\tPHDEBUG << \"ARIAL not initialize\";\n\t\treturn false;\n\t}\n\n\tPHDEBUG << \"Initialize _rect\";\n\t_rect.setRect(100, 100, 75, 40);\n\t_rect.setColor(QColor(0, 255, 0));\n\t_rect.setZ(-2);\n\n\tint w = 50;\n\tint h = 50;\n\tunsigned char * yuv = PhPictureTools::generateYUVPattern(w, h);\n\t_yuvRect.setRect(20, 300, 150, 100);\n\t_yuvRect.createTextureFromYUVBuffer(yuv, w, h);\n\n\treturn true;\n}\n\nvoid GraphicTestView::paint()\n{\n\tglClearColor(1.0f, 1.0f, 1.0f, 1.0f);\n\n\t_image.setTextureCoordinate(1, 3);\n\t_image.draw();\n\n\t_rect.setColor(QColor(0, 255, 0));\n\t_rect.setRect(50, 100, 500, 75);\n\t_rect.draw();\n\n\t_rect.setColor(QColor(0, 255, 255));\n\t_rect.setRect(50, 175, 500, 25);\n\t_rect.draw();\n\n\tint textCount = 1;\n\tint quadCount = 1;\n\tQString textContent(\"Change the text from the settings\");\n\n\tif(_settings) {\n\t\tquadCount = _settings->quadCount();\n\t\ttextCount = _settings->textCount();\n\t\ttextContent = _settings->textContent();\n\t}\n\n\tfor(int i = 0; i < textCount; i++) {\n\t\tPhGraphicText text1(&_font1, textContent);\n\n\t\ttext1.setRect(i % 200, i / 200, 500, 100);\n\t\ttext1.setColor(QColor(128, 255, 0));\n\t\ttext1.setZ(5);\n\t\ttext1.draw();\n\t}\n\n\tthis->addInfo(QString(\"textCount: %1\").arg(textCount));\n\n\tPhGraphicText text2(&_font2, \"e\u00e9a\u00e0i\u00eeo\u00f4\");\n\tint textWidth = 500;\n\ttext2.setRect(_x, 300, textWidth, 100);\n\ttext2.setColor(QColor(255, 0, 0));\n\ttext2.setZ(-1);\n\ttext2.draw();\n\n\t_x += 4;\n\tif(_x > this->width())\n\t\t_x = -textWidth;\n\n\t_font1.select();\n\n\tglEnable(GL_TEXTURE_2D);\n\tglEnable(GL_BLEND);\n\tglColor3f(0, 0, 1);\n\n\tglBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);\n\n\n\tglBegin(GL_QUADS);  //Begining the cube's drawing\n\t{\n\t\tfor(int i = 0; i < quadCount; i++) {\n\t\t\tglTexCoord3f(0, 0, 1);  glVertex3i(0,               0,              0);\n\t\t\tglTexCoord3f(1, 0, 1);  glVertex3i(this->width(),   0,              0);\n\t\t\tglTexCoord3f(1, 1, 1);  glVertex3i(this->width(),   this->height(), 0);\n\t\t\tglTexCoord3f(0, 1, 1);  glVertex3i(0,               this->height(), 0);\n\t\t}\n\t}\n\tglEnd();\n\n\tglDisable(GL_TEXTURE_2D);\n\tglDisable(GL_BLEND);\n\n\t//\t_text.setX(_text.getX() + 4);\n\t//\tif(_text.getX() > this.width())\n\t//\t\t_text.setX(0);\n\t//\tif((_text.getX()+_text.getWidth()) < 0)\n\t//\t\t_text.setX(this.width());\n\n\n\tPhGraphicLoop loop;\n\tloop.setPosition(100, 50, -3);\n\tloop.setSize(120, 100);\n\tloop.setHThick(5);\n\tloop.setCrossHeight(60);\n\tloop.setColor(QColor(1, 255, 1));\n\tloop.draw();\n\n\t//_yuvRect.draw();\n\n\tPhGraphicDisc disc(300, 300, 100);\n\tdisc.setColor(Qt::yellow);\n\tdisc.draw();\n\n\tfor (int i = 0; i < 5; ++i) {\n\t\tPhGraphicDashedLine line(i, 0, 50*i, 300, 30);\n\t\tline.setColor(Qt::green);\n\t\tline.setZ(4);\n\t\tline.draw();\n\t}\n\n\tPhGraphicArrow arrow1(PhGraphicArrow::DownLeftToUpRight, 150, 250, 200, 100);\n\tarrow1.setColor(Qt::red);\n\tarrow1.setZ(5);\n\tarrow1.draw();\n\n\tPhGraphicArrow arrow2(PhGraphicArrow::UpLefToDownRight, 150, 400, 200, 100);\n\tarrow2.setColor(Qt::red);\n\tarrow2.setZ(5);\n\tarrow2.draw();\n}\n\n\n\n\n", "name": "tests/GraphicTest/GraphicTestView.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * Copyright (C) 2012-2014 Phonations\n * License: http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n#ifndef GraphicTestView_H\n#define GraphicTestView_H\n\n#include <QString>\n\n#include \"PhGraphic/PhGraphicView.h\"\n#include \"PhGraphic/PhGraphicImage.h\"\n#include \"PhGraphic/PhGraphicText.h\"\n#include \"PhGraphic/PhFont.h\"\n#include \"PhGraphic/PhGraphicSolidRect.h\"\n#include \"PhGraphic/PhGraphicLoop.h\"\n#include \"PhGraphic/PhGraphicDisc.h\"\n\n#include \"GraphicTestSettings.h\"\n\nclass GraphicTestView : public PhGraphicView\n{\n\tQ_OBJECT\npublic:\n\texplicit GraphicTestView(QWidget *parent = 0);\n\tbool setFontFile(QString fontFile);\n\n\tvoid setTestSettings(GraphicTestSettings *settings);\nprotected:\n\tbool init();\n\n\tvoid paint();\n\nprivate:\n\tGraphicTestSettings *_settings;\n\tPhGraphicImage _image;\n\tPhFont _font1, _font2;\n\tPhGraphicSolidRect _rect;\n\tPhGraphicTexturedRect _yuvRect;\n\tint _x;\n};\n\n#endif // GraphicTestView_H\n", "name": "tests/GraphicTest/GraphicTestView.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include <QFileDialog>\n#include <QMessageBox>\n\n#include \"GraphicTestWindow.h\"\n#include \"ui_GraphicTestWindow.h\"\n\nGraphicTestWindow::GraphicTestWindow(GraphicTestSettings *settings) :\n\tPhWindow(settings),\n\tui(new Ui::GraphicTestWindow),\n\t_settings(settings)\n{\n\tui->setupUi(this);\n\tui->graphicView->setTestSettings(_settings);\n}\n\nGraphicTestWindow::~GraphicTestWindow()\n{\n\tdelete ui;\n}\n\n\nvoid GraphicTestWindow::on_actionChange_font_triggered()\n{\n\tQString fileName = QFileDialog::getOpenFileName();\n\tif(QFile(fileName).exists()) {\n\t\tif(!ui->graphicView->setFontFile(fileName))\n\t\t\tQMessageBox::critical(this, \"Error\", \"Unable to open \" + fileName);\n\t}\n}\n", "name": "tests/GraphicTest/GraphicTestWindow.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef GRAPHICTESTWINDOW_H\n#define GRAPHICTESTWINDOW_H\n\n#include \"PhCommonUI/PhWindow.h\"\n\n#include \"GraphicTestSettings.h\"\n#include \"GraphicTestView.h\"\n\nnamespace Ui {\nclass GraphicTestWindow;\n}\n\nclass GraphicTestWindow : public PhWindow\n{\n\tQ_OBJECT\n\npublic:\n\texplicit GraphicTestWindow(GraphicTestSettings *settings);\n\t~GraphicTestWindow();\n\nprivate slots:\n\tvoid on_actionChange_font_triggered();\n\nprivate:\n\tUi::GraphicTestWindow *ui;\n\tGraphicTestSettings *_settings;\n};\n\n#endif // GRAPHICTESTWINDOW_H\n", "name": "tests/GraphicTest/GraphicTestWindow.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include <QApplication>\n#include <QtGui>\n#include <QtCore>\n#include \"GraphicTestWindow.h\"\n#include \"GraphicTestSettings.h\"\n\n/**\n * @brief The application main entry point\n * @param argc Command line argument count\n * @param argv Command line argument list\n * @return 0 if the application works well.\n */\nint main(int argc, char *argv[])\n{\n\tGraphicTestSettings settings;\n\tQApplication a(argc, argv);\n\tGraphicTestWindow w(&settings);\n\tw.show();\n\n\treturn a.exec();\n}\n", "name": "tests/GraphicTest/main.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include <stdio.h>\n#include <math.h>\n#include \"ltc.h\"\n\n#include \"PhTools/PhDebug.h\"\n\n#define BUFFER_SIZE (256)\n\n/**\n * @brief The application main entry point\n * @param argc Command line argument count\n * @param argv Command line argument list\n * @return 0 if the application works well.\n */\nint main(int argc, char *argv[])\n{\n\tif (argc < 2) {\n\t\tprintf(\"Usage: %s <filename> [audio-frames-per-video-frame]\\n\", argv[0]);\n\t\treturn -1;\n\t}\n\n\tchar *fileName = argv[1];\n\tFILE *f = fopen(fileName, \"r\");\n\tif (!f) {\n\t\tfprintf(stderr, \"error opening '%s'\\n\", fileName);\n\t\treturn -1;\n\t}\n\tfprintf(stderr, \"* reading from: %s\\n\", fileName);\n\tLTCDecoder *decoder = ltc_decoder_create(1920, 3840);\n\tltcsnd_sample_t sound[BUFFER_SIZE];\n\n\tltc_off_t offset = 0;\n\tsize_t byteRead = 0;\n\tltc_off_t lastOffset = 0;\n\tdo {\n\t\tbyteRead = fread(sound, 1, BUFFER_SIZE, f);\n\n\t\tint minLevel = 0;\n\t\tint maxLevel = 0;\n\n\t\tfor(int i = 0; i < byteRead; i++) {\n\t\t\tif(sound[i] < minLevel)\n\t\t\t\tminLevel = sound[i];\n\t\t\telse if (sound[i] > maxLevel)\n\t\t\t\tmaxLevel = sound[i];\n\t\t}\n\n\t\tPHDEBUG << minLevel << maxLevel;\n\n\t\tltc_decoder_write(decoder, sound, byteRead, offset);\n\n\t\tLTCFrameExt frame;\n\t\twhile (ltc_decoder_read(decoder, &frame)) {\n\t\t\tSMPTETimecode stime;\n\t\t\tltc_frame_to_time(&stime, &frame.ltc, 1);\n\t\t\tPHDEBUG << frame.off_start << \":\" << stime.hours << stime.mins << stime.secs << stime.frame << \"/\" << frame.off_start - lastOffset;\n\t\t\tlastOffset = frame.off_start;\n\t\t}\n\t\toffset += byteRead;\n\t}\n\twhile (byteRead);\n\n\tfclose(f);\n\tltc_decoder_free(decoder);\n\n\treturn 0;\n}\n", "name": "tests/LTCTest/main.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include <QApplication>\n\n#include \"OpenGLTestWindow.h\"\n\nint main(int argc, char *argv[])\n{\n\tQApplication a(argc, argv);\n\tOpenGLTestWindow w;\n\tw.show();\n\n\treturn a.exec();\n}\n", "name": "tests/OpenGLTest/main.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include \"OpenGLTestWindow.h\"\n#include <QDebug>\n\nOpenGLTestWindow::OpenGLTestWindow(QWidget *parent) :\n\tQGLWidget(parent) {\n}\n\nvoid OpenGLTestWindow::initializeGL()\n{\n\tqDebug() << \"initializeGL()\";\n\n\tconnect(&_refreshTimer, SIGNAL(timeout()), this, SLOT(updateGL()));\n\t_refreshTimer.setInterval(0);\n\t_refreshTimer.start();\n\t_timer.start();\n}\n\nvoid OpenGLTestWindow::paintGL()\n{\n\tqDebug() << \"paintGL:\" << _timer.elapsed();\n\tglClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\t_timer.restart();\n}\n", "name": "tests/OpenGLTest/OpenGLTestWindow.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef OPENGLTESTWINDOW_H\n#define OPENGLTESTWINDOW_H\n\n#include <QGLWidget>\n#include <QTimer>\n#include <QTime>\n\nclass OpenGLTestWindow : public QGLWidget\n{\n\tQ_OBJECT\n\npublic:\n\texplicit OpenGLTestWindow(QWidget *parent = 0);\n\n\tvoid initializeGL();\n\tvoid paintGL();\n\nprivate:\n\tQTimer _refreshTimer;\n\tQTime _timer;\n};\n\n#endif // OPENGLTESTWINDOW_H\n", "name": "tests/OpenGLTest/OpenGLTestWindow.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include <QtWidgets>\n\n#ifndef CUSTOMWINDOW_H\n#define CUSTOMWINDOW_H\n\n\nclass CustomWindow : public QWidget\n{\n\tQ_OBJECT\n\npublic:\n\tCustomWindow(QWidget *parent = 0);\n\t~CustomWindow();\n\nprotected:\n\tvoid showEvent(QShowEvent *event);\n\nprivate:\n\tvoid CenterOnScreen();\n};\n\n#endif\n\n", "name": "tests/SDLTest/customwindow.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include <QtGlobal>\n\n#include <SDL2/SDL.h>\n#if defined(Q_OS_MAC)\n#include <SDL2_image/SDL_image.h>\n#include <SDL2_ttf/SDL_ttf.h>\n#else\n#include <SDL2/SDL_image.h>\n#include <SDL2/SDL_ttf.h>\n#endif\n\n#include <string>\n#include <cstring>\n#include \"string.h\"\n#include \"iostream\"\n\n#include <QString>\n#include <QFileInfo>\n#include <QDebug>\n#include <QDir>\n#include <QApplication>\n#include <QTime>\n\nusing namespace std;\n\n#undef main\n\n/**\n * @brief The application main entry point\n * @param argc Command line argument count\n * @param argv Command line argument list\n * @return 0 if the application works well.\n */\nint main(int argc, char **argv)\n{\n\tQApplication a(argc, argv);\n\n\tint numdrivers = SDL_GetNumRenderDrivers();\n\tprintf(\"Drivers count: %i\\n\", numdrivers);\n\tfor (int i = 0; i < numdrivers; i++) {\n\t\tSDL_RendererInfo drinfo;\n\t\tSDL_GetRenderDriverInfo(i, &drinfo);\n\n\t\tprintf(\"Driver name: %s\\n\", drinfo.name);\n\t}\n\n\tqDebug() << \"Initialize all SDL subsystems\";\n\tif( SDL_Init( SDL_INIT_VIDEO ) == -1 ) {\n\t\tqDebug() << \"Error:\" << SDL_GetError();\n\t\treturn false;\n\t}\n\n\tqDebug() << \"Set up the window\";\n\tint screenWidth = 1280;\n\tint screenHeight = 600;\n\tSDL_Window * window = SDL_CreateWindow(\"SDLTest\", 100, 100, screenWidth, screenHeight, SDL_SWSURFACE);\n\n\tSDL_Surface * screen = SDL_GetWindowSurface(window);\n\n\tSDL_Rect rect = {600, 20, 200, 300};\n\tSDL_FillRect(screen, &rect, 0xff0000ff);\n\n\tQString ressourcesPath = QApplication::applicationDirPath();\n\t// Create a surface from picture:\n\tQString lookPath = ressourcesPath + \"/look.png\";\n\n\tQFile file(lookPath);\n\tqDebug() << \"exists\" << file.exists();\n\tSDL_Surface *image = IMG_Load( lookPath.toStdString().c_str());\n\n\tif ( image == NULL ) {\n\t\tqDebug() << \"failed to load \" << lookPath;\n\t\tqDebug() << SDL_GetError();\n\t\treturn 1;\n\t}\n\n\t// Display the picture:\n\tSDL_Rect imageRect = {0, 0, image->w, image->h};\n\n\tSDL_BlitSurface( image, NULL, screen, &imageRect );\n\n\t// Initialize TTF :\n\tif( TTF_Init() == -1 ) {\n\t\tqDebug() << \"TTF error.\";\n\t\treturn 2;\n\t}\n\n\t//Create a font\n\tQString fontPath = ressourcesPath + \"/SWENSON.TTF\";\n\tTTF_Font *font = TTF_OpenFont(fontPath.toStdString().c_str(), 100 );\n\tqDebug() << \"Outline :\" << TTF_GetFontOutline(font);\n\n\tif (font == NULL) {\n\t\tqDebug() << \"Error opening \" << fontPath;\n\t\tqDebug() << SDL_GetError();\n\t\treturn 3;\n\t}\n\n\t//Font's color (black)\n\tSDL_Color color = {0, 0, 0, 255};\n\tUint16 ch;\n#define TEST  2\n\n#if TEST == 0\n\t// Displaying a simple string:\n\tSDL_Surface *surface = TTF_RenderUTF8_Blended(font, \"ABCDEFGHIJKL\", color );\n\tSDL_Rect textRect = {0, 100, surface->w, surface->h};\n\tSDL_BlitSurface( surface, NULL, screen, &textRect);\n\n#elif TEST == 2\n\t// used to set the base surface\n\tUint32 rmask, gmask, bmask, amask;\n\trmask = 0x000000ff;\n\tgmask = 0x0000ff00;\n\tbmask = 0x00ff0000;\n\tamask = 0xff000000;\n\n\n\n\t// Creation of the glyph surface\n\tSDL_Surface * glyphMatrix = SDL_CreateRGBSurface(0, 2048, 2048, 32, rmask, gmask, bmask, amask);\n\n\n\t// THIS IS ONLY FOR VISUAL PURPOSE, TOTALY USELESS ON A REAL SITUATION\n\tUint32 bgColor;\n\tbgColor = 0xffffffff;\n\tqDebug() << SDL_FillRect(screen, NULL, bgColor);\n\n\t// store the width of each glyph\n\tint glyphWidth[256];\n\tint glyphAdvance[256];\n\n\t// Space between glyph\n\tint space = 128;\n\tint glyphHeight = 0;\n\n\t// Nb pass for bold setting\n\tint nbPass = 2;\n\tfor(int i = 0; i <= nbPass; i++) {\n\t\tTTF_SetFontOutline(font, i);\n\t\tfor(ch = 32; ch < 256; ++ch) {\n\t\t\tif(TTF_GlyphIsProvided(font, ch)) {\n\t\t\t\tint minx, maxx, miny, maxy, advance;\n\t\t\t\tTTF_GlyphMetrics(font, ch, &minx, &maxx, &miny, &maxy, &advance);\n\t\t\t\t//qDebug() << ch << (char) ch << minx << maxx << miny << maxy << advance;\n\t\t\t\tif(advance != 0) {\n\t\t\t\t\t// Temporary surface of the character\n\t\t\t\t\tSDL_Surface * glyphSurface = TTF_RenderGlyph_Blended(font, ch, color);\n\t\t\t\t\tif (!glyphSurface) {\n\n\t\t\t\t\t\tqDebug() << SDL_GetError();\n\t\t\t\t\t\tqDebug() << TTF_GetError();\n\t\t\t\t\t}\n\t\t\t\t\tSDL_Rect glyphRect;\n\t\t\t\t\tglyphRect.x = (ch % 16) * space;\n\t\t\t\t\tglyphRect.y = (ch / 16) * space;\n\t\t\t\t\tglyphRect.w = glyphSurface->w;\n\t\t\t\t\tglyphRect.h = glyphSurface->h;\n\t\t\t\t\tif(glyphRect.h > glyphHeight)\n\t\t\t\t\t\tglyphHeight = glyphRect.h;\n\t\t\t\t\tif(SDL_BlitSurface( glyphSurface, NULL, glyphMatrix, &glyphRect ))\n\t\t\t\t\t\tqDebug() << SDL_GetError();\n\n\t\t\t\t\t// Store information about the glyph\n\t\t\t\t\tglyphAdvance[ch] = advance;\n\t\t\t\t\tglyphWidth[ch] = maxx - minx;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tqDebug() <<\" Error with : \" << ch << (char) ch << minx << maxx << miny << maxy << advance;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tglyphAdvance[ch] = 0;\n\t\t\t\tglyphWidth[ch] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t//This draw the entire glyph\n\tSDL_Rect glyphMatrixRect;\n\tglyphMatrixRect.x = 0;\n\tglyphMatrixRect.y = -1000;\n\tglyphMatrixRect.w = 400;\n\tglyphMatrixRect.h = 400;\n\tSDL_BlitSurface(glyphMatrix, NULL, screen, &glyphMatrixRect);\n\n\tint x = 50;\n\tint y = 100;\n\tQString s = \"Martin et ses chaussettes propres\";\n\n\t// Display a string\n\tfor(int i = 0; i < s.length(); i++) {\n\t\tint ch = (int)s.at(i).toLatin1();\n\t\tif(glyphWidth[ch] > 0) {\n\t\t\t// Compute glyph rect in the matrix\n\t\t\tSDL_Rect glyphRect;\n\t\t\tglyphRect.x = (ch % 16) * space;\n\t\t\tglyphRect.y = (ch / 16) * space;\n\t\t\t//glyphRect.w = glyphWidth[ch];\n\t\t\tglyphRect.w = space;\n\t\t\tglyphRect.h = glyphHeight;\n\n\n\t\t\t// Display the glyph on the screen\n\t\t\tSDL_Rect draw = {x, y, 500, 500};\n\t\t\tSDL_BlitSurface(glyphMatrix, &glyphRect, screen, &draw);\n\n\t\t}\n\t\t// Shift the offset\n\t\tx += glyphAdvance[ch];\n\t}\n\n\n\n\t//qDebug() << t.elapsed();\n\n#endif\n\n\tSDL_Surface * glyphSurface = TTF_RenderGlyph_Blended(font, 339, color);\n\tSDL_BlitSurface(glyphSurface, NULL, screen, NULL);\n\n\n\t//Update the screen\n\tif( SDL_UpdateWindowSurface(window)) {\n\t\tqDebug() << \"failed to update\";\n\t\treturn -1;\n\t}\n\n\tbool quit = false;\n\n\t//While the user hasn't quit\n\twhile(quit == false) {\n\t\tSDL_Event event;\n\t\t//While there's an event to handle\n\t\twhile( SDL_PollEvent(&event) ) {\n\t\t\t//If the user has Xed out the window\n\t\t\tif( event.type == SDL_QUIT ) { //Quit the program\n\t\t\t\tquit = true;\n\t\t\t}\n\t\t}\n\t}\n\n//\t//Free the surface and quit SDL\n\tSDL_FreeSurface( image );\n//\tSDL_FreeSurface(message);\n\tSDL_FreeSurface(screen);\n\n//\t//Quit SDL\n\tTTF_CloseFont( font );\n\tTTF_Quit();\n\tSDL_Quit();\n\n\treturn 0;\n}\n\n\n", "name": "tests/SDLTest/main.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include \"SerialTestWindow.h\"\n#include <QApplication>\n\n/**\n * @brief The application main entry point\n * @param argc Command line argument count\n * @param argv Command line argument list\n * @return 0 if the application works well.\n */\nint main(int argc, char *argv[])\n{\n\tQApplication a(argc, argv);\n\tSerialTestWindow w;\n\tw.show();\n\n\treturn a.exec();\n}\n", "name": "tests/SerialTest/main.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include <QSerialPortInfo>\n\n#include \"SerialTestWindow.h\"\n#include \"ui_SerialTestWindow.h\"\n#include \"PhTools/PhDebug.h\"\n\nSerialTestWindow::SerialTestWindow(QWidget *parent) :\n\tQMainWindow(parent),\n\tui(new Ui::SerialTestWindow),\n\t_serialA(this),\n\t_serialB(this)\n{\n\tui->setupUi(this);\n\n\tconnect(ui->sendButton1, SIGNAL(clicked()), this, SLOT(sendTextA()));\n\tconnect(&_serialA, SIGNAL(readyRead()), this, SLOT(readTextA()));\n\tif(open(&_serialA, \"A\"))\n\t\t_serialA.write(\"Hello from serial A\");\n\n\n\tconnect(ui->sendButton2, SIGNAL(clicked()), this, SLOT(sendTextB()));\n\tconnect(&_serialB, SIGNAL(readyRead()), this, SLOT(readTextB()));\n\tif(open(&_serialB, \"B\"))\n\t\t_serialB.write(\"Hello from serial B\");\n\n\tconnect(&_ctsTimer, SIGNAL(timeout()), this, SLOT(checkCTS()));\n\t_ctsTimer.start(5);\n}\n\nSerialTestWindow::~SerialTestWindow()\n{\n\tcloseA();\n\tcloseB();\n\tdelete ui;\n}\n\nvoid SerialTestWindow::sendTextA()\n{\n\t_serialA.write(ui->inputA->text().toUtf8().constData());\n}\n\nvoid SerialTestWindow::sendTextB()\n{\n\t_serialB.write(ui->inputB->text().toUtf8().constData());\n}\n\nvoid SerialTestWindow::readTextA()\n{\n\tchar buffer[256];\n\tqint64 n = _serialA.read(buffer, 256);\n\tbuffer[n] = 0;\n\tQString s(buffer);\n\tui->receiveA->setText(ui->receiveA->toPlainText() + s);\n\n\tcheckCTS();\n}\n\nvoid SerialTestWindow::readTextB()\n{\n\tchar buffer[256];\n\tqint64 n = _serialB.read(buffer, 256);\n\tbuffer[n] = 0;\n\tQString s(buffer);\n\tui->receiveB->setText(ui->receiveB->toPlainText() + s);\n\n\tcheckCTS();\n}\n\nvoid SerialTestWindow::on_checkA_toggled(bool checked)\n{\n\tif(checked)\n\t\topen(&_serialA, \"A\");\n\telse\n\t\tcloseA();\n}\n\nvoid SerialTestWindow::on_checkB_toggled(bool checked)\n{\n\tif(checked)\n\t\topen(&_serialB, \"B\");\n\telse\n\t\tcloseB();\n}\n\nbool SerialTestWindow::open(QSerialPort * serial, QString suffix)\n{\n\tPHDEBUG << \"open\" << suffix;\n\n\tforeach(QSerialPortInfo info, QSerialPortInfo::availablePorts())\n\t{\n\t\tQString name = info.portName();\n\t\tif(name.startsWith(\"usbserial-\")) {\n\t\t\tif(name.endsWith(suffix)) {\n\t\t\t\tserial->setPort(info);\n\t\t\t\tserial->setBaudRate(QSerialPort::Baud38400);\n\t\t\t\tserial->setDataBits(QSerialPort::Data8);\n\t\t\t\tserial->setStopBits(QSerialPort::OneStop);\n\t\t\t\tserial->setParity(QSerialPort::OddParity);\n\n\t\t\t\tPHDEBUG << \"Opening \" << name;\n\t\t\t\tserial->open(QSerialPort::ReadWrite);\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\tPHDEBUG << \"not found\";\n\treturn false;\n}\n\nvoid SerialTestWindow::closeA()\n{\n\tPHDEBUG << \"Closing \" << _serialA.objectName();\n\t_serialA.close();\n}\n\nvoid SerialTestWindow::closeB()\n{\n\tPHDEBUG << \"Closing \" << _serialB.objectName();\n\t_serialB.close();\n}\n\nvoid SerialTestWindow::checkCTS()\n{\n\tbool cts = _serialA.pinoutSignals() & QSerialPort::ClearToSendSignal;\n\tfloat frequency = _ctsCounter.frequency();\n\tif(cts != _lastCTS) {\n\t\t_ctsCounter.tick();\n\t\tui->ctsLabel->setText(\"CTS : \" + QString::number(frequency));\n\t\t_lastCTS = cts;\n\t}\n\n\t_timerCounter.tick();\n\tPHDEBUG << _timerCounter.frequency() << frequency;\n}\n", "name": "tests/SerialTest/SerialTestWindow.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef MAINWINDOW_H\n#define MAINWINDOW_H\n\n#include <QMainWindow>\n#include <QSerialPort>\n#include <QTimer>\n\n#include \"PhTools/PhTickCounter.h\"\n\nnamespace Ui {\nclass SerialTestWindow;\n}\n\nclass SerialTestWindow : public QMainWindow\n{\n\tQ_OBJECT\n\npublic:\n\texplicit SerialTestWindow(QWidget *parent = 0);\n\t~SerialTestWindow();\n\nprivate slots:\n\tvoid sendTextA();\n\tvoid readTextA();\n\tvoid sendTextB();\n\tvoid readTextB();\n\n\tvoid on_checkA_toggled(bool checked);\n\n\tvoid on_checkB_toggled(bool checked);\n\tvoid checkCTS();\n\nprivate:\n\tbool open(QSerialPort * serial, QString suffix);\n\tvoid closeA();\n\tvoid closeB();\n\n\n\tUi::SerialTestWindow *ui;\n\n\tQSerialPort _serialA, _serialB;\n\tQTimer _ctsTimer;\n\tPhTickCounter _ctsCounter, _timerCounter;\n\tbool _lastCTS;\n};\n\n#endif // MAINWINDOW_H\n", "name": "tests/SerialTest/SerialTestWindow.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include \"SonyTestWindow.h\"\n#include <QApplication>\n#include <QtTest>\n\n#include \"PhTools/PhDebug.h\"\n\nint main(int argc, char *argv[])\n{\n\tQApplication a(argc, argv);\n\tMainWindow w;\n\tw.show();\n\n\treturn a.exec();\n}\n", "name": "tests/SonyTest/main.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef SONYTESTSETTINGS_H\n#define SONYTESTSETTINGS_H\n\n#include \"PhTools/PhGenericSettings.h\"\n#include \"PhSync/PhSyncSettings.h\"\n\nclass SonyTestSettings : PhGenericSettings, public PhSyncSettings\n{\npublic:\n\t// PhSyncSettings:\n\tPH_SETTING_BOOL2(setVideoSyncUp, videoSyncUp, true)\n\tPH_SETTING_UCHAR2(setSonyDevice1, sonyDevice1, 0xF0)\n\tPH_SETTING_UCHAR2(setSonyDevice2, sonyDevice2, 0xC0)\n\tPH_SETTING_FLOAT2(setSonyFastRate, sonyFastRate, 3)\n\tPH_SETTING_STRING2(setSonySlavePortSuffix, sonySlavePortSuffix, \"A\")\n\tPH_SETTING_STRING2(setSonyMasterPortSuffix, sonyMasterPortSuffix, \"B\")\n\n\t// Others settings\n\tPH_SETTING_BOOL2(setSonySlaveActive, sonySlaveActive, true);\n\tPH_SETTING_BOOL2(setSonyMasterActive, sonyMasterActive, true)\n\n\tPH_SETTING_BOOL2(setUseVideoSlaveSync, useVideoSlaveSync, true);\n\tPH_SETTING_BOOL2(setUseVideoMasterSync, useVideoMasterSync, true);\n\n};\n\n#endif // SONYTESTSETTINGS_H\n", "name": "tests/SonyTest/SonyTestSettings.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include <QMessageBox>\n\n#include \"SonyTestWindow.h\"\n#include \"ui_SonyTestWindow.h\"\n\n#include \"PhTools/PhDebug.h\"\n#include \"PhCommonUI/PhTimeCodeDialog.h\"\n\nMainWindow::MainWindow(QWidget *parent) :\n\tQMainWindow(parent),\n\tui(new Ui::MainWindow),\n\t_sonyMaster(PhTimeCodeType25, &_settings),\n\t_sonySlave(PhTimeCodeType25, &_settings)\n{\n\tui->setupUi(this);\n\n\t// configure panels\n\tui->masterPanel->setMediaLength(10000);\n\n\tui->slavePanel->setMediaLength(10000);\n\n\t// Connect master panel to sony master\n\tconnect(ui->masterPanel, SIGNAL(playPause()), this, SLOT(masterPlayPause()));\n\tconnect(ui->masterPanel, SIGNAL(nextFrame()), this, SLOT(masterNextFrame()));\n\tconnect(ui->masterPanel, SIGNAL(previousFrame()), this, SLOT(masterPreviousFrame()));\n\tconnect(ui->masterPanel, SIGNAL(fastForward()), &_sonyMaster, SLOT(fastForward()));\n\tconnect(ui->masterPanel, SIGNAL(rewind()), &_sonyMaster, SLOT(rewind()));\n\n\tconnect(_sonyMaster.clock(), SIGNAL(frameChanged(PhFrame, PhTimeCodeType)), ui->masterPanel, SLOT(onFrameChanged(PhFrame, PhTimeCodeType)));\n\tconnect(_sonyMaster.clock(), SIGNAL(rateChanged(PhRate)), ui->masterPanel, SLOT(onRateChanged(PhRate)));\n\n\t// Connect sony master to MainWindow\n\tconnect(ui->queryIdButton, SIGNAL(clicked()), &_sonyMaster, SLOT(deviceTypeRequest()));\n\tconnect(ui->statusSenseButton, SIGNAL(clicked()), &_sonyMaster, SLOT(statusSense()));\n\tconnect(ui->timeSenseButton, SIGNAL(clicked()), &_sonyMaster, SLOT(timeSense()));\n\tconnect(ui->speedSenseButton, SIGNAL(clicked()), &_sonyMaster, SLOT(speedSense()));\n\n\tconnect(&_sonyMaster, SIGNAL(deviceIdData(unsigned char, unsigned char)), this, SLOT(onDeviceIdData(unsigned char, unsigned char)));\n\tconnect(&_sonyMaster, SIGNAL(statusData(unsigned char*, int, int)), this, SLOT(onStatusData(unsigned char*, int, int)));\n\n\t// Connect sony slave clock to slave panel\n\tconnect(_sonySlave.clock(), SIGNAL(frameChanged(PhFrame, PhTimeCodeType)), ui->slavePanel, SLOT(onFrameChanged(PhFrame, PhTimeCodeType)));\n\tconnect(_sonySlave.clock(), SIGNAL(rateChanged(PhRate)), ui->slavePanel, SLOT(onRateChanged(PhRate)));\n\n\t// Connect video sync signal\n//\tconnect(&_sonyMaster, SIGNAL(videoSync()), &_sonyMaster, SLOT(onVideoSync()));\n//\tconnect(&_sonySlave, SIGNAL(videoSync()), &_sonySlave, SLOT(onVideoSync()));\n\t// start master and slave\n\n\ton_masterActiveCheck_clicked(_settings.sonyMasterActive());\n\ton_slaveActiveCheck_clicked(_settings.sonySlaveActive());\n\n\tui->actionSlave_Use_video_sync->setChecked(_settings.useVideoSlaveSync());\n\tui->actionMaster_Use_video_sync->setChecked(_settings.useVideoMasterSync());\n\n\ton_actionSlave_Use_video_sync_triggered(_settings.useVideoSlaveSync());\n\ton_actionMaster_Use_video_sync_triggered(_settings.useVideoMasterSync());\n\n\t_sonySlave.clock()->setFrame(25 * 25);\n\n//\t_sonySlave.getClock()->setRate(1);\n}\n\nMainWindow::~MainWindow()\n{\n\t_sonyMaster.close();\n\t_sonySlave.close();\n\tdelete ui;\n}\n\nvoid MainWindow::masterPlayPause()\n{\n\tif(_sonyMaster.clock()->rate() != 0)\n\t\t_sonyMaster.stop();\n\telse\n\t\t_sonyMaster.play();\n}\n\nvoid MainWindow::masterNextFrame()\n{\n\t_sonyMaster.cue(_sonyMaster.clock()->frame() + 1);\n}\n\nvoid MainWindow::masterPreviousFrame()\n{\n\t_sonyMaster.cue(_sonyMaster.clock()->frame() - 1);\n}\n\nvoid MainWindow::onDeviceIdData(unsigned char id1, unsigned char id2)\n{\n\tQString id;\n\tid.sprintf(\"%2X %2X\", id1, id2);\n\tui->idLabel->setText(id);\n}\n\nvoid MainWindow::onStatusData(unsigned char *statusData, int offset, int length)\n{\n\tQ_UNUSED(offset);\n\tQString statusStr = \"\";\n\tfor (int i = 0; i < length; i++)\n\t\tstatusStr += QString::number(statusData[i], 16) + \" \";\n\tui->statusLabel->setText(statusStr);\n}\n\nvoid MainWindow::on_masterActiveCheck_clicked(bool checked)\n{\n\t_settings.setSonyMasterActive(checked);\n\tif(checked) {\n\t\tPHDEBUG << \"opening master\";\n\n\t\tif(_sonyMaster.open()) {\n\t\t\tPHDEBUG << \"master open ok\";\n\n\t\t\t_sonyMaster.deviceTypeRequest();\n\t\t\t_sonyMaster.statusSense();\n\t\t\t_sonyMaster.timeSense();\n\t\t\t_sonyMaster.speedSense();\n\t\t}\n\t\telse {\n\t\t\tPHDEBUG << \"error opening master\";\n\t\t\tchecked = false;\n\t\t\tQMessageBox::critical(this, \"Sony Test\", \"Unable to connect to Sony master\");\n\t\t}\n\t}\n\telse {\n\t\tPHDEBUG << \"closing sony master\";\n\t\t_sonyMaster.close();\n\t}\n\n\tui->masterActiveCheck->setChecked(checked);\n\n\tui->queryIdButton->setEnabled(checked);\n\tui->statusSenseButton->setEnabled(checked);\n\tui->timeSenseButton->setEnabled(checked);\n\tui->speedSenseButton->setEnabled(checked);\n\n\tui->masterPanel->setEnabled(checked);\n}\n\nvoid MainWindow::on_slaveActiveCheck_clicked(bool checked)\n{\n\t_settings.setSonySlaveActive(checked);\n\tif(checked) {\n\t\tif(_sonySlave.open())\n\t\t\tPHDEBUG << \"slave open ok\";\n\t\telse {\n\t\t\tPHDEBUG << \"error opening slave\";\n\t\t\tchecked = false;\n\t\t\tQMessageBox::critical(this, \"Sony Test\", \"Unable to connect to Sony slave\");\n\t\t}\n\t}\n\telse {\n\t\tPHDEBUG << \"closing sony slave\";\n\t\t_sonySlave.clock()->setRate(0);\n\t\t_sonySlave.close();\n\t}\n\n\tui->slaveActiveCheck->setChecked(checked);\n\tui->slavePanel->setEnabled(checked);\n}\n\n\nvoid MainWindow::on_actionMaster_GoTo_triggered()\n{\n\tPhTimeCodeDialog dlg(_sonyMaster.clock()->timeCodeType(), _sonyMaster.clock()->frame());\n\tif(dlg.exec() == QDialog::Accepted)\n\t\t_sonyMaster.cue(dlg.frame());\n}\n\nvoid MainWindow::on_actionSlave_GoTo_triggered()\n{\n\tPhTimeCodeDialog dlg(_sonySlave.clock()->timeCodeType(), _sonySlave.clock()->frame());\n\tif(dlg.exec() == QDialog::Accepted)\n\t\t_sonySlave.clock()->setFrame(dlg.frame());\n}\n\nvoid MainWindow::on_actionSlave_Use_video_sync_triggered(bool useVideo)\n{\n\t_settings.setUseVideoSlaveSync(useVideo);\n\n\t_slaveTimer.stop();\n\tif(useVideo) {\n\t\t// timer trigger the checkVideoSync on the serial port\n\t\tdisconnect(&_slaveTimer, SIGNAL(timeout()), &_sonySlave, SLOT(onVideoSync()));\n\t\tconnect(&_slaveTimer, SIGNAL(timeout()), &_sonySlave, SLOT(checkVideoSync()));\n\n\t\t_slaveTimer.start(10);\n\t}\n\telse {\n\t\t// timer trigger the onVideoSync slot directly\n\t\tdisconnect(&_slaveTimer, SIGNAL(timeout()), &_sonySlave, SLOT(checkVideoSync()));\n\t\tconnect(&_slaveTimer, SIGNAL(timeout()), &_sonySlave, SLOT(onVideoSync()));\n\n\t\t_slaveTimer.start(40);\n\t}\n}\n\nvoid MainWindow::on_actionMaster_Use_video_sync_triggered(bool useVideo)\n{\n\t_settings.setUseVideoMasterSync(useVideo);\n\n\t_masterTimer.stop();\n\tif(useVideo) {\n\t\t// timer trigger the checkVideoSync on the serial port\n\t\tdisconnect(&_masterTimer, SIGNAL(timeout()), &_sonyMaster, SLOT(onVideoSync()));\n\t\tconnect(&_masterTimer, SIGNAL(timeout()), &_sonyMaster, SLOT(checkVideoSync()));\n\n\t\t_masterTimer.start(10);\n\t}\n\telse {\n\t\t// timer trigger the onVideoSync slot directly\n\t\tdisconnect(&_masterTimer, SIGNAL(timeout()), &_sonyMaster, SLOT(checkVideoSync()));\n\t\tconnect(&_masterTimer, SIGNAL(timeout()), &_sonyMaster, SLOT(onVideoSync()));\n\n\t\t_masterTimer.start(40);\n\t}\n}\n", "name": "tests/SonyTest/SonyTestWindow.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef MAINWINDOW_H\n#define MAINWINDOW_H\n\n#include <QMainWindow>\n#include <QTimer>\n\n#include \"PhTools/PhClock.h\"\n#include \"PhSync/PhSonyMasterController.h\"\n#include \"PhSync/PhSonySlaveController.h\"\n\n#include \"SonyTestSettings.h\"\n\nnamespace Ui {\nclass MainWindow;\n}\n\n/**\n * @brief The MainWindow class\n *\n * The status active/inactive of the ports are saved to the settings whenever they are changed\n * and loaded when the application is launched\n */\n\nclass MainWindow : public QMainWindow\n{\n\tQ_OBJECT\n\npublic:\n\texplicit MainWindow(QWidget *parent = 0);\n\t~MainWindow();\n\nprivate slots:\n\tvoid masterPlayPause();\n\tvoid masterNextFrame();\n\tvoid masterPreviousFrame();\n\n\tvoid onDeviceIdData(unsigned char id1, unsigned char id2);\n\tvoid onStatusData(unsigned char * statusData, int offset, int length);\n\tvoid on_masterActiveCheck_clicked(bool checked);\n\tvoid on_slaveActiveCheck_clicked(bool checked);\n\n\n\tvoid on_actionMaster_GoTo_triggered();\n\n\tvoid on_actionSlave_GoTo_triggered();\n\n\tvoid on_actionSlave_Use_video_sync_triggered(bool useVideo);\n\n\tvoid on_actionMaster_Use_video_sync_triggered(bool useVideo);\n\nprivate:\n\tSonyTestSettings _settings;\n\tUi::MainWindow *ui;\n\tPhSonyMasterController _sonyMaster;\n\tPhSonySlaveController _sonySlave;\n\tQTimer _masterTimer, _slaveTimer;\n};\n\n#endif // MAINWINDOW_H\n", "name": "tests/SonyTest/SonyTestWindow.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/****************************************************************************\n**\n** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).\n** Contact: http://www.qt-project.org/legal\n**\n** This file is part of the examples of the Qt Toolkit.\n**\n** $QT_BEGIN_LICENSE:BSD$\n** You may use this file under the terms of the BSD license as follows:\n**\n** \"Redistribution and use in source and binary forms, with or without\n** modification, are permitted provided that the following conditions are\n** met:\n**   * Redistributions of source code must retain the above copyright\n**     notice, this list of conditions and the following disclaimer.\n**   * Redistributions in binary form must reproduce the above copyright\n**     notice, this list of conditions and the following disclaimer in\n**     the documentation and/or other materials provided with the\n**     distribution.\n**   * Neither the name of Digia Plc and its Subsidiary(-ies) nor the names\n**     of its contributors may be used to endorse or promote products derived\n**     from this software without specific prior written permission.\n**\n**\n** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n** \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\"\n**\n** $QT_END_LICENSE$\n**\n****************************************************************************/\n\n#include <stdlib.h>\n#include <math.h>\n\n#include <QDateTime>\n#include <QDebug>\n#include <QPainter>\n#include <QVBoxLayout>\n#include <QAudioDeviceInfo>\n#include <QAudioInput>\n#include <qendian.h>\n\n#include \"audioinput.h\"\n\n#define PUSH_MODE_LABEL \"Enable push mode\"\n#define PULL_MODE_LABEL \"Enable pull mode\"\n#define SUSPEND_LABEL   \"Suspend recording\"\n#define RESUME_LABEL    \"Resume recording\"\n\nconst int BufferSize = 4096;\n\nAudioInfo::AudioInfo(const QAudioFormat &format, QObject *parent)\n\t:   QIODevice(parent)\n\t,   m_format(format)\n\t,   m_maxAmplitude(0)\n\t,   m_level(0.5)\n\n{\n\tswitch (m_format.sampleSize()) {\n\tcase 8:\n\t\tswitch (m_format.sampleType()) {\n\t\tcase QAudioFormat::UnSignedInt:\n\t\t\tm_maxAmplitude = 255;\n\t\t\tbreak;\n\t\tcase QAudioFormat::SignedInt:\n\t\t\tm_maxAmplitude = 127;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 16:\n\t\tswitch (m_format.sampleType()) {\n\t\tcase QAudioFormat::UnSignedInt:\n\t\t\tm_maxAmplitude = 65535;\n\t\t\tbreak;\n\t\tcase QAudioFormat::SignedInt:\n\t\t\tm_maxAmplitude = 32767;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase 32:\n\t\tswitch (m_format.sampleType()) {\n\t\tcase QAudioFormat::UnSignedInt:\n\t\t\tm_maxAmplitude = 0xffffffff;\n\t\t\tbreak;\n\t\tcase QAudioFormat::SignedInt:\n\t\t\tm_maxAmplitude = 0x7fffffff;\n\t\t\tbreak;\n\t\tcase QAudioFormat::Float:\n\t\t\tm_maxAmplitude = 0x7fffffff; // Kind of\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nAudioInfo::~AudioInfo()\n{\n}\n\nvoid AudioInfo::start()\n{\n\topen(QIODevice::WriteOnly);\n}\n\nvoid AudioInfo::stop()\n{\n\tclose();\n}\n\nqint64 AudioInfo::readData(char *data, qint64 maxlen)\n{\n\tQ_UNUSED(data)\n\tQ_UNUSED(maxlen)\n\n\treturn 0;\n}\n\nqint64 AudioInfo::writeData(const char *data, qint64 len)\n{\n\tif (m_maxAmplitude) {\n\t\tQ_ASSERT(m_format.sampleSize() % 8 == 0);\n\t\tconst int channelBytes = m_format.sampleSize() / 8;\n\t\tconst int sampleBytes = m_format.channelCount() * channelBytes;\n\t\tQ_ASSERT(len % sampleBytes == 0);\n\t\tconst int numSamples = len / sampleBytes;\n\n\t\tquint32 maxValue = 0;\n\t\tconst unsigned char *ptr = reinterpret_cast<const unsigned char *>(data);\n\n\t\tfor (int i = 0; i < numSamples; ++i) {\n\t\t\tfor (int j = 0; j < m_format.channelCount(); ++j) {\n\t\t\t\tquint32 value = 0;\n\n\t\t\t\tif (m_format.sampleSize() == 8 && m_format.sampleType() == QAudioFormat::UnSignedInt) {\n\t\t\t\t\tvalue = *reinterpret_cast<const quint8*>(ptr);\n\t\t\t\t}\n\t\t\t\telse if (m_format.sampleSize() == 8 && m_format.sampleType() == QAudioFormat::SignedInt) {\n\t\t\t\t\tvalue = qAbs(*reinterpret_cast<const qint8*>(ptr));\n\t\t\t\t}\n\t\t\t\telse if (m_format.sampleSize() == 16 && m_format.sampleType() == QAudioFormat::UnSignedInt) {\n\t\t\t\t\tif (m_format.byteOrder() == QAudioFormat::LittleEndian)\n\t\t\t\t\t\tvalue = qFromLittleEndian<quint16>(ptr);\n\t\t\t\t\telse\n\t\t\t\t\t\tvalue = qFromBigEndian<quint16>(ptr);\n\t\t\t\t}\n\t\t\t\telse if (m_format.sampleSize() == 16 && m_format.sampleType() == QAudioFormat::SignedInt) {\n\t\t\t\t\tif (m_format.byteOrder() == QAudioFormat::LittleEndian)\n\t\t\t\t\t\tvalue = qAbs(qFromLittleEndian<qint16>(ptr));\n\t\t\t\t\telse\n\t\t\t\t\t\tvalue = qAbs(qFromBigEndian<qint16>(ptr));\n\t\t\t\t}\n\t\t\t\telse if (m_format.sampleSize() == 32 && m_format.sampleType() == QAudioFormat::UnSignedInt) {\n\t\t\t\t\tif (m_format.byteOrder() == QAudioFormat::LittleEndian)\n\t\t\t\t\t\tvalue = qFromLittleEndian<quint32>(ptr);\n\t\t\t\t\telse\n\t\t\t\t\t\tvalue = qFromBigEndian<quint32>(ptr);\n\t\t\t\t}\n\t\t\t\telse if (m_format.sampleSize() == 32 && m_format.sampleType() == QAudioFormat::SignedInt) {\n\t\t\t\t\tif (m_format.byteOrder() == QAudioFormat::LittleEndian)\n\t\t\t\t\t\tvalue = qAbs(qFromLittleEndian<qint32>(ptr));\n\t\t\t\t\telse\n\t\t\t\t\t\tvalue = qAbs(qFromBigEndian<qint32>(ptr));\n\t\t\t\t}\n\t\t\t\telse if (m_format.sampleSize() == 32 && m_format.sampleType() == QAudioFormat::Float) {\n\t\t\t\t\tvalue = qAbs(*reinterpret_cast<const float*>(ptr) * 0x7fffffff); // assumes 0-1.0\n\t\t\t\t}\n\n\t\t\t\tmaxValue = qMax(value, maxValue);\n\t\t\t\tptr += channelBytes;\n\t\t\t}\n\t\t}\n\n\t\tmaxValue = qMin(maxValue, m_maxAmplitude);\n\t\tm_level = qreal(maxValue) / m_maxAmplitude;\n\t}\n\n\temit update();\n\treturn len;\n}\n", "name": "tests/SoundTest/audioinput.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/****************************************************************************\n**\n** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).\n** Contact: http://www.qt-project.org/legal\n**\n** This file is part of the examples of the Qt Toolkit.\n**\n** $QT_BEGIN_LICENSE:BSD$\n** You may use this file under the terms of the BSD license as follows:\n**\n** \"Redistribution and use in source and binary forms, with or without\n** modification, are permitted provided that the following conditions are\n** met:\n**   * Redistributions of source code must retain the above copyright\n**     notice, this list of conditions and the following disclaimer.\n**   * Redistributions in binary form must reproduce the above copyright\n**     notice, this list of conditions and the following disclaimer in\n**     the documentation and/or other materials provided with the\n**     distribution.\n**   * Neither the name of Digia Plc and its Subsidiary(-ies) nor the names\n**     of its contributors may be used to endorse or promote products derived\n**     from this software without specific prior written permission.\n**\n**\n** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n** \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\"\n**\n** $QT_END_LICENSE$\n**\n****************************************************************************/\n\n#ifndef AUDIOINPUT_H\n#define AUDIOINPUT_H\n\n#include <QAudioInput>\n#include <QByteArray>\n#include <QComboBox>\n#include <QMainWindow>\n#include <QObject>\n#include <QPixmap>\n#include <QPushButton>\n#include <QSlider>\n#include <QWidget>\n\nclass AudioInfo : public QIODevice\n{\n\tQ_OBJECT\n\npublic:\n\tAudioInfo(const QAudioFormat &format, QObject *parent);\n\t~AudioInfo();\n\n\tvoid start();\n\tvoid stop();\n\n\tqreal level() const {\n\t\treturn m_level;\n\t}\n\n\tqint64 readData(char *data, qint64 maxlen);\n\tqint64 writeData(const char *data, qint64 len);\n\nprivate:\n\tconst QAudioFormat m_format;\n\tquint32 m_maxAmplitude;\n\tqreal m_level; // 0.0 <= m_level <= 1.0\n\nsignals:\n\tvoid update();\n};\n\n\n\n#endif // AUDIOINPUT_H\n", "name": "tests/SoundTest/audioinput.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/****************************************************************************\n**\n** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).\n** Contact: http://www.qt-project.org/legal\n**\n** This file is part of the examples of the Qt Toolkit.\n**\n** $QT_BEGIN_LICENSE:BSD$\n** You may use this file under the terms of the BSD license as follows:\n**\n** \"Redistribution and use in source and binary forms, with or without\n** modification, are permitted provided that the following conditions are\n** met:\n**   * Redistributions of source code must retain the above copyright\n**     notice, this list of conditions and the following disclaimer.\n**   * Redistributions in binary form must reproduce the above copyright\n**     notice, this list of conditions and the following disclaimer in\n**     the documentation and/or other materials provided with the\n**     distribution.\n**   * Neither the name of Digia Plc and its Subsidiary(-ies) nor the names\n**     of its contributors may be used to endorse or promote products derived\n**     from this software without specific prior written permission.\n**\n**\n** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n** \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\"\n**\n** $QT_END_LICENSE$\n**\n****************************************************************************/\n\n#include \"generator.h\"\n\n#include <QAudioDeviceInfo>\n#include <QAudioOutput>\n#include <qmath.h>\n#include <qendian.h>\n\n#include \"PhTools/PhDebug.h\"\n\nconst int DurationSeconds = 1;\nconst int ToneSampleRateHz = 16500;\nconst int DataSampleRateHz = 44100;\nconst int BufferSize      = 32768;\n\n\nGenerator::Generator(const QAudioFormat &format,\n                     qint64 durationUs,\n                     int sampleRate,\n                     QObject *parent)\n\t:   QIODevice(parent)\n\t,   m_pos(0)\n{\n\tgenerateData(format, durationUs, sampleRate);\n}\n\nGenerator::~Generator()\n{\n\n}\n\nvoid Generator::start()\n{\n\topen(QIODevice::ReadOnly);\n}\n\nvoid Generator::stop()\n{\n\tm_pos = 0;\n\tclose();\n}\n\nvoid Generator::generateData(const QAudioFormat &format, qint64 durationUs, int sampleRate)\n{\n\tconst int channelBytes = format.sampleSize() / 8;\n\n\tqint64 length = (format.sampleRate() * format.channelCount() * (format.sampleSize() / 8))\n\t                * durationUs / 1000000;\n\n\tm_buffer.resize(length);\n\tunsigned char *ptr = reinterpret_cast<unsigned char *>(m_buffer.data());\n\tint sampleIndex = 0;\n\n\tPHDBG() << \"Type :\" << format.sampleType() << \" Size : \" << format.sampleSize() << \" Channel Count : \" << format.channelCount();\n\n\twhile (length) {\n\t\tconst qreal x = qSin(2 * M_PI * sampleRate * qreal(sampleIndex % format.sampleRate()) / format.sampleRate());\n\t\tfor (int i = 0; i < format.channelCount(); ++i) {\n\t\t\tqint16 value = static_cast<qint16>(x * 32767);\n\t\t\tqToLittleEndian<qint16>(value, ptr);\n\n\t\t\tptr += channelBytes;\n\t\t\tlength -= channelBytes;\n\t\t}\n\t\t++sampleIndex;\n\t}\n}\n\nqint64 Generator::readData(char *data, qint64 len)\n{\n\tqint64 total = 0;\n\twhile (len - total > 0) {\n\t\tconst qint64 chunk = qMin((m_buffer.size() - m_pos), len - total);\n\t\tmemcpy(data + total, m_buffer.constData() + m_pos, chunk);\n\t\tm_pos = (m_pos + chunk) % m_buffer.size();\n\t\ttotal += chunk;\n\t}\n\treturn total;\n}\n\nqint64 Generator::writeData(const char *data, qint64 len)\n{\n\tQ_UNUSED(data);\n\tQ_UNUSED(len);\n\n\treturn 0;\n}\n\nqint64 Generator::bytesAvailable() const\n{\n\treturn m_buffer.size() + QIODevice::bytesAvailable();\n}\n", "name": "tests/SoundTest/generator.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/****************************************************************************\n**\n** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).\n** Contact: http://www.qt-project.org/legal\n**\n** This file is part of the examples of the Qt Toolkit.\n**\n** $QT_BEGIN_LICENSE:BSD$\n** You may use this file under the terms of the BSD license as follows:\n**\n** \"Redistribution and use in source and binary forms, with or without\n** modification, are permitted provided that the following conditions are\n** met:\n**   * Redistributions of source code must retain the above copyright\n**     notice, this list of conditions and the following disclaimer.\n**   * Redistributions in binary form must reproduce the above copyright\n**     notice, this list of conditions and the following disclaimer in\n**     the documentation and/or other materials provided with the\n**     distribution.\n**   * Neither the name of Digia Plc and its Subsidiary(-ies) nor the names\n**     of its contributors may be used to endorse or promote products derived\n**     from this software without specific prior written permission.\n**\n**\n** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n** \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\"\n**\n** $QT_END_LICENSE$\n**\n****************************************************************************/\n\n#ifndef GENERATOR_H\n#define GENERATOR_H\n\n\n#include <QAudioOutput>\n#include <QByteArray>\n#include <QIODevice>\n#include <QObject>\n\n\nclass Generator : public QIODevice\n{\n\tQ_OBJECT\n\npublic:\n\tGenerator(const QAudioFormat &format, qint64 durationUs, int sampleRate, QObject *parent);\n\t~Generator();\n\n\tvoid start();\n\tvoid stop();\n\n\tqint64 readData(char *data, qint64 maxlen);\n\tqint64 writeData(const char *data, qint64 len);\n\tqint64 bytesAvailable() const;\n\n\tvoid generateData(const QAudioFormat &format, qint64 durationUs, int sampleRate);\n\nprivate:\n\tqint64 m_pos;\n\tQByteArray m_buffer;\n};\n#endif // GENERATOR_H\n", "name": "tests/SoundTest/generator.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include <QApplication>\n#include <QObject>\n#include <QIODevice>\n\n#include \"PhTools/PhDebug.h\"\n\n#include \"generator.h\"\n#include \"audioinput.h\"\n\nconst int DurationSeconds = 1;\nconst int ToneSampleRateHz = 50;\nconst int DataSampleRateHz = 48000;\nconst int BufferSize      = 32768 * 2;\n\n\n/**\n * @brief The application main entry point\n * @param argc Command line argument count\n * @param argv Command line argument list\n * @return 0 if the application works well.\n */\nint main(int argc, char *argv[])\n{\n\tQApplication a(argc, argv);\n\n\tQAudioFormat m_format;\n\n#if 1 /* This part is for output testing*/\n\tQAudioDeviceInfo m_device = QAudioDeviceInfo::defaultOutputDevice();\n\n\n\tm_format.setSampleRate(DataSampleRateHz);\n\tm_format.setChannelCount(1);\n\tm_format.setSampleSize(16);\n\tm_format.setCodec(\"audio/pcm\");\n\tm_format.setByteOrder(QAudioFormat::LittleEndian);\n\tm_format.setSampleType(QAudioFormat::SignedInt);\n\n\n\tQAudioOutput *m_audioOutput = new QAudioOutput(m_device, m_format);\n\tGenerator * m_generator = new Generator(m_format, DurationSeconds*1000000, ToneSampleRateHz, NULL);\n\n\tQTime time = QTime::currentTime();\n\tqsrand((uint)time.msec());\n\n\tint high = 10000;\n\tint low = 100;\n\n\tm_generator->start();\n\tm_audioOutput->start(m_generator);\n\twhile (true) {\n\t\tint freq = qrand() % ((high + 1) - low) + low;;\n\t\tm_audioOutput->stop();\n\t\tm_generator->generateData(m_format, DurationSeconds * 1000000, freq);\n\t\tm_audioOutput->start(m_generator);\n\t\t//sleep(1);\n\n\t}\n\t//    m_generator->stop();\n\n#else\n\n\tAudioInfo *m_audioInfo = new AudioInfo(m_format, NULL);\n\tQAudioInput *m_audioInput;\n\tQAudioDeviceInfo m_device = QAudioDeviceInfo::defaultInputDevice();\n\n\n\tQIODevice *m_input = 0;\n\tQByteArray m_buffer(BufferSize, 0);\n\n\n\tm_format.setSampleRate(48000);\n\tm_format.setChannelCount(1);\n\tm_format.setSampleSize(8);\n\tm_format.setSampleType(QAudioFormat::SignedInt);\n\tm_format.setByteOrder(QAudioFormat::LittleEndian);\n\tm_format.setCodec(\"audio/pcm\");\n\n\tQList<QAudioDeviceInfo> list = QAudioDeviceInfo::availableDevices(QAudio::AudioInput);\n\n\tQAudioDeviceInfo info;\n\tforeach(QAudioDeviceInfo input, list)\n\t{\n\t\tif(input.deviceName() == \"Built-in Input\")\n\t\t\tinfo = input;\n\t}\n\n\tif(info.isNull()) {\n\t\tPHDEBUG << \"Error with input\";\n\t\treturn 1;\n\t}\n\n\tif (!info.isFormatSupported(m_format)) {\n\t\tqWarning() << \"Default format not supported - trying to use nearest\";\n\t\tm_format = info.nearestFormat(m_format);\n\t}\n\n\tm_audioInfo  = new AudioInfo(m_format, NULL);\n\tm_audioInput = new QAudioInput(m_device, m_format, NULL);\n\n\tPHDEBUG << m_audioInfo->level();\n\n\tm_audioInfo->start();\n\tm_input = m_audioInput->start();\n\n\tqint64 procUSecs = 0;\n\t// Stop after 10 seconds\n\twhile(m_audioInput->elapsedUSecs() / 1000000 < 10) {\n\t\tqint64 len = m_audioInput->bytesReady();\n\t\tif (len > BufferSize)\n\t\t\tlen = BufferSize;\n\t\tqint64 l = m_input->read(m_buffer.data(), len);\n\t\tif (l > 0)\n\t\t\tm_audioInfo->write(m_buffer.constData(), l);\n\t\t//        if (procUSecs != m_audioInput->processedUSecs())\n//        {\n//            qWarning() << \"bytesReady = \" << m_audioInput->bytesReady()\n//                       << \", \" << \"elapsedUSecs = \" <<m_audioInput->elapsedUSecs()\n//                       << \", \" << \"processedUSecs = \"<<m_audioInput->processedUSecs();\n//            procUSecs = m_audioInput->processedUSecs();\n//        }\n\t}\n\n#endif\n\n\treturn 0;\n}\n", "name": "tests/SoundTest/main.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include <QDebug>\n\n#include <QFileInfo>\n\n#include \"PhStrip/PhStripDoc.h\"\n\n#include \"StripTestSettings.h\"\n\nusing namespace std;\n\nPhStripDoc * openDoc(QString fileName)\n{\n\tPhStripDoc * doc = new PhStripDoc();\n\tif(doc->openStripFile(fileName)) {\n\t\tif(doc->title().length() == 0)\n\t\t\tdoc->setTitle(QFileInfo(fileName).baseName());\n\t}\n\telse {\n\t\tdelete doc;\n\t\tdoc = NULL;\n\t}\n\treturn doc;\n}\n\nint computeLoopLength(PhStripDoc *doc, int loopNumber)\n{\n\tPhTime timeIn = PHTIMEMIN;\n\tPhTime timeOut = PHTIMEMAX;\n\tif(loopNumber > 0)\n\t\ttimeIn = doc->loops()[loopNumber - 1]->timeIn();\n\tif(loopNumber + 1 < doc->loops().count())\n\t\ttimeOut = doc->loops()[loopNumber]->timeIn();\n\treturn timeOut - timeIn;\n}\n\nint countLoopDetectLength(PhStripDoc *doc, int loopNumber)\n{\n\tQMap<QString, int> map;\n\t/// Compute in and out\n\tPhTime timeIn = PHTIMEMIN;\n\tPhTime timeOut = PHTIMEMAX;\n\tif(loopNumber > 0)\n\t\ttimeIn = doc->loops()[loopNumber - 1]->timeIn();\n\tif(loopNumber + 1 < doc->loops().count())\n\t\ttimeOut = doc->loops()[loopNumber]->timeIn();\n\n\tint loopLength = 0;\n\tforeach(PhStripDetect *detect, doc->detects(timeIn, timeOut)) {\n\t\tint detectLength = detect->timeOut() - detect->timeIn();\n\t\tif(detectLength == 0)\n\t\t\tPHDEBUG << \"ZEROR\";\n\t\tmap[detect->people()->name()] += detectLength;\n\t\tloopLength += detectLength;\n\t\tPHDBG(2) << PHNQ(PhTimeCode::stringFromTime(detect->timeIn(), doc->timeCodeType()))\n\t\t         << PHNQ(PhTimeCode::stringFromTime(detect->timeOut(), doc->timeCodeType()))\n\t\t         << PHNQ(PhTimeCode::stringFromTime(loopLength, doc->timeCodeType()))\n\t\t         << detectLength\n\t\t         << detect->people()->name();\n\t}\n\n\tforeach(QString name, map.keys())\n\tPHDBG(1) << PHNQ(name) << \":\\t\" << PHNQ(PhTimeCode::stringFromTime(map[name], doc->timeCodeType()));\n\n\treturn loopLength;\n}\n\nint displayDetectCountPerLoop(PhStripDoc *doc)\n{\n\tint totalLength = 0;\n\tPHDBG(3) << doc->title();\n\n\tfor(int loop = 0; loop <= doc->loops().count(); loop++) {\n\t\tint detectLength = countLoopDetectLength(doc, loop);\n\t\tint loopLength = computeLoopLength(doc, loop);\n\t\t//\t\t\t\tPHDEBUG << loop << \"\\t:\" << PHNQ(PhTimeCode::stringFromTime(loopLength, doc->getTCType()));\n\t\tPHDBG(3) << loop << \"\\t:\" << detectLength << \"\\t\" << loopLength << \"\\t\" << detectLength * 100 / loopLength;\n\t\ttotalLength += detectLength;\n\t}\n\treturn totalLength;\n}\n\nint countDetectLength(PhStripDoc *doc)\n{\n\tQMap<QString, int> map;\n\n\tPHDBG(1) << PHNQ(doc->title());\n\n\tint fileLength = 0;\n\n\tforeach(PhPeople *people, doc->peoples()) {\n\t\tint length = 0;\n\t\tforeach(PhStripDetect *detect, doc->peopleDetects(people)) {\n\t\t\tint detectLength = detect->timeOut() - detect->timeIn();\n\t\t\tlength += detectLength;\n\t\t\tPHDBG(2) << PHNQ(PhTimeCode::stringFromTime(detect->timeIn(), doc->timeCodeType()))\n\t\t\t         << PHNQ(PhTimeCode::stringFromTime(detect->timeOut(), doc->timeCodeType()))\n\t\t\t         << PHNQ(PhTimeCode::stringFromTime(length, doc->timeCodeType()))\n\t\t\t         << detectLength\n\t\t\t         << people->name();\n\t\t}\n\t\tmap[people->name()] += length;\n\t\tfileLength += length;\n\t}\n\n\tPHDBG(1);\n\n\tforeach(QString name, map.keys()) {\n\t\tPHDBG(1) << PHNQ(name) << \":\\t\" << PHNQ(PhTimeCode::stringFromTime(map[name], PhTimeCodeType25));\n\t}\n\n\treturn fileLength;\n}\n\nvoid displayDoc(PhStripDoc* doc)\n{\n\tPHDEBUG << doc->title();\n\tforeach(PhPeople *people, doc->peoples()) {\n\t\tPHDEBUG << people->name();\n\t}\n\n\tforeach(PhStripText *text, doc->texts()) {\n\t\tQString name = \"???\";\n\t\tif(text->people())\n\t\t\tname = text->people()->name();\n\t\tPHDEBUG << text->track() << \"-\"\n\t\t        << name << \":\"\n\t\t        << PhTimeCode::stringFromTime(text->timeIn(), doc->timeCodeType())\n\t\t        << \" -> \"\n\t\t        << PhTimeCode::stringFromTime(text->timeOut(), doc->timeCodeType())\n\t\t        << text->content();\n\t}\n\n\tforeach(PhStripText *text, doc->texts(true)) {\n\t\tQString name = \"???\";\n\t\tif(text->people())\n\t\t\tname = text->people()->name();\n\t\tPHDEBUG << text->track() <<\"-\"\n\t\t        << name << \":\"\n\t\t        << PhTimeCode::stringFromTime(text->timeIn(), doc->timeCodeType())\n\t\t        << \" -> \"\n\t\t        << PhTimeCode::stringFromTime(text->timeOut(), doc->timeCodeType())\n\t\t        << text->content();\n\t}\n\n\tforeach(PhStripDetect *detect, doc->detects()) {\n\t\tQString name = \"???\";\n\t\tif(detect->people())\n\t\t\tname = detect->people()->name();\n\t\tPHDEBUG << detect->track()<< \"-\"\n\t\t        << name << \":\"\n\t\t        << PhTimeCode::stringFromTime(detect->timeIn(), doc->timeCodeType())\n\t\t        << \" -> \"\n\t\t        << PhTimeCode::stringFromTime(detect->timeOut(), doc->timeCodeType())\n\t\t        << \"type:\" << detect->type();\n\t}\n}\n\n/**\n * @brief The application main entry point\n * @param argc Command line argument count\n * @param argv Command line argument list\n * @return 0 if the application works well.\n */\nint main(int argc, char *argv[])\n{\n\tStripTestSettings settings;\n\tPhDebug::setDisplay(false, false, false, false, false);\n\tPhDebug::setLogMask(settings.logMask());\n\n\tint result = 0;\n\n\tPhStripDoc doc;\n\tfor(int i = 1; i < argc; i++) {\n\t\tQString fileName = QLatin1String(argv[i]);\n\t\tif(QFile::exists(fileName)) {\n\t\t\tif(doc.openStripFile(fileName)) {\n\t\t\t\tdisplayDoc(&doc);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult = 1;\n\t\t\t\tPHDEBUG << \"-------- FAILED --------\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n", "name": "tests/StripTest/main.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef STRIPTESTSETTINGS_H\n#define STRIPTESTSETTINGS_H\n\n#include \"PhTools/PhGenericSettings.h\"\n\nclass StripTestSettings : protected PhGenericSettings\n{\npublic:\n\tPH_SETTING_INT2(setLogMask, logMask, 1);\n};\n\n#endif // STRIPTESTSETTINGS_H\n", "name": "tests/StripTest/StripTestSettings.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include \"TextEditTestWindow.h\"\n#include <QApplication>\n\n#include \"PhTools/PhDebug.h\"\n\nint main(int argc, char *argv[])\n{\n\tTextEditTestSettings settings;\n\n\tQApplication a(argc, argv);\n\n\tTextEditTestWindow w(&settings);\n\tw.processArg(argc, argv);\n\tw.show();\n\n\treturn a.exec();\n}\n", "name": "tests/TextEditTest/main.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef TEXTEDITTESTSETTINGS_H\n#define TEXTEDITTESTSETTINGS_H\n\n#include <QDir>\n\n#include \"PhTools/PhGenericSettings.h\"\n#include \"PhCommonUI/PhDocumentWindowSettings.h\"\n\nclass TextEditTestSettings : protected PhGenericSettings, public PhDocumentWindowSettings\n{\npublic:\n\t// PhWindowSettings\n\tPH_SETTING_BOOL(setFullScreen, fullScreen)\n\tPH_SETTING_BYTEARRAY(setWindowGeometry, windowGeometry)\n\n\t// PhDocumentWindowSettings\n\tPH_SETTING_STRING(setCurrentDocument, currentDocument)\n\tPH_SETTING_STRING2(setLastDocumentFolder, lastDocumentFolder, QDir::homePath())\n\tPH_SETTING_STRINGLIST(setRecentDocumentList, recentDocumentList)\n\tPH_SETTING_INT2(setMaxRecentDocument, maxRecentDocument, 5)\n\tPH_SETTING_BOOL2(setAutoReload, autoReload, true)\n};\n\n#endif // TEXTEDITTESTSETTINGS_H\n", "name": "tests/TextEditTest/TextEditTestSettings.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include <QMessageBox>\n#include <QFileDialog>\n#include <QTextStream>\n\n#include <PhTools/PhDebug.h>\n\n#include \"TextEditTestWindow.h\"\n#include \"ui_TextEditTestWindow.h\"\n\nTextEditTestWindow::TextEditTestWindow(TextEditTestSettings *settings) :\n\tPhDocumentWindow(settings),\n\tui(new Ui::TextEditTestWindow),\n\t_settings(settings)\n{\n\tui->setupUi(this);\n}\n\nTextEditTestWindow::~TextEditTestWindow()\n{\n\tdelete ui;\n}\n\nbool TextEditTestWindow::openDocument(QString fileName)\n{\n\tPHDEBUG << fileName;\n\tQFile file(fileName);\n\tif(!file.open(QFile::ReadOnly))\n\t\treturn false;\n\n\tQTextStream ts(&file);\n\tui->textEdit->setText(ts.readAll());\n\n\tsetCurrentDocument(fileName);\n\treturn true;\n}\n\nQMenu *TextEditTestWindow::recentDocumentMenu()\n{\n\treturn ui->menuOpen_recent;\n}\n\nvoid TextEditTestWindow::on_actionOpen_triggered()\n{\n\tPHDEBUG << _settings->lastDocumentFolder();\n\tQString fileName = QFileDialog::getOpenFileName(this, \"Open a text file...\", _settings->lastDocumentFolder(), \"Text file (*.txt)\");\n\n\tif(QFile::exists(fileName)) {\n\t\tif(!openDocument(fileName))\n\t\t\tQMessageBox::critical(this, \"\", tr(\"Unable to open \") + fileName);\n\t}\n}\n\nvoid TextEditTestWindow::on_actionSave_triggered()\n{\n\n}\n\nvoid TextEditTestWindow::on_actionSave_as_triggered()\n{\n\n}\n\n", "name": "tests/TextEditTest/TextEditTestWindow.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef TEXTEDITTESTWINDOW_H\n#define TEXTEDITTESTWINDOW_H\n\n#include \"PhCommonUI/PhDocumentWindow.h\"\n\n#include \"TextEditTestSettings.h\"\n\nnamespace Ui {\nclass TextEditTestWindow;\n}\n\nclass TextEditTestWindow : public PhDocumentWindow\n{\n\tQ_OBJECT\n\npublic:\n\texplicit TextEditTestWindow(TextEditTestSettings *settings);\n\t~TextEditTestWindow();\n\nprotected:\n\tbool openDocument(QString fileName);\n\tQMenu *recentDocumentMenu();\n\tQAction *fullScreenAction() {\n\t\treturn NULL;\n\t}\n\nprivate slots:\n\tvoid on_actionOpen_triggered();\n\n\tvoid on_actionSave_triggered();\n\n\tvoid on_actionSave_as_triggered();\n\nprivate:\n\tUi::TextEditTestWindow *ui;\n\tTextEditTestSettings *_settings;\n};\n\n#endif // TEXTEDITTESTWINDOW_H\n", "name": "tests/TextEditTest/TextEditTestWindow.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include <QtGui>\n#include <QApplication>\n\n#include \"TimecodePlayerWindow.h\"\n\n/**\n * @brief The application main entry point\n * @param argc Command line argument count\n * @param argv Command line argument list\n * @return 0 if the application works well.\n */\nint main(int argc, char *argv[])\n{\n\tQApplication a(argc, argv);\n\tMainWindow w;\n\tw.show();\n\n\treturn a.exec();\n}\n", "name": "tests/TimecodePlayer/main.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include \"TimecodePlayerWindow.h\"\n#include \"ui_TimecodePlayerWindow.h\"\n\nMainWindow::MainWindow(QWidget *parent) :\n\tQMainWindow(parent), ui(new Ui::TimecodePlayerWindow)\n{\n\tui->setupUi(this);\n\t_clock = new PhClock(PhTimeCodeType25);\n\tui->mediaController->setMediaLength(7500);\n\tui->mediaController->setTCType(_clock->timeCodeType());\n\tui->mediaController->setFirstFrame(_clock->frame());\n\tui->mediaController->setClock(_clock);\n\n\t_timer = new QTimer();\n\tconnect(_timer, SIGNAL(timeout()), this, SLOT(updateFrame()));\n\t_timer->start(10);\n}\n\nMainWindow::~MainWindow()\n{\n\tdelete ui;\n}\n\nvoid MainWindow::updateFrame()\n{\n\t_clock->tick(100);\n}\n", "name": "tests/TimecodePlayer/TimecodePlayerWindow.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef MAINWINDOW_H\n#define MAINWINDOW_H\n\n#include <QMainWindow>\n#include <QTimer>\n\n#include \"PhCommonUI/PhMediaPanel.h\"\n#include \"PhTools/PhClock.h\"\n\nnamespace Ui {\nclass TimecodePlayerWindow;\n}\n\nclass MainWindow : public QMainWindow\n{\n\tQ_OBJECT\n\npublic:\n\n\texplicit MainWindow(QWidget *parent = 0);\n\t~MainWindow();\n\npublic slots:\n\n\tvoid updateFrame();\n\nprivate:\n\n\tUi::TimecodePlayerWindow *ui;\n\tQTimer *_timer;\n\tPhClock *_clock;\n\n};\n\n\n#endif // MAINWINDOW_H\n", "name": "tests/TimecodePlayer/TimecodePlayerWindow.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/**\n * Copyright (C) 2012-2014 Phonations\n * License: http://www.gnu.org/licenses/gpl.html GPL version 2 or higher\n */\n\n\n#include <QApplication>\n\n#include \"PhTools/PhDebug.h\"\n#include \"PhStrip/PhStripDoc.h\"\n\n#include \"VideoStripTestWindow.h\"\n\n/**\n * @brief The application main entry point\n * @param argc Command line argument count\n * @param argv Command line argument list\n * @return 0 if the application works well.\n */\nint main(int argc, char *argv[])\n{\n\tQApplication a(argc, argv);\n\n\tVideoStripTestSettings settings;\n\tVideoStripTestWindow w(&settings);\n\n\tw.processArg(argc, argv);\n\tw.show();\n\n\treturn a.exec();\n}\n", "name": "tests/VideoStripTest/main.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include \"PhTools/PhDebug.h\"\n#include \"VideoStripSynchronizer.h\"\n\nVideoStripSynchronizer::VideoStripSynchronizer() : _stripClock(NULL), _videoClock(NULL)\n{\n}\n\nvoid VideoStripSynchronizer::setStripClock(PhClock *clock)\n{\n\t_stripClock = clock;\n\tconnect(_stripClock, SIGNAL(frameChanged(PhFrame, PhTimeCodeType)), this, SLOT(onStripFrameChanged(PhFrame, PhTimeCodeType)));\n\tconnect(_stripClock, SIGNAL(rateChanged(PhRate)), this, SLOT(onStripRateChanged(PhRate)));\n}\n\nvoid VideoStripSynchronizer::setVideoClock(PhClock *clock)\n{\n\t_videoClock = clock;\n\tconnect(_videoClock, SIGNAL(frameChanged(PhFrame, PhTimeCodeType)), this, SLOT(onVideoFrameChanged(PhFrame, PhTimeCodeType)));\n\tconnect(_videoClock, SIGNAL(rateChanged(PhRate)), this, SLOT(onVideoRateChanged(PhRate)));\n}\n\nvoid VideoStripSynchronizer::onStripFrameChanged(PhFrame frame, PhTimeCodeType tcType)\n{\n\t_videoClock->setFrame(frame);\n}\n\nvoid VideoStripSynchronizer::onStripRateChanged(PhRate rate)\n{\n\t//_videoClock->setRate(rate);\n}\n\nvoid VideoStripSynchronizer::onVideoFrameChanged(PhFrame frame, PhTimeCodeType tcType)\n{\n\tif(_stripClock->frame() != frame)\n\t\tPHDEBUG << \"error :\" << _stripClock->frame() << frame;\n#warning TODO handle frame difference error\n}\n\nvoid VideoStripSynchronizer::onVideoRateChanged(PhRate rate)\n{\n\t_stripClock->setRate(rate);\n}\n", "name": "tests/VideoStripTest/VideoStripSynchronizer.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef VIDEOSTRIPSYNCHRONIZER_H\n#define VIDEOSTRIPSYNCHRONIZER_H\n\n#include <QObject>\n\n#include \"PhTools/PhClock.h\"\n\nclass VideoStripSynchronizer : public QObject\n{\n\tQ_OBJECT\npublic:\n\tVideoStripSynchronizer();\n\n\tvoid setStripClock(PhClock *clock);\n\tvoid setVideoClock(PhClock *clock);\n\nprivate slots:\n\tvoid onStripFrameChanged(PhFrame frame, PhTimeCodeType tcType);\n\tvoid onStripRateChanged(PhRate rate);\n\tvoid onVideoFrameChanged(PhFrame frame, PhTimeCodeType tcType);\n\tvoid onVideoRateChanged(PhRate rate);\nprivate:\n\tPhClock * _stripClock;\n\tPhClock * _videoClock;\n};\n\n#endif // VIDEOSTRIPSYNCHRONIZER_H\n", "name": "tests/VideoStripTest/VideoStripSynchronizer.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef VIDEOSTRIPTESTSETTINGS_H\n#define VIDEOSTRIPTESTSETTINGS_H\n\n#include <QDir>\n\n#include \"PhTools/PhGenericSettings.h\"\n#include \"PhGraphicStrip/PhGraphicStripSettings.h\"\n#include \"PhVideo/PhVideoSettings.h\"\n#include \"PhCommonUI/PhDocumentWindowSettings.h\"\n\nclass VideoStripTestSettings : PhGenericSettings,\n\tpublic PhGraphicStripSettings,\n\tpublic PhVideoSettings,\n\tpublic PhDocumentWindowSettings\n{\npublic:\n\tPH_SETTING_INT(setScreenDelay, screenDelay)\n\n\t// PhGraphicSettings\n\tPH_SETTING_BOOL(setDisplayInfo, displayInfo)\n\tPH_SETTING_BOOL(setResetInfo, resetInfo)\n\n\t// PhGraphicStripSettings :\n\tPH_SETTING_FLOAT2(setStripHeight, stripHeight, 0.25f)\n\tPH_SETTING_INT2(setHorizontalTimePerPixel, horizontalTimePerPixel, 80)\n\tPH_SETTING_INT2(setVerticalTimePerPixel, verticalTimePerPixel, 1000)\n\tPH_SETTING_STRING(setTextFontFile, textFontFile)\n\tPH_SETTING_INT2(setTextBoldness, textBoldness, 1)\n\tPH_SETTING_BOOL(setStripTestMode, stripTestMode)\n\tPH_SETTING_BOOL2(setDisplayNextText, displayNextText, true)\n\tPH_SETTING_BOOL(setInvertColor, invertColor)\n\tPH_SETTING_BOOL(setDisplayRuler, displayRuler)\n\tPH_SETTING_INT(setRulerTimeIn, rulerTimeIn)\n\tPH_SETTING_INT2(setTimeBetweenRuler, timeBetweenRuler, 48000)\n\n\t// PhVideoSettings :\n\n\t// PhWindowSettings\n\tPH_SETTING_BOOL(setFullScreen, fullScreen)\n\tPH_SETTING_BYTEARRAY(setWindowGeometry, windowGeometry)\n\n\t// PhDocumentWindowSettings\n\tPH_SETTING_STRING(setCurrentDocument, currentDocument)\n\tPH_SETTING_STRING2(setLastDocumentFolder, lastDocumentFolder, QDir::homePath())\n\tPH_SETTING_STRINGLIST(setRecentDocumentList, recentDocumentList)\n\tPH_SETTING_INT2(setMaxRecentDocument, maxRecentDocument, 10)\n\tPH_SETTING_BOOL2(setAutoReload, autoReload, true)\n\n\t// Other settings :\n\tPH_SETTING_STRING(setLastVideoFolder, lastVideoFolder)\n};\n\n#endif // VIDEOSTRIPTESTSETTINGS_H\n", "name": "tests/VideoStripTest/VideoStripTestSettings.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include \"VideoStripTestWindow.h\"\n#include \"ui_VideoStripTestWindow.h\"\n\n#include <QFileDialog>\n#include <QFontDialog>\n\n#include \"PhTools/PhDebug.h\"\n#include \"PhCommonUI/PhTimeCodeDialog.h\"\n\nVideoStripTestWindow::VideoStripTestWindow(VideoStripTestSettings *settings) :\n\tPhDocumentWindow(settings),\n\tui(new Ui::VideoStripTestWindow),\n\t_settings(settings)\n{\n\tui->setupUi(this);\n\t_strip = ui->videoStripView->strip();\n\t_videoEngine = ui->videoStripView->videoEngine();\n\n\t_strip->setSettings(_settings);\n\n\t_doc = _strip->doc();\n\n\t_synchronizer.setStripClock(_strip->clock());\n\n\t_synchronizer.setVideoClock(_videoEngine->clock());\n\n\tif(_settings->fullScreen()) {\n\t\tthis->connect(&_fullScreenTimer, SIGNAL(timeout()), this, SLOT(on_actionFull_screen_triggered()));\n\t\t_fullScreenTimer.start(1000);\n\t}\n}\n\nVideoStripTestWindow::~VideoStripTestWindow()\n{\n\t_settings->setFullScreen(this->windowState() == Qt::WindowFullScreen);\n\tdelete ui;\n}\n\nbool VideoStripTestWindow::openDocument(QString fileName)\n{\n\tPHDEBUG << \"openFile : \" << fileName;\n\tif(!_doc->openStripFile(fileName))\n\t\treturn false;\n\n\t_strip->clock()->setTimeCodeType(_doc->timeCodeType());\n\t_strip->clock()->setTime(_doc->lastTime());\n\tthis->setWindowTitle(fileName);\n\n\tQFileInfo fileInfo(_doc->videoFilePath());\n\tif (fileInfo.exists()) {\n\t\t_videoEngine->open(_doc->videoFilePath());\n\t\t_videoEngine->setFirstFrame(_doc->videoFrameIn());\n\t}\n\n\tsetCurrentDocument(fileName);\n\n\treturn true;\n}\n\nvoid VideoStripTestWindow::on_actionOpen_triggered()\n{\n\tQFileDialog dlg(this, \"Open...\", \"\", \"Rythmo files (*.detx *.strip)\");\n\tif(dlg.exec()) {\n\t\tQString fileName = dlg.selectedFiles()[0];\n\t\tif(!openDocument(fileName))\n\t\t\tQMessageBox::critical(this, \"Error\", \"Unable to open \" + fileName);\n\t}\n}\n\nvoid VideoStripTestWindow::on_actionPlay_pause_triggered()\n{\n\tif(_strip->clock()->rate() == 0.0)\n\t\t_strip->clock()->setRate(1.0);\n\n\telse\n\t\t_strip->clock()->setRate(0.0);\n}\n\nvoid VideoStripTestWindow::on_actionPlay_backward_triggered()\n{\n\t_strip->clock()->setRate(-1.0);\n}\n\nvoid VideoStripTestWindow::on_actionStep_forward_triggered()\n{\n\t_strip->clock()->setRate(0.0);\n\t_strip->clock()->setFrame(_strip->clock()->frame() + 1);\n}\n\nvoid VideoStripTestWindow::on_actionStep_backward_triggered()\n{\n\t_strip->clock()->setRate(0.0);\n\t_strip->clock()->setFrame(_strip->clock()->frame() - 1);\n}\n\nvoid VideoStripTestWindow::on_actionStep_time_forward_triggered()\n{\n\t_strip->clock()->setRate(0.0);\n\t_strip->clock()->setTime(_strip->clock()->time() + 1);\n}\n\nvoid VideoStripTestWindow::on_actionStep_time_backward_triggered()\n{\n\t_strip->clock()->setRate(0.0);\n\t_strip->clock()->setTime(_strip->clock()->time() - 1);\n}\n\nvoid VideoStripTestWindow::on_action_3_triggered()\n{\n\t_strip->clock()->setRate(-3.0);\n}\n\nvoid VideoStripTestWindow::on_action_1_triggered()\n{\n\t_strip->clock()->setRate(-1.0);\n}\n\nvoid VideoStripTestWindow::on_action_0_5_triggered()\n{\n\t_strip->clock()->setRate(-0.5);\n}\n\nvoid VideoStripTestWindow::on_action0_triggered()\n{\n\t_strip->clock()->setRate(0.0);\n}\n\nvoid VideoStripTestWindow::on_action0_5_triggered()\n{\n\t_strip->clock()->setRate(0.5);\n}\n\nvoid VideoStripTestWindow::on_action1_triggered()\n{\n\t_strip->clock()->setRate(1.0);\n}\n\nvoid VideoStripTestWindow::on_action3_triggered()\n{\n\t_strip->clock()->setRate(3.0);\n}\n\nvoid VideoStripTestWindow::on_actionGo_To_triggered()\n{\n\tPhTimeCodeDialog dlg(_strip->clock()->timeCodeType(), _strip->clock()->frame());\n\tif(dlg.exec() == QDialog::Accepted)\n\t\t_strip->clock()->setFrame(dlg.frame());\n}\n\nvoid VideoStripTestWindow::on_actionOpen_Video_triggered()\n{\n\tQString fileName = QFileDialog::getOpenFileName(this, tr(\"Open Movie\"), QDir::homePath());\n\topenVideoFile(fileName); // TODO: show error in case of error\n}\n\n\nbool VideoStripTestWindow::openVideoFile(QString videoFileName)\n{\n\tQFileInfo fileInfo(videoFileName);\n\tif (fileInfo.exists()) {\n\t\t_videoEngine->open(videoFileName);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nQMenu *VideoStripTestWindow::recentDocumentMenu()\n{\n\treturn ui->menuOpen_recent;\n}\n\nvoid VideoStripTestWindow::on_actionSet_Time_Code_triggered()\n{\n\tPhTimeCodeDialog dlg(_strip->clock()->timeCodeType(), _strip->clock()->frame());\n\tif(dlg.exec() == QDialog::Accepted)\n\t\t_videoEngine->setFirstFrame(dlg.frame());\n\n}\n\nvoid VideoStripTestWindow::on_actionChange_font_triggered()\n{\n\tQString fontFile = QFileDialog::getOpenFileName(this, \"Change font...\", \"\", \"Font files (*.ttf)\");\n\tif(QFile(fontFile).exists()) {\n\t\tif(!_strip->setFontFile(fontFile))\n\t\t\tQMessageBox::critical(this, \"Error\", \"Unable to open \" + fontFile);\n\t}\n}\n\n\nvoid VideoStripTestWindow::on_actionFull_screen_triggered()\n{\n\t_fullScreenTimer.stop();\n\tthis->setWindowState(Qt::WindowFullScreen);\n}\n\n\nvoid VideoStripTestWindow::on_actionTest_mode_triggered()\n{\n\t_settings->setStripTestMode(!_settings->stripTestMode());\n}\n", "name": "tests/VideoStripTest/VideoStripTestWindow.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef MAINWINDOW_H\n#define MAINWINDOW_H\n\n#include <QMessageBox>\n#include <QTimer>\n\n#include \"PhGraphicStrip/PhGraphicStrip.h\"\n#include \"PhVideo/PhVideoEngine.h\"\n#include \"PhStrip/PhStripDoc.h\"\n#include \"PhCommonUI/PhDocumentWindow.h\"\n\n#include \"VideoStripTestSettings.h\"\n#include \"VideoStripSynchronizer.h\"\n\nnamespace Ui {\nclass VideoStripTestWindow;\n}\n\nclass VideoStripTestWindow : public PhDocumentWindow\n{\n\tQ_OBJECT\n\npublic:\n\texplicit VideoStripTestWindow(VideoStripTestSettings * settings);\n\t~VideoStripTestWindow();\n\n\tbool openDocument(QString fileName);\n\n\tbool openVideoFile(QString videoFileName);\n\nprotected:\n\tQMenu *recentDocumentMenu();\n\tQAction *fullScreenAction() {\n\t\treturn NULL;\n\t}\n\nprivate slots:\n\tvoid on_actionOpen_triggered();\n\n\tvoid on_actionPlay_pause_triggered();\n\n\tvoid on_actionPlay_backward_triggered();\n\n\tvoid on_actionStep_forward_triggered();\n\n\tvoid on_actionStep_backward_triggered();\n\n\tvoid on_actionStep_time_forward_triggered();\n\n\tvoid on_actionStep_time_backward_triggered();\n\n\tvoid on_action_3_triggered();\n\n\tvoid on_action_1_triggered();\n\n\tvoid on_action_0_5_triggered();\n\n\tvoid on_action0_triggered();\n\n\tvoid on_action0_5_triggered();\n\n\tvoid on_action1_triggered();\n\n\tvoid on_action3_triggered();\n\n\tvoid on_actionGo_To_triggered();\n\n\tvoid on_actionOpen_Video_triggered();\n\n\tvoid on_actionSet_Time_Code_triggered();\n\n\tvoid on_actionChange_font_triggered();\n\n\tvoid on_actionFull_screen_triggered();\n\tvoid on_actionTest_mode_triggered();\n\nprivate:\n\tUi::VideoStripTestWindow *ui;\n\tPhGraphicStrip *_strip;\n\tPhStripDoc *_doc;\n\tPhVideoEngine * _videoEngine;\n\tVideoStripSynchronizer _synchronizer;\n\tVideoStripTestSettings * _settings;\n\tQTimer _fullScreenTimer;\n};\n\n#endif // MAINWINDOW_H\n", "name": "tests/VideoStripTest/VideoStripTestWindow.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include \"VideoStripView.h\"\n\nVideoStripView::VideoStripView(QWidget *parent) :\n\tPhGraphicView(parent)\n{\n}\n\nbool VideoStripView::init()\n{\n\tconnect(this, SIGNAL(beforePaint(PhTimeScale)), _strip.clock(), SLOT(tick(PhTimeScale)));\n\n\t_strip.init();\n}\n\nvoid VideoStripView::paint()\n{\n\tint videoHeight = this->height() * 3 / 4;\n\tint videoWidth = this->height();\n\tint videoX = (this->width() - videoWidth) / 2;\n\t_strip.draw(0, videoHeight, this->width(), this->height() - videoHeight);\n\t_videoEngine.drawVideo(videoX, 0, videoWidth, videoHeight);\n}\n", "name": "tests/VideoStripTest/VideoStripView.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef VIDEOSTRIPVIEW_H\n#define VIDEOSTRIPVIEW_H\n\n#include \"PhGraphic/PhGraphicView.h\"\n#include \"PhVideo/PhVideoEngine.h\"\n#include \"PhGraphicStrip/PhGraphicStrip.h\"\n\nclass VideoStripView : public PhGraphicView\n{\n\tQ_OBJECT\npublic:\n\texplicit VideoStripView(QWidget *parent = 0);\n\n\tPhVideoEngine * videoEngine() {\n\t\treturn &_videoEngine;\n\t}\n\tPhGraphicStrip * strip() {\n\t\treturn &_strip;\n\t}\nprotected:\n\tbool init();\n\tvoid paint();\n\nprivate:\n\tPhVideoEngine _videoEngine;\n\tPhGraphicStrip _strip;\n};\n\n#endif // VIDEOSTRIPVIEW_H\n", "name": "tests/VideoStripTest/VideoStripView.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include <QApplication>\n#include <QFile>\n\n#include \"VideoSyncTestWindow.h\"\n#include \"VideoSyncTestSettings.h\"\n\n/**\n * @brief The application main entry point\n * @param argc Command line argument count\n * @param argv Command line argument list\n * @return 0 if the application works well.\n */\nint main(int argc, char *argv[])\n{\n\tVideoSyncTestSettings settings;\n\tQApplication app(argc, argv);\n\n\tVideoSyncTestWindow w(&settings);\n\tw.processArg(argc, argv);\n\tw.show();\n\n\treturn app.exec();\n}\n", "name": "tests/VideoSyncTest/main.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef VIDEOSYNCTESTSETTINGS_H\n#define VIDEOSYNCTESTSETTINGS_H\n\n#include <QDir>\n\n#include \"PhTools/PhGenericSettings.h\"\n#include \"PhVideo/PhVideoSettings.h\"\n#include \"PhSync/PhSyncSettings.h\"\n#include \"PhCommonUI/PhDocumentWindowSettings.h\"\n\nclass VideoSyncTestSettings : PhGenericSettings,\n\tpublic PhVideoSettings,\n\tpublic PhSyncSettings,\n\tpublic PhDocumentWindowSettings\n{\npublic:\n\tPH_SETTING_INT(setScreenDelay, screenDelay)\n\n\tPH_SETTING_BOOL(setResetInfo, resetInfo)\n\n\t// PhVideoSettings :\n\n\t// PhSyncSettings:\n\tPH_SETTING_BOOL2(setVideoSyncUp, videoSyncUp, true)\n\tPH_SETTING_UCHAR2(setSonyDevice1, sonyDevice1, 0xF0)\n\tPH_SETTING_UCHAR2(setSonyDevice2, sonyDevice2, 0xC0)\n\tPH_SETTING_FLOAT2(setSonyFastRate, sonyFastRate, 3)\n\tPH_SETTING_STRING2(setSonySlavePortSuffix, sonySlavePortSuffix, \"A\")\n\tPH_SETTING_STRING2(setSonyMasterPortSuffix, sonyMasterPortSuffix, \"B\")\n\n\t// PhWindowSettings\n\tPH_SETTING_BOOL(setFullScreen, fullScreen)\n\tPH_SETTING_BYTEARRAY(setWindowGeometry, windowGeometry)\n\n\t// PhDocumentWindowSettings\n\tPH_SETTING_STRING(setCurrentDocument, currentDocument)\n\tPH_SETTING_STRING2(setLastDocumentFolder, lastDocumentFolder, QDir::homePath())\n\tPH_SETTING_STRINGLIST(setRecentDocumentList, recentDocumentList)\n\tPH_SETTING_INT2(setMaxRecentDocument, maxRecentDocument, 10)\n\tPH_SETTING_BOOL2(setAutoReload, autoReload, true)\n};\n\n#endif // VIDEOSYNCTESTSETTINGS_H\n", "name": "tests/VideoSyncTest/VideoSyncTestSettings.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include \"VideoSyncTestWindow.h\"\n#include \"ui_VideoSyncTestWindow.h\"\n\n#include <QPushButton>\n#include <QBoxLayout>\n#include <QFileInfo>\n#include <QFileDialog>\n\nVideoSyncTestWindow::VideoSyncTestWindow(VideoSyncTestSettings *settings)\n\t: PhDocumentWindow(settings),\n\tui(new Ui::VideoSyncTestWindow),\n\t_settings(settings)\n{\n\tui->setupUi(this);\n\t_videoEngine.setSettings(_settings);\n\tui->_videoView->setEngine(&_videoEngine);\n\n\tui->mediaController->setClock(_videoEngine.clock());\n\n\tconnect(ui->actionOpen, SIGNAL(triggered()), this, SLOT(onOpenFile()));\n}\n\n\nVideoSyncTestWindow::~VideoSyncTestWindow()\n{\n\tdelete ui;\n}\n\nbool VideoSyncTestWindow::openDocument(QString fileName)\n{\n\tif (_videoEngine.open(fileName)) {\n\t\tui->mediaController->setFirstFrame(_videoEngine.firstFrame());\n\t\tui->mediaController->setMediaLength(_videoEngine.length());\n\n\t\t_videoEngine.clock()->setRate(0.0);\n\n\t\tsetCurrentDocument(fileName);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nQMenu *VideoSyncTestWindow::recentDocumentMenu()\n{\n\tui->menuOpen_recent;\n}\n\nvoid VideoSyncTestWindow::onOpenFile()\n{\n\tQString fileName = QFileDialog::getOpenFileName(this, tr(\"Open Movie\"), QDir::homePath());\n\topenDocument(fileName);  // TODO: show error in case of error\n}\n\n\n", "name": "tests/VideoSyncTest/VideoSyncTestWindow.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef MAINVIEW_H\n#define MAINVIEW_H\n\n#include <QString>\n#include <QTimer>\n\n#include \"PhTools/PhClock.h\"\n#include \"PhVideo/PhVideoView.h\"\n#include \"PhCommonUI/PhMediaPanel.h\"\n#include \"PhCommonUI/PhDocumentWindow.h\"\n\n#include \"VideoSyncTestSettings.h\"\n\nnamespace Ui {\nclass VideoSyncTestWindow;\n}\n\nclass VideoSyncTestWindow : public PhDocumentWindow\n{\n\tQ_OBJECT\npublic:\n\t/**\n\t * @brief MainView constructor\n\t */\n\tVideoSyncTestWindow(VideoSyncTestSettings *settings);\n\t~VideoSyncTestWindow();\n\t/**\n\t * Open a video file.\n\t * @param fileName Path of the video file to open.\n\t * @return True if succeeds, false otherwise.\n\t */\n\tbool openDocument(QString fileName);\n\nprotected:\n\tQMenu *recentDocumentMenu();\n\tQAction *fullScreenAction() {\n\t\treturn NULL;\n\t}\n\nprivate slots:\n\n\tvoid onOpenFile();\nprivate:\n\tUi::VideoSyncTestWindow *ui;\n\tPhVideoEngine _videoEngine;\n\tVideoSyncTestSettings *_settings;\n};\n\n#endif\n", "name": "tests/VideoSyncTest/VideoSyncTestWindow.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include <QtWidgets/QApplication>\n#include <QFile>\n\n#include \"VideoTestWindow.h\"\n\n/**\n * @brief The application main entry point\n * @param argc Command line argument count\n * @param argv Command line argument list\n * @return 0 if the application works well.\n */\nint main(int argc, char *argv[])\n{\n\tPHDEBUG << \"=========== Starting VideoTest ==============\";\n\tQApplication app(argc, argv);\n\tVideoTestSettings settings;\n\tPhDebug::setLogMask(settings.logMask());\n\n\tVideoTestWindow w(&settings);\n\tw.processArg(argc, argv);\n\tw.show();\n\n\treturn app.exec();\n}\n", "name": "tests/VideoTest/main.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef VIDEOTESTSETTINGS_H\n#define VIDEOTESTSETTINGS_H\n\n#include <QApplication>\n#include <QDir>\n\n#include \"PhTools/PhGenericSettings.h\"\n#include \"PhGraphic/PhGraphicSettings.h\"\n#include \"PhVideo/PhVideoSettings.h\"\n#include \"PhCommonUI/PhDocumentWindowSettings.h\"\n\nclass VideoTestSettings : PhGenericSettings,\n\tpublic PhGraphicSettings,\n\tpublic PhVideoSettings,\n\tpublic PhDocumentWindowSettings\n{\npublic:\n\tPH_SETTING_INT(setScreenDelay, screenDelay)\n\tPH_SETTING_INT2(setLogMask, logMask, 1)\n\tPH_SETTING_BOOL2(setDisplayMediaPanel, displayMediaPanel, true)\n\tPH_SETTING_BOOL(setDeinterlaceVideo, deinterlaceVideo)\n\tPH_SETTING_INT(setFrameStamp, frameStamp)\n\tPH_SETTING_INT(setCurrentFrame, currentFrame)\n\n\t// PhGraphicSettings\n\tPH_SETTING_BOOL(setDisplayInfo, displayInfo)\n\tPH_SETTING_BOOL(setResetInfo, resetInfo)\n\n\t// PhVideoSettings :\n\n\t// PhWindowSettings\n\tPH_SETTING_BOOL(setFullScreen, fullScreen)\n\tPH_SETTING_BYTEARRAY(setWindowGeometry, windowGeometry)\n\n\t// PhDocumentWindowSettings\n\tPH_SETTING_STRING(setCurrentDocument, currentDocument)\n\tPH_SETTING_STRING2(setLastDocumentFolder, lastDocumentFolder, QDir::homePath())\n\tPH_SETTING_STRINGLIST(setRecentDocumentList, recentDocumentList)\n\tPH_SETTING_INT2(setMaxRecentDocument, maxRecentDocument, 10)\n\tPH_SETTING_BOOL2(setAutoReload, autoReload, true)\n};\n\n#endif // VIDEOTESTSETTINGS_H\n", "name": "tests/VideoTest/VideoTestSettings.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#include \"VideoTestWindow.h\"\n#include \"ui_VideoTestWindow.h\"\n\n#include <QPushButton>\n#include <QBoxLayout>\n#include <QFileInfo>\n#include <QFileDialog>\n#include <QMessageBox>\n\n#include \"PhCommonUI/PhTimeCodeDialog.h\"\n\nVideoTestWindow::VideoTestWindow(VideoTestSettings *settings)\n\t: PhDocumentWindow(settings),\n\tui(new Ui::VideoTestWindow),\n\t_settings(settings),\n\t_videoEngine(false)\n{\n\tui->setupUi(this);\n\t_videoEngine.setSettings(settings);\n\tui->_videoView->setGraphicSettings(settings);\n\n\t_mediaPanelDialog.setClock(_videoEngine.clock());\n\n\tui->actionDisplay_media_panel->setChecked(_settings->displayMediaPanel());\n\tui->actionDeinterlace_video->setChecked(_settings->deinterlaceVideo());\n\n\tui->_videoView->setEngine(&_videoEngine);\n\t_videoEngine.setDeinterlace(_settings->deinterlaceVideo());\n\n\tconnect(_videoEngine.clock(), SIGNAL(frameChanged(PhFrame, PhTimeCodeType)), this, SLOT(onFrameChanged(PhFrame, PhTimeCodeType)));\n}\n\nVideoTestWindow::~VideoTestWindow()\n{\n\tdelete ui;\n}\n\nbool VideoTestWindow::openDocument(QString fileName)\n{\n\tif(!_videoEngine.open(fileName))\n\t\treturn false;\n\n\t_mediaPanelDialog.setMediaLength(_videoEngine.length());\n\tPhFrame frameStamp = _videoEngine.firstFrame();\n\tPhFrame currentFrame = frameStamp;\n\n\tif(fileName == _settings->currentDocument()) {\n\t\tframeStamp = _settings->frameStamp();\n\t\t_videoEngine.setFirstFrame(frameStamp);\n\t\tcurrentFrame = _settings->currentFrame();\n\t}\n\telse if(_videoEngine.firstFrame() == 0) {\n\t\ton_actionSet_timestamp_triggered();\n\t\tframeStamp = _videoEngine.firstFrame();\n\t\tcurrentFrame = frameStamp;\n\t}\n\t_mediaPanelDialog.setFirstFrame(frameStamp);\n\n\t_videoEngine.clock()->setFrame(currentFrame);\n\n\tsetCurrentDocument(fileName);\n\t_settings->setFrameStamp(frameStamp);\n\n\treturn true;\n}\n\nvoid VideoTestWindow::processArg(int argc, char *argv[])\n{\n\tPhDocumentWindow::processArg(argc, argv);\n\tfor(int i = 1; i < argc; i++) {\n\t\tPhFrame firstFrame = PhTimeCode::frameFromString(argv[i], _videoEngine.clock()->timeCodeType());\n\t\tif(firstFrame) {\n\t\t\t_videoEngine.setFirstFrame(firstFrame);\n\t\t\t_videoEngine.clock()->setFrame(firstFrame);\n\t\t}\n\t}\n}\n\nvoid VideoTestWindow::resizeEvent(QResizeEvent *)\n{\n\tPHDEBUG << this->width() << this->height();\n\t_mediaPanelDialog.move(this->x() + this->width() / 2 - _mediaPanelDialog.width() / 2,\n\t                       this->y() + this->height() * 0.95 - _mediaPanelDialog.height());\n}\n\nvoid VideoTestWindow::closeEvent(QCloseEvent *)\n{\n\t_mediaPanelDialog.close();\n}\n\nQMenu *VideoTestWindow::recentDocumentMenu()\n{\n\treturn ui->menuOpen_recent;\n}\n\nvoid VideoTestWindow::onApplicationActivate()\n{\n\tif(_settings->displayMediaPanel())\n\t\t_mediaPanelDialog.show();\n}\n\nvoid VideoTestWindow::onApplicationDeactivate()\n{\n\t_mediaPanelDialog.hide();\n}\n\nvoid VideoTestWindow::on_actionPlay_pause_triggered()\n{\n\tif(_videoEngine.clock()->rate() != 0)\n\t\t_videoEngine.clock()->setRate(0);\n\telse\n\t\t_videoEngine.clock()->setRate(1);\n}\n\nvoid VideoTestWindow::on_actionNext_frame_triggered()\n{\n\t_videoEngine.clock()->setFrame(_videoEngine.clock()->frame() + 1);\n}\n\nvoid VideoTestWindow::on_actionPrevious_frame_triggered()\n{\n\t_videoEngine.clock()->setFrame(_videoEngine.clock()->frame() - 1);\n}\n\nvoid VideoTestWindow::on_actionSet_timestamp_triggered()\n{\n\t_mediaPanelDialog.hide();\n\tPhFrame frame;\n\tif(_videoEngine.clock()->frame() < _videoEngine.firstFrame())\n\t\tframe = _videoEngine.firstFrame();\n\telse if(_videoEngine.clock()->frame() > _videoEngine.firstFrame() + _videoEngine.length())\n\t\tframe = _videoEngine.lastFrame();\n\telse\n\t\tframe = _videoEngine.clock()->frame();\n\n\tPhTimeCodeDialog dlg(_videoEngine.clock()->timeCodeType(), frame);\n\tif(dlg.exec() == QDialog::Accepted) {\n\t\tPhFrame frameStamp;\n\t\tif(_videoEngine.clock()->frame() > _videoEngine.firstFrame() + _videoEngine.length())\n\t\t\tframeStamp = dlg.frame() - (_videoEngine.length() - 1);\n\t\telse if (_videoEngine.clock()->frame() < _videoEngine.firstFrame())\n\t\t\tframeStamp =  dlg.frame();\n\t\telse\n\t\t\tframeStamp = _videoEngine.firstFrame() + dlg.frame() - _videoEngine.clock()->frame();\n\n\t\t_videoEngine.setFirstFrame(frameStamp);\n\t\t_mediaPanelDialog.setFirstFrame(frameStamp);\n\t\t_videoEngine.clock()->setFrame(dlg.frame());\n\t\t_settings->setFrameStamp(frameStamp);\n\t}\n\n\tif(_settings->displayMediaPanel())\n\t\t_mediaPanelDialog.show();\n}\n\nvoid VideoTestWindow::on_actionOpen_triggered()\n{\n\t_mediaPanelDialog.hide();\n\tQString fileName = QFileDialog::getOpenFileName(this, tr(\"Open Movie\"), _settings->lastDocumentFolder());\n\tif(QFile::exists(fileName)) {\n\t\tif(!openDocument(fileName))\n\t\t\tQMessageBox::critical(this, \"Error\", \"Unable to open \" + fileName);\n\t}\n\n\tif(_settings->displayMediaPanel())\n\t\t_mediaPanelDialog.show();\n}\n\nvoid VideoTestWindow::on_actionReverse_triggered()\n{\n\t_videoEngine.clock()->setRate(-1);\n}\n\nvoid VideoTestWindow::on_actionGo_to_triggered()\n{\n\t_mediaPanelDialog.hide();\n\tPhTimeCodeDialog dlg(_videoEngine.clock()->timeCodeType(), _videoEngine.clock()->frame(), this);\n\n\tif(dlg.exec() == QDialog::Accepted) {\n\t\tPHDEBUG << PhTimeCode::stringFromFrame(dlg.frame(), _videoEngine.clock()->timeCodeType());\n\t\t_videoEngine.clock()->setFrame(dlg.frame());\n\t}\n\n\tif(_settings->displayMediaPanel())\n\t\t_mediaPanelDialog.show();\n}\n\nvoid VideoTestWindow::on_actionDisplay_media_panel_triggered(bool checked)\n{\n\t_settings->setDisplayMediaPanel(checked);\n\tif(checked)\n\t\t_mediaPanelDialog.show();\n\telse\n\t\t_mediaPanelDialog.hide();\n}\n\nvoid VideoTestWindow::on_actionDeinterlace_video_triggered(bool checked)\n{\n\t_settings->setDeinterlaceVideo(checked);\n\t_videoEngine.setDeinterlace(checked);\n}\n\nvoid VideoTestWindow::onFrameChanged(PhFrame frame, PhTimeCodeType tcType)\n{\n\t_settings->setCurrentFrame(frame);\n\tui->statusBar->showMessage(PhTimeCode::stringFromFrame(frame, tcType));\n\n}\n", "name": "tests/VideoTest/VideoTestWindow.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "#ifndef VIDEOTESTWINDOW_H\n#define VIDEOTESTWINDOW_H\n\n#include <QString>\n#include <QTimer>\n\n#include \"PhTools/PhClock.h\"\n#include \"PhTools/PhDebug.h\"\n\n#include \"PhVideo/PhVideoView.h\"\n#include \"PhVideo/PhVideoEngine.h\"\n\n#include \"PhCommonUI/PhFloatingMediaPanel.h\"\n#include \"PhCommonUI/PhDocumentWindow.h\"\n\n#include \"VideoTestSettings.h\"\n\nnamespace Ui {\nclass VideoTestWindow;\n}\n\nclass VideoTestWindow : public PhDocumentWindow\n{\n\tQ_OBJECT\npublic:\n\t/**\n\t * @brief MainView constructor\n\t */\n\tVideoTestWindow(VideoTestSettings *settings);\n\n\t~VideoTestWindow();\n\t/**\n\t * Open a video file.\n\t * @param fileName Path of the video file to open.\n\t * @return True if succeeds, false otherwise.\n\t */\n\tbool openDocument(QString fileName);\n\n\t/**\n\t * @brief Process the application argument\n\t *\n\t * Set the timestamp if provided in the argument\n\t *\n\t * @param argc The arguments count\n\t * @param argv The arguments values\n\t */\n\tvoid processArg(int argc, char *argv[]);\n\nprotected:\n\tvoid resizeEvent(QResizeEvent *);\n\tvoid closeEvent(QCloseEvent *);\n\n\tQMenu *recentDocumentMenu();\n\tQAction *fullScreenAction() {\n\t\treturn NULL;\n\t}\n\n\tvoid onApplicationActivate();\n\tvoid onApplicationDeactivate();\n\nprivate slots:\n\tvoid on_actionPlay_pause_triggered();\n\n\tvoid on_actionNext_frame_triggered();\n\n\tvoid on_actionPrevious_frame_triggered();\n\n\tvoid on_actionSet_timestamp_triggered();\n\n\tvoid on_actionOpen_triggered();\n\n\tvoid on_actionReverse_triggered();\n\n\tvoid on_actionGo_to_triggered();\n\n\tvoid on_actionDisplay_media_panel_triggered(bool checked);\n\n\tvoid on_actionDeinterlace_video_triggered(bool checked);\n\n\tvoid onFrameChanged(PhFrame frame, PhTimeCodeType tcType);\n\nprivate:\n\n\tUi::VideoTestWindow *ui;\n\tVideoTestSettings *_settings;\n\tPhVideoEngine _videoEngine;\n\tPhFloatingMediaPanel _mediaPanelDialog;\n};\n\n#endif\n", "name": "tests/VideoTest/VideoTestWindow.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/******************************\n* Qt player using libVLC     *\n* By protonux                *\n*                            *\n* Under WTFPL                *\n******************************/\n\n#include <QApplication>\n#include \"player.h\"\n\n#ifdef Q_WS_X11\n\t#include <X11/Xlib.h>\n#endif\n\n/**\n * @brief The application main entry point\n * @param argc Command line argument count\n * @param argv Command line argument list\n * @return 0 if the application works well.\n */\nint main(int argc, char *argv[]) {\n#ifdef Q_WS_X11\n\tXInitThreads();\n#endif\n\n\tQApplication app(argc, argv);\n\n\tMwindow player;\n\tplayer.show();\n\n\tif(argc > 1)\n\t\tplayer.openFile(argv[1]);\n\n\treturn app.exec();\n}\n", "name": "tests/VLCTest/main.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/******************************\n* Qt player using libVLC     *\n* By protonux                *\n*                            *\n* Under WTFPL                *\n******************************/\n\n#include \"player.h\"\n#include <vlc/vlc.h>\n\n#include <QMessageBox>\n#include <QMenu>\n#include <QMenuBar>\n#include <QHBoxLayout>\n#include <QFileDialog>\n\n#define qtu( i ) ((i).toUtf8().constData())\n\n#include <QtGui>\n\nMwindow::Mwindow() {\n\tvlcPlayer = NULL;\n\n\t/* Initialize libVLC */\n\tvlcInstance = libvlc_new(0, NULL);\n\n\t/* Complain in case of broken installation */\n\tif (vlcInstance == NULL) {\n\t\tQMessageBox::critical(this, \"Qt libVLC player\", \"Could not init libVLC\");\n\t\texit(1);\n\t}\n\n\t/* Interface initialization */\n\tinitUI();\n}\n\nMwindow::~Mwindow() {\n\t/* Release libVLC instance on quit */\n\tif (vlcInstance)\n\t\tlibvlc_release(vlcInstance);\n}\n\nvoid Mwindow::initUI() {\n\n\t/* Menu */\n\tQMenu *fileMenu = menuBar()->addMenu(\"&File\");\n\tQMenu *editMenu = menuBar()->addMenu(\"&Edit\");\n\n\tQAction *Open    = new QAction(\"&Open\", this);\n\tQAction *Quit    = new QAction(\"&Quit\", this);\n\tQAction *playAc  = new QAction(\"&Play/Pause\", this);\n\tQAction *fsAc  = new QAction(\"&Fullscreen\", this);\n\tQAction *aboutAc = new QAction(\"&About\", this);\n\n\tOpen->setShortcut(QKeySequence(\"Ctrl+O\"));\n\tQuit->setShortcut(QKeySequence(\"Ctrl+Q\"));\n\n\tfileMenu->addAction(Open);\n\tfileMenu->addAction(aboutAc);\n\tfileMenu->addAction(Quit);\n\teditMenu->addAction(playAc);\n\teditMenu->addAction(fsAc);\n\n\tconnect(Open,    SIGNAL(triggered()), this, SLOT(openFile()));\n\tconnect(playAc,  SIGNAL(triggered()), this, SLOT(play()));\n\tconnect(aboutAc, SIGNAL(triggered()), this, SLOT(about()));\n\tconnect(fsAc,    SIGNAL(triggered()), this, SLOT(fullscreen()));\n\tconnect(Quit,    SIGNAL(triggered()), qApp, SLOT(quit()));\n\n\t/* Buttons for the UI */\n\tplayBut = new QPushButton(\"Play\");\n\tQObject::connect(playBut, SIGNAL(clicked()), this, SLOT(play()));\n\n\tQPushButton *stopBut = new QPushButton(\"Stop\");\n\tQObject::connect(stopBut, SIGNAL(clicked()), this, SLOT(stop()));\n\n\tQPushButton *muteBut = new QPushButton(\"Mute\");\n\tQObject::connect(muteBut, SIGNAL(clicked()), this, SLOT(mute()));\n\n\tQPushButton *fsBut = new QPushButton(\"Fullscreen\");\n\tQObject::connect(fsBut, SIGNAL(clicked()), this, SLOT(fullscreen()));\n\n\tvolumeSlider = new QSlider(Qt::Horizontal);\n\tQObject::connect(volumeSlider, SIGNAL(sliderMoved(int)), this, SLOT(changeVolume(int)));\n\tvolumeSlider->setValue(80);\n\n\tslider = new QSlider(Qt::Horizontal);\n\tslider->setMaximum(1000);\n\tQObject::connect(slider, SIGNAL(sliderMoved(int)), this, SLOT(changePosition(int)));\n\n\t/* A timer to update the sliders */\n\tQTimer *timer = new QTimer(this);\n\tconnect(timer, SIGNAL(timeout()), this, SLOT(updateInterface()));\n\ttimer->start(100);\n\n\t/* Central Widgets */\n\tQWidget* centralWidget = new QWidget;\n\tvideoWidget = new QWidget;\n\n\tvideoWidget->setAutoFillBackground( true );\n\tQPalette plt = palette();\n\tplt.setColor( QPalette::Window, Qt::black );\n\tvideoWidget->setPalette( plt );\n\n\t/* Put all in layouts */\n\tQHBoxLayout *layout = new QHBoxLayout;\n\tlayout->setMargin(0);\n\tlayout->addWidget(playBut);\n\tlayout->addWidget(stopBut);\n\tlayout->addWidget(muteBut);\n\tlayout->addWidget(fsBut);\n\tlayout->addWidget(volumeSlider);\n\n\tQVBoxLayout *layout2 = new QVBoxLayout;\n\tlayout2->setMargin(0);\n\tlayout2->addWidget(videoWidget);\n\tlayout2->addWidget(slider);\n\tlayout2->addLayout(layout);\n\n\tcentralWidget->setLayout(layout2);\n\tsetCentralWidget(centralWidget);\n\tresize( 600, 400);\n}\n\nvoid Mwindow::openFile()\n{\n\t/* The basic file-select box */\n\tQString fileName = QFileDialog::getOpenFileName(this, tr(\"Load a file\"), \"~\");\n\n\topenFile(fileName);\n}\n\nvoid Mwindow::openFile(QString fileName)\n{\n\t/* Stop if something is playing */\n\tif (vlcPlayer && libvlc_media_player_is_playing(vlcPlayer))\n\t\tstop();\n\n\t/* Create a new Media */\n\tlibvlc_media_t *vlcMedia = libvlc_media_new_path(vlcInstance, qtu(fileName));\n\tif (!vlcMedia)\n\t\treturn;\n\n\t/* Create a new libvlc player */\n\tvlcPlayer = libvlc_media_player_new_from_media(vlcMedia);\n\n\t/* Release the media */\n\tlibvlc_media_release(vlcMedia);\n\n\t/* Integrate the video in the interface */\n#if defined(Q_OS_MAC)\n\tlibvlc_media_player_set_nsobject(vlcPlayer, (void *)videoWidget->winId());\n#elif defined(Q_OS_UNIX)\n\tlibvlc_media_player_set_xwindow(vlcPlayer, videoWidget->winId());\n#elif defined(Q_OS_WIN)\n\tlibvlc_media_player_set_hwnd(vlcPlayer, (HWND)videoWidget->winId());\n#endif\n\n\t/* And start playback */\n\tlibvlc_media_player_play(vlcPlayer);\n\n\t/* Update playback button */\n\tplayBut->setText(\"Pause\");\n}\n\nvoid Mwindow::play() {\n\tif (!vlcPlayer)\n\t\treturn;\n\n\tif (libvlc_media_player_is_playing(vlcPlayer)) {\n\t\t/* Pause */\n\t\tlibvlc_media_player_pause(vlcPlayer);\n\t\tplayBut->setText(\"Play\");\n\t}\n\telse {\n\t\t/* Play again */\n\t\tlibvlc_media_player_play(vlcPlayer);\n\t\tplayBut->setText(\"Pause\");\n\t}\n}\n\nint Mwindow::changeVolume(int vol) { /* Called on volume slider change */\n\n\tif (vlcPlayer)\n\t\treturn libvlc_audio_set_volume(vlcPlayer, vol);\n\n\treturn 0;\n}\n\nvoid Mwindow::changePosition(int pos) { /* Called on position slider change */\n\n\tif (vlcPlayer)\n\t\tlibvlc_media_player_set_position(vlcPlayer, (float)pos/1000.0);\n}\n\nvoid Mwindow::updateInterface() { //Update interface and check if song is finished\n\n\tif (!vlcPlayer)\n\t\treturn;\n\n\t/* update the timeline */\n\tfloat pos = libvlc_media_player_get_position(vlcPlayer);\n\tslider->setValue((int)(pos*1000.0));\n\n\t/* Stop the media */\n\tif (libvlc_media_player_get_state(vlcPlayer) == libvlc_Ended)\n\t\tthis->stop();\n}\n\nvoid Mwindow::stop() {\n\tif(vlcPlayer) {\n\t\t/* stop the media player */\n\t\tlibvlc_media_player_stop(vlcPlayer);\n\n\t\t/* release the media player */\n\t\tlibvlc_media_player_release(vlcPlayer);\n\n\t\t/* Reset application values */\n\t\tvlcPlayer = NULL;\n\t\tslider->setValue(0);\n\t\tplayBut->setText(\"Play\");\n\t}\n}\n\nvoid Mwindow::mute() {\n\tif(vlcPlayer) {\n\t\tif(volumeSlider->value() == 0) { //if already muted...\n\n\t\t\tthis->changeVolume(80);\n\t\t\tvolumeSlider->setValue(80);\n\n\t\t}\n\t\telse {   //else mute volume\n\n\t\t\tthis->changeVolume(0);\n\t\t\tvolumeSlider->setValue(0);\n\n\t\t}\n\t}\n}\n\nvoid Mwindow::about()\n{\n\tQMessageBox::about(this, \"Qt libVLC player demo\", QString::fromUtf8(libvlc_get_version()) );\n}\n\nvoid Mwindow::fullscreen()\n{\n\tif (isFullScreen()) {\n\t\tshowNormal();\n\t\tmenuWidget()->show();\n\t}\n\telse {\n\t\tshowFullScreen();\n\t\tmenuWidget()->hide();\n\t}\n}\n\nvoid Mwindow::closeEvent(QCloseEvent *event) {\n\tstop();\n\tevent->accept();\n}\n", "name": "tests/VLCTest/player.cpp", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, {"source": "/******************************\n* Qt player using libVLC     *\n* By protonux                *\n*                            *\n* Under WTFPL                *\n******************************/\n\n#ifndef PLAYER\n#define PLAYER\n\n#include <QtGui>\n#include <vlc/vlc.h>\n#include <QMainWindow>\n#include <QPushButton>\n#include <QSlider>\n\nclass Mwindow : public QMainWindow {\n\n\tQ_OBJECT\n\npublic:\n\tMwindow();\n\tvirtual ~Mwindow();\n\tvoid openFile(QString fileName);\n\nprivate slots:\n\tvoid openFile();\n\tvoid play();\n\tvoid stop();\n\tvoid mute();\n\tvoid about();\n\tvoid fullscreen();\n\n\tint changeVolume(int);\n\tvoid changePosition(int);\n\tvoid updateInterface();\n\nprotected:\n\tvirtual void closeEvent(QCloseEvent*);\n\nprivate:\n\tQPushButton *playBut;\n\tQSlider *volumeSlider;\n\tQSlider *slider;\n\tQWidget *videoWidget;\n\n\tlibvlc_instance_t *vlcInstance;\n\tlibvlc_media_player_t *vlcPlayer;\n\n\tvoid initUI();\n};\n\n\n\n#endif\n", "name": "tests/VLCTest/player.h", "coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}], "service_job_id": ""}